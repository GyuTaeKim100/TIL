
# 프론트엔드 아키텍처의 가장 최근 트렌드는?

## 1.HTML, CSS, JS의 탄생 : 관심의 분리와 느슨한 결합

- HTML은 서버에서 작성하는 영역
- JS 용도는 단순한 동작
- CSS는 화면의 스타일을 관리
- Controller 변경 시, 백엔드에서 페이지 전체를 클라이언트에게 다시 Delivery 함.

## 2. JQuery까지의 시대: 일단 DOM을 쉽게 쓰자

- Ajax의 탄생으로 서버에서 새 HTML을 만들지 않고도, Client와 데이터만 교환이 가능하게 됨.
- 백엔드에서 받은 데이터로 DOM을 조작하는 작업이 중요하게 됨.
- JQuery와 같은 Ajax와 DOM을 잘 다룰 수 있는 도구를 활용해서 개발하게 됨.
- 현 시점에서 JQuery의 장점
  - SPA로 작성할 필요가 없거나 구형 브라우저를 지원한다면 JQuery는 유용하다. (크로스 브라우징 문제를 고민하지 않고 간결한 코드를 작성할 수 있도록 해준다.)

## 3. HTML + JS를 합치는 게 더 낫던데? : MVC 컴포넌트 방식의 탄생

- 섹션 2의 개발자 경험을 통해서, HTML과 JS를 함께 다루는 편이 더 효율적임을 깨닳게 되었다.
  > *Controller에 의해 View가 변경되므로!*
- MVC 아키텍처를 표방하면서, 데이터를 조작하고 DOM을 조작하는 로직을 하나로 관리하려는 움직임이 생겨났다.
- 자연스럽게 화면 단위가 아닌, 컴포넌트 단위로 발전하게 됨.
- MVC 방식으로 화면을 만들고자 하는 Backbone.js와 같은 프레임워크들도 만들어졌다.

## 4. 선언적으로 만들자: 데이터 바인딩 + 템플릿 = MVVM 웹 프레임워크 춘추전국시대

- Model-View-ViewModel
- 매번 데이터 변경 때마다 템플릿 방식으로 HTML가 자동으로 관리 되는 방안이 연구 되었고, 이를 자동화 하는 과정에서 Angular.js 등의 프레임워크에서 웹 서비스를 개발하는 MVVM 아키텍처가 만들어진다.
- 이후 React, View, Angular를 비롯한 수많은 프레임워크가 이런 방식으로 만들어지기 시작한다.
- 참고
  - <https://docs.microsoft.com/ko-kr/windows/uwp/data-binding/data-binding-and-mvvm>

## 5. 컴포넌트 간 데이터 교환이 너무 복잡해: Container - Presenter 방식

- 데이터가 많아지고, 로직이 흩어지면(React 도큐먼트의 컴포넌트 설계 원칙 참고) 컴포넌트는 점차 복잡해졌다.
- 컴포넌트 재사용성이 떨어지면서, 데이터를 받아서 보여주기만 하는 Readonly 스타일의 `Presenter형 컴포넌트`와 데이터 조작을 주로 다루는 `Container형 컴포넌트`를 분리하기로 함.
  - Container에서 Props를 Presenter로 내려주면서 로직을 응집시키고, 화면을 다루는 View 컴포넌트의 재사용성 향상을 중점으로 하는 아키텍처 주류가 된다.
- 의문
  - Redux 나오기 전에는, React에서 어떻게 관심사를 분리함?
    - 답: React docs, 컴포넌트 설계 원칙 참고.
  - Normal Component? Container?
  - Pure Component (Presentational)?
  - Stateless function component? (Presentational)?

## 6. Props drilling 문제 어떻게 할거야? : Flux와 Redux (상태 관리 도구)

- 섹션 5에서, 상위 props들이 하위로 전달되는 과정에서 Props drilling이 발생한다.
- Props drilling을 최소화 또는 제거하는 방법이 연구되기 시작한다.
  - Props drilling을 활용 하는 컴포넌트 설계 원칙은 역할과 책임의 경계를 잘 분배해서 협력해야 함.
  - Props drilling을 통한 설계의 완성도가 높을지라도, 대규모 앱에서는 설계 시 고려하지 못한 문제가 발생할 확률이 높음.
    - 기능 확장 및 변경 시 State 끌어올리기 또는 State 내리기 행동에 의해서 코드 변경 비용이 발생함.
    - 특히 커브가 큰 요구사항 변경에 대해서 코드 재사용성을 보장하기 힘들다.
    - Props drilling이 이루어지는 모든 중간 계층을 함께 작업을 해야 함.
    - 또한 State 및 로직이 위치한 부분을 파악 해야 함. 그 후 Props로 관계 된 모든 중간 계층 컴포넌트를 순회 탐색하면서, Props drilling이 어떻게 이루어지고 어떻게 바꿀지를 확인해야 함.
- Props Drilling에 의한 장점으로 컴포넌트의 독립과 재사용성을 위해서 컴포넌트를 분리했지만, 단점으로 중간 계층의 컴포넌트들로 인해 오히려 *상위 컴포넌트와 하위 컴포넌트가 더 단단하게 결합하는 꼴이 된 모양이 된다.*
  - 중간 계층의 컴포넌트에 따라 최상단, 최하단 컴포넌트가 이어지게 연결되므로, 중간 계층이 많아질수록 Props drilling에 의해 보다 강하게 컴포넌트 간 결합이 발생 됨.
  - 상위 Props를 하위 컴포넌트로 전달 시, 중간 계층 컴포넌트에서 사용하지도 않은 Props를 추가해야만 하는 Props Drilling 문제가 대두하게 된다.
- *비즈니스 로직을 굳이 컴포넌트 계층구조로 만들 필요가 없는 것*을 알게 된다.
- View와 비즈니스 로직을 분리해서, 단방향 데이터 구조를 가지는 Flux 패턴이 대세가 되고, Redux 등의 상태 관리 라이브러리르 활용이 주류가 된다.
- 이 때부터, 비즈니스 로직을 컴포넌트로부터 분리하고, 별도로 관리하는 도구들이 주류가 됐으며, 이러한 개념을 `상태 관리(State management)`라고 부르게 된다.

## 너무 복잡한데?: Hooks와 Context, Recoil, Zustand, Jotai

- Redux는 너무 많은 보일러플레이트(의미는, 최소한의 변경으로 여러 곳에서 재사용되며, 반복적으로 비슷한 형태를 띠는 코드이다.)가 필요했다.
- 컨셉과 시도는 좋았지만, 엄격하고 복잡한 체계에 의해서, 대형 프로젝트가 아닌 경우에는 대부분 오버엔지니어링에 가까웠다.
- 이후 React는 Hooks API를 통해서, 조금 더 간결한 문법과 외부에서 데이터를 사용해서, 외부 비즈니스 로직을 쉽게 연동할 수 있도록 만들었다.
- 또한 Context를 통해서 Props Drilling 없이도, 상위 Props를 하위로 전달할 방법을 제공하면서 Redux는 더더욱 쓰기 싫은 기술이 되었다.
- 그렇지만 React에서 기본적으로 제공하는 Hook API, Context 만으로는, 전역적으로 상태관리가 용이하지 않았다.
- 그래서 Atom이라고 불리는 전역 객체를 이용해 데이터를 기록하고, 변경감지를 통해 View로 전달하는 형태인 Recoil이나 다른 상태 관리 도구인 Zustands, Jotai 등이 생겨났다.
- 의문
  - (Recoil을 잘 모르는 상태에서) Redux도 Hook API가 생겼는데, Recoil과 무슨 차이가 있을까? Action과 Dispatch로 처리하는 Redux가 정말 Atom보다 얼마나 비용이 많이 드는 작업일까?
  - 상호 간 트레이드-오프는?

## 일반적으로 대부분 서버 API를 관리하려고 쓰는 거 아냐? React Query, SWR, Redux Query

- 대부분의 프론트엔드에서 전역적인 상태관리가 필요한 이유는 서버와 API에 있다.
- 웹의 특성상 데이터의 보관과 조회, 수정이 서버에서 이루어져야 하고, 그렇기에 비즈니스 로직이 대부분 백엔드에 보관되기 때문이다.
- 즉 대부분 경우에는, View는 서버 데이터를 보여주고 서버에게 Action을 전달만 하는 경우가 대부분이었다.
- 백엔드와 직접 연동하는 기존 상태관리에서 처리하던 로딩, 캐싱, 무효화, 업데이트 등의 복잡한 로직들을, 단순하게 만들어주는 방식이 생겨났다.
- Model의 많은 부분을 차지하고 있었던 `API를 통한 전역 상태관리`가 간단해지는 좋은 효과가 나왔다.
- 의문
  - (다른 맥락인 질문) API를 통한 전역 상태 관리를 Redux 등의 Middleware를 사용한 이유는?
    - 결국 Redux 내부에서 Action에 대한 처리를 Store 내에서 처리해서, API와 관련된 비즈니스 로직을 상태관리 하려고?
    - 전역적 특징이 필수인 경우이므로?
    - UI 컴포넌트에 비즈니스 로직을 분리해서, 역할과 책임을 분리하려고?

## 프론트엔드 트렌드 변화

- **서버에서 생성하는 결과물이 HTML에서 JSON으로 바뀌면서, 변경된 데이터를 화면에 반영하는 개발이 프론트엔드의 중요 역할**이 되었다.
- **프론트엔드는 데이터를 화면으로 변경하는 작업을 자동화하는 방향으로, 그리고 페이지 단위에서 컴포넌트 단위로 작업 방식이 진화**하게 되었다.
- *컴포넌트의 재사용성과 독립성이 중요*해지면서 데이터를 다루는 컴포넌트와 그렇지 않은 컴포넌트를 구분하는 식으로 발전했다.
- 그로인해 *컴포넌트의 계층구조와 데이터의 계층구조가, 다른 상황에서 화면과 컴포넌트의 계층구조가 복잡해지면서, 컴포넌트 간의 데이터 교환까지 복잡해지는 결과* 를 가져온다.
- 이를 해결하기 위해서 *컴포넌트와 데이터를 분리하는 단방향 아키텍처가 제기*되고, 이때부터 컴포넌트와 데이터를 분리하는 기조가 나타나게 된다.
- 그러면서 데이터의 변화를 다루는 상태관리가 컴포넌트 프레임워크와 분리되며, 독자적인 발전양상이 나타나게 된다.
- 하지만 상태관리가 고도화되고, 코드가 복잡해지면서 `적정 기술로 상태관리 중인가`에 대한 의구심이 커졌다.
- 이후 컴포넌트와 비즈니스 로직은 분리하되, 조금 더 간결하게 데이터의 변경감지를 전달할 수 있는 형태로 발전했다.
- 또한 전역 Store 관리와 서버 상태를 보다 효과적으로 다룰 수 있는 방향으로 발전하기도 했다.
- 그밖에 상태관리를 위한 불변성 관리가 필요해지면서, 복잡해진 Nested한 Object를 다루는 방법들을 해결하기 위한 방안들이 모색되고 있다.
- 요약
  1. 컴포넌트의 계층구조가 데이터의 계층구조와 일치 하지 않으면서, 더 복잡해짐으로서 컴포넌트 간 데이터 교환이 보다 어려워짐.
  2. 컴포넌트와 비즈니스 로직의 분리를 위한 도구로서 상태관리의 등장
  3. 상태관리의 3가지 방향성
     1. 고도화 된 상태관리
     2. 간단한 전역 스토어
        - Recoil
     3. 서버 기반(API) 상태 관리

## MVI 아키텍처

- Model - View - Intent
- 사용자가 다른 동작을 하더라도, 실제로 동일한 데이터의 변화를 의미하는 경우가 있다.
- 예시로 사용자가 숫자 증가 버튼을 누르거나, 또는 위쪽 방향 키를 눌렀을 때 숫자가 1 증가하도록 설정할 수 있다.
- 이 경우 사용자가 한 행동은 다르지만, 데이터의 입장에서는 그저 동일한 동작을 수행한 셈이다.
- 이를 통해 비즈니스 로직을 2가지 계층으로 분리 할 수 있다.
  1. 사용자가 View를 통해서 전달한 UI Event를, 어떠한 데이터 변화를 변화 시킬지에 대한 의도를 전달하는 역할
  2. 전달받은 요청에 따라서, 적절한 데이터를 변화하는 역할
- 개발자들은 (바로 위) 항목 1을 사용자의 의도를 파악하는 단계로 정의하고, 이를 Intent라 정의했다.
- 항목 2는 데이터를 다루므로, 전통적인 이름인 Model로 정의헀다.
- MVI 특징
  - MVC나 MVI의 다른점은 컨셉의 적용 범위이다.
    - MVC는 하나의 컴포넌트 계층 단위이다.
    - MVI는 하나의 컴포넌트 계층 단위가 아닌, 앱 전체에 적용이 되는 것.
  - 주요 특징으로 데이터의 방향성이 단방향으로 연결이 되며, 데이터가 전역적으로 구성이 되는 것이 특징이다.
  - View는 모델에 의존적이지만, 비즈니스 로직은 View와 의존성이 없으므로, 화면 변화에 유연하며 분리된 환경에서 테스트를 수행하기 편하다.
  - 또한 컴포넌트 간 데이터 통신에 의존하지 않으므로, 일관성 있는 상태를 유지하기도 용이하다.
  - 기타
        1. 데이터가 단방향으로 순환하므로, 데이터의 흐름을 쉽게 이해하고 디버깅을 하기 쉬워진다.
        2. 비즈니스 로직이 View에 의존하지 않으므로, UI 변화 요구사항에 유연하게 대응할 수 있다.
        3. View의 생명주기와 무관하게 일관성 있는 상태를 갖으므로, 컴포넌트 생명주기에 따른 상태 동기화 문제를 해결한다.
- 의문
  - 만약 Redux에 모든 비즈니스 로직 몰아넣고, Action을 통해서만 비즈니스 로직과 상태를 관리한다면, 이는 MVI 아키텍처인가?
    - Redux와 Redux 액션을 Custom Hook으로 관리하면 MVI 인가?
  - Redux Present, Container 패턴 또한 MVI로 볼 수 있는가? Present, Container로 결합되므로 아닌가?

## 프론트엔드 아키텍처의 방향성 요약정리

- 재사용이 가능한 독립적인 컴포넌트를 조립하여 서비스를 구성하는 기존 구조와 다르게, 현재 프론트엔드 방향성은 뷰 로직과 비즈니스 로직을 완전히 분리하여 생각하고 있다.
- 비즈니스 로직의 구성은, (1)데이터를 관장하는 Model과 (2)사용자의 행동을 데이터 변화로 매핑하는 Intent 영역으로 분리한다.
- Model의 구성은, (1)변화를 감지하고 변경사항을 전파하는 영역과 (2)데이터를 변화하는 로직을 구분하여 작성한다.
  - 의문
    - React Hook은 이에 해당하는가?
- 이를 통해 View에서는 Model로부터 데이터를 조회하는 Query와 데이터를 변화시키는 Command를 언제든 조립해서 사용 (CQRS 패턴) 할 수 있다.
  - 의문
    - CQRS 패턴?
- View는 비즈니스 로직에 의존적이지만, View 끼리는 느슨하게 결합 되어서 UI 요구사항 변화에 기민하게 대응할 수 있게 된다.
- 의문
  - 기존 상태관리와 MVI의 차이점은?

## Container - Presentation 방식은 안티 패턴인가?

- 전통적인 독립 UI 컴포넌트가 필요 없는 건 아니다.
- 프론트엔드에서 컴포넌트 계층의 맨 아래에 있는 재사용이 가능한 독립적인 UI 컴포넌트를 조립하여 화면을 만드는 전략은 여전히 유효하다.
- 그러나 Props Drilling을 유발하며 경직된 구조를 만들어내는 중간 계층의 컴포넌트들은 사실 독립적일 필요도 없고, 재사용도 되지 않는 컴포넌트인 경우가 많다. 이러한 컴포넌트들은 대개 비즈니스 로직을 담당하기 때문에 ‘거대한 컴포넌트(Massive-View-Container)’가 되기 마련이다.
- **기존에는 ‘컴포넌트’는 독립성을 유지하고 의존성을 최소화해야 한다는 원칙에 최대한 Props를 통해서 컴포넌트 계층 구조를 유지하려고 했다. 하지만 이 방식이 되려, 경직된 구조를 만들어 냈으므로, 어차피 재사용하지 못할 컴포넌트라면 비즈니스 모듈에 의존적이더라도 언제든 교체가능한 방식으로 만들어내는 것이 변화에 대응하기 좋을 수 있다.)**
  - **hooks의 도입된 이유**
  - React Query 컨셉

## One more thing: Intent와 Reducer

- Flux 패턴에서는, 생소한 개념인 Reducer를 사용해서 ‘왜 이렇게 작성해야 하는지?’에 대해 의문을 품는 사람들이 많다.
- 일반적으로 보통 이벤트 핸들러에서 직접 모델의 여러 데이터들의 변화를 기술하는 식으로 작성하는 경우가 많다.
- 이러한 방식은 우리가 알고 있는 실행 순서와 일치하기 때문에 작성 시에는 어렵지 않다.
- 그러나 문제는 디버깅할 때 이다.
- 디버깅은 결과를 보고 원인을 찾아내는, 역순의 과정을 밞아야 하기 때문에 특정 데이터의 변화를 다 추적해야 할 필요가 생긴다.
- 특히 데이터가 변화하는 View 코드에 흩어져 있으면, 어떤 식으로 데이터가 변화하는지 추적이 어렵다.
- 만약 View에서 직접 데이터를 수정하도록 작성하게 되면, View와 Model 간의 의존성 외에 Model과 View간의 의존성까지 생기게 된다.
- **따라서 View에서는 의도만을 전달하고, 의도에 맞는 데이터 변환은 모델에서만 처리할 수 있도록 만들어야 한다.**
- 데이터를 변환하는 코드를 Model 모듈에 모아서 응집도가 높이면, 추후 디버깅에 용이하며, 특히 View가 비즈니스 로직으로부터 느슨한 결합을 할 수 있다. (코드를 모듈화(응집도 향상)를 통한 파편화 제거)
- 의문
  - **Intent와 Reducer는 어떤 부분에서 차이가 있는가?**
## 참고

- <https://yozm.wishket.com/magazine/detail/1663/>

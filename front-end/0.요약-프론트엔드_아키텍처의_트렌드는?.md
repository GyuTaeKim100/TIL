
# 프론트엔드 아키텍처의 가장 최근 트렌드는?

## 1.HTML, CSS, JS의 탄생 : 관심의 분리와 느슨한 결합

- HTML은 서버에서 작성하는 영역
- JS 용도는 단순한 동작
- CSS는 화면의 스타일을 관리
- Controller 변경 시, 백엔드에서 페이지 전체를 클라이언트에게 다시 Delivery 함.

## 2. JQuery까지의 시대: 일단 DOM을 쉽게 쓰자

- Ajax의 탄생으로 서버에서 새 HTML을 만들지 않고도, Client와 데이터만 교환이 가능하게 됨.
- 백엔드에서 받은 데이터로 DOM을 조작하는 작업이 중요하게 됨.
- JQuery와 같은 Ajax와 DOM을 잘 다룰 수 있는 도구를 활용해서 개발하게 됨.
- 현 시점에서 JQuery의 장점
  - SPA로 작성할 필요가 없거나 구형 브라우저를 지원한다면 JQuery는 유용하다. (크로스 브라우징 문제를 고민하지 않고 간결한 코드를 작성할 수 있도록 해준다.)

## 3. HTML + JS를 합치는 게 더 낫던데? : MVC 컴포넌트 방식의 탄생

- 섹션 2의 개발자 경험을 통해서, HTML과 JS를 함께 다루는 편이 더 효율적임을 깨닳게 되었다.
  > *Controller에 의해 View가 변경되므로!*
- MVC 아키텍처를 표방하면서, 데이터를 조작하고 DOM을 조작하는 로직을 하나로 관리하려는 움직임이 생겨났다.
- 자연스럽게 화면 단위가 아닌, 컴포넌트 단위로 발전하게 됨.
- MVC 방식으로 화면을 만들고자 하는 Backbone.js와 같은 프레임워크들도 만들어졌다.

## 4. 선언적으로 만들자: 데이터 바인딩 + 템플릿 = MVVM 웹 프레임워크 춘추전국시대

- Model-View-ViewModel
- 매번 데이터 변경 때마다 템플릿 방식으로 HTML가 자동으로 관리 되는 방안이 연구 되었고, 이를 자동화 하는 과정에서 Angular.js 등의 프레임워크에서 웹 서비스를 개발하는 MVVM 아키텍처가 만들어진다.
- 이후 React, View, Angular를 비롯한 수많은 프레임워크가 이런 방식으로 만들어지기 시작한다.
- 참고
  - <https://docs.microsoft.com/ko-kr/windows/uwp/data-binding/data-binding-and-mvvm>

## 5. 컴포넌트 간 데이터 교환이 너무 복잡해: Container - Presenter 방식

- 데이터가 많아지고, 로직이 흩어지면(React 도큐먼트의 컴포넌트 설계 원칙 참고) 컴포넌트는 점차 복잡해졌다.
- 컴포넌트 재사용성이 떨어지면서, 데이터를 받아서 보여주기만 하는 Readonly 스타일의 `Presenter형 컴포넌트’와 데이터 조작을 주로 다루는 ‘Container형 컴포넌트’를 분리하기로 함.
  - Container에서 Props를 Presenter로 내려주면서 로직을 응집시키고, 화면을 다루는 View의 재사용성 향상을 중점으로 하는 아키텍처 주류가 된다.
- 의문
  - Redux 나오기 전에는, React에서 어떻게 관심사를 분리함?
    - 답: React docs, 컴포넌트 설계 원칙 참고.
  - Normal Component? Container?
  - Pure Component (Presentational)?
  - Stateless function component? (Presentational)?

## 6. Props drilling 문제 어떻게 할거야? : Flux와 Redux (상태 관리 도구)

- 섹션 5에서, 상위 props들이 하위로 전달되는 과정에서 Props drilling이 발생한다.
- Props drilling을 최소화 또는 제거하는 방법이 연구되기 시작한다.
  - Props drilling을 활용 하는 컴포넌트 설계 원칙은 역할과 책임의 경계를 잘 분배해서 협력해야 함.
  - Props drilling을 통한 설계의 완성도가 높을지라도, 대규모 앱에서는 설계 시 고려하지 못한 문제가 발생할 확률이 높음.
    - 기능 확장 및 변경 시 State 끌어올리기 또는 State 내리기 행동에 의해서 코드 변경 비용이 발생함.
    - 특히 커브가 큰 요구사항 변경에 대해서 코드 재사용성을 보장하기 힘들다.
    - Props drilling이 이루어지는 모든 중간 계층을 함께 작업을 해야 함.
    - 또한 State 및 로직이 위치한 부분을 파악 해야 함. 그 후 일일이 자식 컴포넌트를 순회 탐색하면서 Props drilling이 어떻게 이루어지고 어떻게 바꿀지를 확인해야 함.
- 이로인해, 컴포넌트의 독립과 재사용성을 위해서 컴포넌트를 분리헀지만, 중간 컴포넌트로 인해 오히려 *상위 컴포넌트와 하위 컴포넌트가 더 단단하게 결합하는 꼴이 된 셈*이다. (중간 컴포넌트에 따라 상, 하가 정상적으로 연결되므로, 중간 계층이 많아질수록 Props drilling에 의해 보다 강하게 결합하게 됨.)
- 상위 Props를 하위 컴포넌트로 전달 할때, 중간 컴포넌트에서 사용하지도 않은 Props를 추가해야 하는 Props Drilling 문제가 대두하게 된다.
- *비즈니스 로직을 굳이 컴포넌트 계층구조로 만들 필요가 없는 것*을 알게 된다.
- View와 비즈니스 로직을 분리해서, 단방향 데이터 구조를 가지는 FLUX 패턴이 대두 되고, Redux 등을 통해 사용하게 되면서 이러한 형태가 주류 아키텍처가 됬다.
- 이 때부터, 비즈니스 로직을 컴포넌트로부터 분리하고, 별도로 관리하는 도구들이 주류가 됐으며, 이러한 개념을 ‘상태 관리(State management)’라고 부르게 된다.

## 너무 복잡한데?: Hooks와 Context, Recoil, Zustand, Jotai

- Redux는 너무 많은 보일러플레이트(최소한의 변경으로 여러 곳에서 재사용되며, 반복적으로 비슷한 형태를 띠는 코드를 의미함)가 필요했다.
- 컨셉과 시도는 좋았지만, 과한 문법 체계를 가지고 있었기에 대형 프로젝트가 아니라면 중소규모에서 대부분 오버엔지니어링에 가까웠다.
- 이후 React는 조금 더 간결한 문법과 외부에서 데이터를 사용할 수 있도록, Hooks를 통해서 외부 비즈니스 로직을 쉽게 연동할 수 있도록 만들었다.
- 또한 Context를 통해서 Props Drilling 없이도 상위 Props를 하위로 전달할 방법을 제공하면서 Redux는 더더욱 쓰기 싫은 기술이 되었다.
- 그렇지만 React에서 기본적으로 제공하는 Hook API만으로는, 전역적으로 상태관리가 용이하지 않았다.
- 그래서 Atom이라고 불리는 전역 객체를 이용해 데이터를 기록하고, 변경감지를 통해 View로 전달하는 형태인 Recoil이나 Zustands, Jotai같은 방식이 최근 새로운 대안으로 제시되고 있다.
- 의문
  - (Recoil을 잘 모르는 상태) Redux도 Hook API가 생겼는데, Recoil과 무슨 차이가 있을까? Action과 Dispatch로 처리하는 Redux가 정말 Atom보다 얼마나 비용이 많이 드는 작업일까?
  - 상호 간 트레이드-오프는?

## 어차피 대부분 서버 API를 관리하려고 쓰는 거 아냐? React Query, SWR, Redux Query

- 대부분의 프론트엔드에서 전역적인 상태관리가 필요한 이유는 서버와 API에 있다.
- 웹의 특성상 데이터의 보관과 조회, 수정이 서버에서 이루어져야 하고, 그렇기에 비즈니스 로직이 대부분 백엔드에 보관되기 때문이다.
- 즉 대부분 경우에는, View는 서버 데이터를 보여주고 서버에게 Action을 전달만 하는 경우가 대부분이었다.
- 백엔드와 직접 연동해 기존 상태관리에서 로딩, 캐싱, 무효화, 업데이트 등 복잡하게 진행하던 로직들을 단순하게 만들어주는 방식이 생겨났다.
- 모델의 많은 부분을 차지하고 있었던 ‘API를 통한 전역 상태관리’가 단순해지는 결과가 나왔다.
- 의문
  - API를 통한 전역 상태 관리를 Redux 등의 Middleware를 사용한 이유는?
    - 결국 리덕스 내에서 스토어와 관련 있는 비즈니스 로직을 관리하려고?
    - API는 비즈니스 로직이니까?
    - 어디서든 접근 가능하려고?
    - UI 컴포넌트는 언제든 교체 가능하게 하려고?

## 프론트엔드 트렌드 변화

- **서버에서 생성하는 결과물이 HTML에서 JSON으로 바뀌면서, 변경된 데이터를 화면에 반영하는 개발이 프론트엔드의 역할**이 되었다.
- **프론트엔드는 데이터를 화면으로 변경하는 작업을 자동화하는 방향으로, 그리고 페이지 단위에서 컴포넌트 단위로 작업 방식이 진화**함.
- *컴포넌트의 재사용성과 독립성이 중요*해지면서 데이터를 다루는 컴포넌트와 그렇지 않은 컴포넌트를 구분하는 식으로 발전했다. 그렇지만 *컴포넌트의 계층구조와 데이터의 계층구조가, 다른 상황에서 화면과 컴포넌트의 계층구조가 복잡해지다 보니, 컴포넌트 간의 데이터 교환까지 복잡해지는 결과* 를 가져온다.
- 이를 타파하기 위해 *컴포넌트와 데이터를 분리하는 단방향 아키텍처가 제기*되고, 이때부터 컴포넌트와 데이터를 분리하는 기조가 나타나게 된다. 그러면서 데이터의 변화를 다루는 상태관리가 컴포넌트 프레임워크와 분리되며, 독자적인 발전양상이 나타나게 된다.
- 하지만 상태관리가 고도화되고, 코드가 복잡해지면서 ‘제대로 기능하는지’에 대한 의구심이 커졌다.
  - 의문
    - 어떤 의구심?
- 이후 컴포넌트와 비즈니스 로직은 분리하되, 조금 더 간결하게 데이터의 변경감지를 전달할 수 있는 형태로 발전했다. 또한 전역적인 데이터 스토어 방향과 서버 상태를 조금 더 편하게 다룰 수 있는 방향으로 발전하기도 했다.
- 그밖에 상태관리를 위한 불변성 관리가 필요해지면서 복잡해진 Nested한 Object를 다루는 방법들을 해결하기 위한 방안들이 모색되고 있다.

  1. 컴포넌트의 계층구조가 데이터의 계층구조와 일치 하지 않으면서, 더 복잡해짐으로서, 컴포넌트 간 데이터 교환이 보다 어려워짐.
  2. 컴포넌트와 비즈니스 로직의 분리 -> 상태관리의 등장
  3. 상태관리의 3가지 방향성
     1. 고도화 된 상태관리
     2. 간단한 전역 스토어
        - Recoil?
        - 또는 Viewlet 강사분이 말씀하신 블랙박스 개념의 Store 개념?
            - Reducer에 대한 구조를 모르는 상태에서, Store를 활용하고 싶을 떄?
     3. 서버 기반(API) 상태 관리

## MVI 아키텍처

- Model - View - Intent
- 사용자가 다른 동작을 하더라도, 실제로 동일한 데이터의 변화를 의미하는 경우가 있다.
- 에시로 사용자가 숫자 증가 버튼을 누르거나, 또는 위쪽 방향 키를 눌렀을 때 숫자가 1 증가하도록 설정할 수 있다.
- 이 경우 사용자가 한 행동은 다르지만, 데이터의 입장에서는 같은 동작을 수행한 셈이다.
- 이를 통해 비즈니스 로직을 2가지 레이어로 나눌 수 있다.
  1. 사용자가 View를 통해서 전달한 UI Event를, 어떠한 데이터 변화를 변화 시킬지를 전달하는 역할
  2. 전달받은 요청에 따라서 적절히 데이터를 변화하는 역할

- 개발자들은 항목 1을 사용자의 의도를 파악하는 단계로 정의하고, 이를 Intent라 정의했다.
- 항목 2는 데이터를 다루므로, 전통적인 이름인 Model로 정의헀다.
- MVI 특징
  - MVC나 MVVM과 다른점은 이 구성이 하나의 컴포넌트가 아니라 앱 전체에 적용이 되는 것.
  - 전체적으로 데이터의 방향성이 단방향으로 연결이 되며, 데이터가 전역적으로 구성이 되는 것이 특징이다.
  - View는 모델에 의존적이지만 비즈니스 로직은 View와의 의존성이 없기 때문에 화면변화에 유연하며, 별도로 테스트하기 쉽다.
  - 또한 컴포넌트 간 데이터 통신에 의존하지 않기 떄문에 일관성 있는 상태를 유지하기도 용이하다.
  - 특징 정리
        1. 데이터가 단방향으로 순환한다 -> 데이터의 흐름을 이해하고 디버깅을 하기 쉬워진다.
        2. 비즈니스 로직이 View에 의존하지 않는다. -> UI 변화 요구사항에 유연하게 대응할 수 있다.
        3. View의 생명주기와 무관하게 일관성 있는 상태를 갖는다 -> 컴포넌트 생명주기에 따른 상태 동기화 문제를 해결한다.
- 즉 FLUX 패턴, Redux 패턴, 상태관리 등 그 동안 프론트엔드에서 줄곧 제시되었던 방법들을 잘 정리하여 아키텍처로서 구성된 형태를 지닌다.
- 의문
  - Redux에 모든 비즈니스 로직 몰아넣으면 그게 MVI 아키텍처인가?
  - Redux Present, Container 패턴도 MVI로 볼 수 있는가? MVI의 정확한 기준을 모르겠다.
  - Redux와 Redux 액션을 Custom Hook으로 관리하면 MVI 인가?

## 프론트엔드 아키텍처의 방향성 요약정리

- 재사용이 가능한 독립적인 컴포넌트를 조립하여 서비스를 구성하는 기존 구조와 달리 현재 프론트엔드 방향성은 View와 비즈니스 로직을 완전히 분리하여 생각하고 있다.
- 비즈니스 로직은 1) 데이터를 관장하는 Model과 2)사용자의 행동을 데이터 변화로 매핑하는 Intent 영역으로 분리한다.
- Model은 다시 1) 변화를 감지하고 변경사항을 전파하는 영역과 2) 데이터를 변화하는 로직을 구분하여 작성한다.
- 이를 통해 View에서는 Model로부터 데이터를 조회하는 Query와 데이터를 변화시키는 Command를 언제든 조립해서 사용 (CQRS 패턴) 할 수 있다.
- 또한 View는 비즈니스 로직에 의존적이지만, View끼리는 느슨하게 결합하여 UI 요구사항 변화에 긴밀하게 대응할 수 있게 된다.

## 의문: 기존 상태관리와 MVI의 차이점은?

## 기존 방법은 안 좋은 것일까?

- 전통적인 독립 UI 컴포넌트가 필요 없는 건 아니다.
- 프론트엔드에서 컴포넌트 계층의 맨 아래에 있는 재사용이 가능한 독립적인 UI 컴포넌트를 조립하여 화면을 만드는 전략은 여전히 유효하다.
- 그러나 Props Drilling을 유발하며 경직된 구조를 만들어내는 중간 계층의 컴포넌트들은 사실 독립적일 필요도 없고, 재사용도 되지 않는 컴포넌트인 경우가 많다. 이러한 컴포넌트들은 대개 비즈니스 로직을 담당하기 때문에 ‘거대한 컴포넌트(Massive-View-Container)’가 되기 마련이다.
- **기존에는 ‘컴포넌트’는 독립성을 유지하고 의존성을 최소화해야 한다는 원칙에 최대한 props를 통해서 컴포넌트 계층 구조를 유지하려고 했다. 하지만 이 방식이 되려 경직된 구조를 만들어 냈기에 어차피 재사용하지 못할 컴포넌트라면 비즈니스 모듈에 의존적이더라도 언제든 교체가능한 방식으로 만들어내는 것이 변화에 대응하기 좋을 수 있다.**
- **hooks의 도입 이유**
- 의문
- props drilling을 없애면 계층 구조가 최소화가 될까? 최소화는 안되나 줄어들 것이다.

## One more thing: Intent와 Reducer

- FLUX 패턴에서는 생소한 개념인 Reducer는 ‘왜 이렇게 작성해야 하는지?’에 대해 의문을 품는 사람들이 많다.

- 일반적으로 보통 이벤트 핸들러에서 직접 모델의 여러 데이터들의 변화를 기술하는 식으로 작성하는 경우가 많다.
- 이러한 방식은 우리가 알고 있는 실행 순서와 일치하기 때문에 작성할 떄는 어렵지 않다.
- 그러나 문제는 디버깅할 때 이다.
- 디버깅은 결과를 보고 원인을 찾아내는 역순의 과정을 밞아야 하기 때문에 특정 데이터의 변화를 다 추적해야 할 필요가 생긴다.
- 이 때 데이터가 변화하는 View 코드에 흩어져 있으면 어떤 식으로 데이터가 변화하는지 추적이 어렵다.
- 그뿐만 아니라 View에서 직접 데이터를 수정하도록 작성하게 되면 View와 모델 간의 의존성 뿐만 아니라 모델과 View간의 의존성이 생기게 된다(무슨 말?)
- **따라서 View에서는 의도만을 전달하고 의도에 맞는 데이터 변환은 모델에서만 처리할 수 있도록 만들어야 한다.**
- 데이터를 변환하는 코드를 Model 모듈에 모으게 되면 응집도가 높아지고 추후 디버깅에 용이하며, 특히 View가 비즈니스 로직으로부터 느슨한 결합을 할 수 있다.
- **결론으로 Intent와 Reducer는 어떤 부분에서 차이가 있는가?**
- 코드를 모듈화(응집도 향상)를 통한 파편화 제거

## 참고

- <https://yozm.wishket.com/magazine/detail/1663/>

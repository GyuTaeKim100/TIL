# Module system history

## 최초의 JavaScript

- 간단한 모듈 시스템
- HTML에서 JavaScript 원본 소스를 제공하고, 브라우저에서 이것을 순서대로 로드하는 방식
- 예제

- ```
    <html>
        <script src="/src/foo.js"></script>
        <script src="/src/bar.js"></script>
        <script src="/src/baz.js"></script>
        <script src="/src/quz.js"></script>
   ```

- 문제점
  - Script를 로드한 전역 컨텍스트에서 각 모듈 간 충돌이 발생함.
    - 예시로, `foo.js`에서 선언한 변수와 같은 이름을 가진 변수가 `bar.js`에 선언되어 있는 경우, 나중에 호출된 `bar.js`의 변수로 재정의가 되면서 `foo.js`의 파일이 제대로 동작하지 않게 된다.
  - 즉, 모듈 간 스코프가 구분되지 않아 다른 파일을 오염시킴.
    - 이를 해결하기 위해서,
      - 개발자들은 다른 모듈과 변수 이름이 겹치지 않도록 모듈 순서를 지정하는 데에 불필요한 시간 낭비를 함.
- 웹의 역할이 단순 문서 보여주기를 넘어서, 애플리케이션 플랫폼에 가까워지면서 문제점이 더욱 부각 됨.
- 2008년도에 브라우저 외부에서도 JavaScript를 실행시킬 수 있는 Google V8 엔진이 공개되면서, 이를 이용해 서버 사이드에서 JavaScript를 활용하자는 아이디어가 제시됨.
- 이로 인해 모듈화에 대한 필요성이 더욱 부각 되었고, 2009년을 기점으로 JavaScript의 모듈을 표준화하기 위한 움직임이 본격적으로 시작되었다.
- 이 떄 등장한 것이, CommonJS와 AMD(Asynchronous Module Definition)이다.

## Common JS

- JavaScript를 브라우저 뿐 아닌, 서버 사이드 애플리케이션이나 데스크톱 애플리케이션 등에서 보다 범용적인 용도를 목적으로 한 모듈시스템.
- 예제

  - ```
      // CommonJS

      // 모듈 정의
      module.exports = foo;

      // 모듈 사용
      const foo = require("./foo");
    ```

- 범용적인 JavaScript 모듈 시스템이므로, **모든 디펜던시가 로컬 디스크에 존재해서 필요한 모듈을 바로 사용할 수 있는 호나경을 전제로 함.**
- **따라서 동기적(Synchronously)으로 모듈을 호출하는 방식을 채택함.**
- `required`와 `exports` 키워드를 활용한 직관적이고 간단한 문법이 가독성은 좋다.
- 단점
  1. 비동기 방식보다 느리고, 트리 쉐이킹(tree shaking, 임포트 처리되었으나, 실제로는 사용되지 않는 코드를 분석하고 삭제하는 코드 최적화 기술)이 어려움.
  2. 순환 참조에 취약함.
  3. 브라우저에서 사용할 수 없음.
  - 의문
    - 구체적으로 왜?
- JavaScript 런타임인 Node.js는 CommonJS 방식의 명세를 채택하고 구현함.
- 추후 브라우저 호환성을 위한 Browserify가 탄생하게 됨.

## AMD (Asynchronous Module Definition)

- 초창기에는 AMD의 목적은 브라우저에서 모듈 시행의 우선순위가 높았음.
  - 이유는 브라우저에서는 필요한 모듈들을 네트워크를 통해 비동기적으로 다운로드한 후, 사용할 수 있었다.
- 예제

  - ```
      // AMD

      // 모듈 정의
      define([
        'jquery',
        'underscore'
        // 의존 모듈들을 배열로 나열
      ], function ($, _) {
        // 의존 모듈들은 순서대로 매개변수에 당김

        return {
          // 외부에 노출할 함수들만 반환
        }
      })

      // 모듈 사용
      require([
        ...
        // 사용할 모듈 배열로 나열

      ], function (...) {
        // 사용할 모듈들이 순서대로 매개변수에 당김
      })
    ```

- CommonJS와 비교 시
  - 복잡한 문법이지만, 비동기적으로 모듈을 호출하는 특성 때문에 퍼포먼스 측면에서는 CommonJS 보다 나은 성능을 보인다.
  - 브라우저와 서버 사이드에서 모두 호환되는 방식이다.
- AMD 명세로 구현된 대표적인 모듈 로더 라이브러리는 RequireJS가 있다.

## UMD (Universal ModuleDefinition) 패턴

- CommonJS와 AMD는 서로 지향하는 목적이 다른 부분에서, 통일되지 않은 규격들의 발생은 결국 서로 간 호환성 문제로 이어진다.
- CommonJS와 AMD 방식을 모두 호환할 수 있도록 조건문으로 분기하고, 이를 팩토리 패턴으로 구현함.
- 예제

  - ```
      (function (root, factory){
        if(typeof define === "function" && define.amd) {
          // AMD 방식
          define(["jquery", "underscore"], factory);
        } else if (typeof exports === "object") {
          // CommonJS 방식
          module.exports = factory(require("jquery"), require("underscore"));
        } else {
          root.foo=factory(root.$, root._)
        }
      })(this, function ($, _)) {
        // 모듈 정의
        var foo = {
          // ...
        }

        return foo;
      })
    ```

- window 객체를 통해 전역적으로 접근 또한 가능하다.
- 임시방편으로 두 방식을 모두 호환할 수 있었기 때문에, 라이브러리를 만들 때 자주 사용되는 패턴이다.
- 만약 웹팩과 롤업 같은 몇몇 번들러들은 ES6방식으로 모듈 로드에 실패했을 때, 대안책(fallback)으로 UMD 패턴으로 로드하는 방식을 아직도 사용하고 있다고 한다.

## ES6 Module

- UMD 또한 CommonJS와 AMD의 호환성을 해결할 뿐이고, 모듈 시스템의 부재라는 근본적인 문제를 해결하지 못헀다.
- JavaScript 언어 차원에서 모듈 시스템을 지원해야 하는 필요성이 생김.
- 예제

  - ```
      // ES6
      import foo from "bar";

      export default qux;
    ```

- 특징
  - 동기/비동기를 모두 지원함.
  - 간단한 문법
  - CommonJS와 다르게, 실제 객체/함수를 바인딩하기 때문에 순환 참조 관리가 편리함.
  - 정적 분석(static analyze, 코드를 실행하지 않더라도 분석이 가능함) 지원
  - 쉬운 트리 쉐이킹 지원
- 단점
  - 구형 브라우저에서 제대로 동작하지 않음.
  - SystemJS가 나온 배경이 되기도 함.

## 모듈 로더 (Module loader)

- JavaScript 모듈을 런타임에 로드할 수 있게 만드는 구현체
- AMD의 모듈 로더는 RequireJS이고,
- ES6 방식 모듈 로더는 네이티브 브라우저가 될 수 있다.
- SystemJS는 모든 모듈을 로드할 수 있으므로, ES6, CommonJS, AMD 방식의 모듈 로더이다.

## 트랜스파일러

- 한 번 컴파일하면 구형 브라우저에서도 동작하는 JavaScript 코드를 만드는 도구
  - ES6 문법을 구형 브라우저에서 사용하지 못해서 SystemJS 같은 라이브러리에 의존해야 하는 상황에 대한 대처
- 대표적으로 바벨(Babel)이 있다.
  - 최신 JavaScript 문법을 사용하되,
  - 바벨로 컴파일 후, 같은 동작을 하는 구형 브라우저에 호환되는 JavaScript 코드로 변환한다.
- 또는 CoffeScript, TypeScript 같은 JavaScript의 슈퍼셋 (Superset) 언어를 통해서 해결이 가능하다.

## 태스크 러너 (Task Runner)

- 프로덕트 개발 과정에서 필요한 일련의 과정들(린팅, 빌딩, 테스팅 등)을 자동화하기 위한 도구이다.
- 탄생 배경
  - Common JS, AMD, UMD 방식의 모듈 시스템의 주 목적은 바로 스코프이다.
  - 스코프가 구분되는 모듈을 만드는 목적은, 여러 모듈을 조합해 중복되는 코드를 줄이면서도, 생산성과 퍼포먼스가 뛰어난 애플리케이션을 만들기 위해서이다.
  - 이를 위해서는 개발 과정에서 코드를 작성하고, 컨벤션을 유지하기 위해 린트를 사용하며, Sass나 TypeScript처럼 전처리가 필요한 언어를 컴파일하고, 소스 코드를 축소(Minify) 후 하나로 묶는(Bundle) 일련의 과정이 필수적으로 동반한다.
  - 이러한 과정들의 반복의 비용을 최소화하기 위해서, 특정 작업들을 자동화 할 수 있는 도구의 필요성이 생김.
  - 그 결과가 태스크 러너이다.
  - 이전에는 프론트엔드 생태계에서 크게 필요성이 없었고, 태스크 자동화에 대한 뚜렷한 성과가 없었다.
- 대표적으로 Grunt, Gulp, Make가 있다.
- Grunt, Gulp는 테스트나 린트, 번들, 최적화 플러그인들을 제공해주면서 이 과정들을 자동화 할 수 있게 도와주었다.
- 생산성 측면에서, 이 과정에서 빌드를 위한 태스크 러너의 한 과정이었던 번들에 대해서, 보다 전문적으로 도와주는 도구가 필요해졌고, 이것이 바로 모듈 번들러의 등장이다.

## 모듈 번들러 (Module Bundler)

- JavaScript 모듈을 브라우저에서 실행할 수 있는 단일 JavaScript 파일로 번들링 할 경우에 사용되는 프론트엔드 개발 도구이다.
- 모듈 로더와 차이점
  - 모듈 번들러는 코드를 프로덕션 환경에서 사용할 수 있도록 준비하는 부분에 더 큰 목적이 있다.
  - 모듈 로더는 일반적으로 런타임에 모듈을 가져오기 위한 목적인 반면, 번들러는 빌드 시 모듈을 묶어 단일 번들 파일로 만들기 때문에 런타임에서 추가적인 로드를 할 필요가 없다.
- 모듈 번들러의 사용 이유
  1. 브라우저가 모듈 시스템을 완전히 지원하지 않음.
  2. 코드의 종속성 관리에 이점
  3. 종속성 순서대로 이미지, CSS 에셋 등을 로드하는 데 도움이 됨.

- 번들러 활용

  - JavaScript 모듈을 브라우저에서 실행할 수 있는 단일 JavaScript 파일로 번들링
  - 사용하지 않는 코드 제거 등의 최적화 작업
- 최근에는 번들러 자체적으로 개발, 빌드, 최적화를 위한 각종 플러그인을 제공하므로, 굳이 별도의 태스크 러너나 최적화 도구를 사용하지 않아도 됨.
- 대표적인 툴로, 웹팩, 롤업, 파셀이 있다.

## Webpack

- 장점
  - 웹 애플리케이션에서 사용하는 CSS, 이미지 에셋들을 JavaScript 코드로 변환하고, 이를 분석해서 번들링함.
    - 이로 인해, 웹팩의 구성은 다른 번들러에 비해 설정할 부분이 많고 복잡함.
  - 개발 서버
    - 라이브 리로딩(Live reloading) 지원
      - 개발 중 변경사항을 자동으로 새로고침함.
    - 핫 모듈 교체 (HMR, Hot Module Replacement) 지원
    - 새로고침 없이 런타임에 브라우저의 모듈을 업데이트
  - 트리 쉐이킹 지원
    - 단 CommonJS 방식으로 모듈을 로드한 부분을 ES6 문법으로 교체해야 하고, `package.json` 파일에 `SideEffect` 플래그를 설정해야 하며, `UglifyJSPlugin`, `Tester`같은 별도의 플러그인을 설치하는 번거로운 추가 과정이 필요함.
- 단점
  - 아직까지 ES6 모듈 형태로 빌드 결과물을 출력할 수 없음.
  - 복잡한 문서로 인한 높은 러닝 커브

## Rollup

- 장점
  - ES6 모듈 형식으로 빌드 결과물을 출력할 수 있음.
    - 라이브러리 패키지 개발에 활용
      - 웹팩과 파셀은 자체 로더가 존재하나, 롤업은 ES6 모듈이 기본이다.
    - 코드 스플리팅 측면에서 다른 번들러에 비해 강점이 있다.
      - 중복 제거에 특화
        - 진입점(entry point)이 여러 개 있을 때 이 부분이 특히 두드러짐. 롤업은 진입점이 다르기 때문에 중복해서 번들될 수 있는 부분을 공통으로 알아내고 독립된 모듈로 분리해 낼 수 있다.
        - 웹 워커(Web Workser)와 메인 쓰레드 간에도 코드 스플리팅이 가능
- 단점
  - 파일의 해시 캐스캐이딩(hash cascading, 하나의 파일의 해시가 바뀌면 그것을 참조한 파일의 해시도 알아서 교체)이 약함.

## Parcel

- 장점
  - 별도 설정 파일 없이 동작함 (Zero config)
    - 설치만 하면, 별도의 설정 파일 없이 빌드 명령어를 통해서 바로 사용 가능
      - 파셀은 JavaScript 엔트리 포인트를 지정해 주는 방식이 아닌, 애플리케이션 진입을 위한 HTML 파일 자체를 읽는다.
      - 즉 HTML 파일을 순서대로 읽어나가면서 JavaScript, CSS , 이미지 에셋 등을 직접 참조한다.
  - 사용되지 않는 코드를 제거하는 트리 쉐이킹 시 강점
    - ES6, CommonJS 모듈 모두에 대해서 지원
    - NPM Library에 있는 대부분의 코드가 여전히 CommonJS를 사용한다는 점에서 특히 강점
  - 파셀은 트랜스파일러도 간편하게 설정 가능
    - 일반적으로 번들러는 JavaScript 파일만 읽을 수 있기 때문에, CSS나 이미지 같은 에셋들의 종속성을 인식하고 번들에 추가하려면 트랜스파일러를 사용해야 한다.
      - 의문
        - 왜? 이해 안됨
    - 트랜스파일이 필요한 파일 유형을 일일이 설정해야 하는 웹팩 및 롤업과 달리, 파셀은 트랜스파일에 대한 기본 제공을 지원.
      - 즉, babelrc, postcssrc, posthtml 같은 설정 파일들을 프로젝트 루트 디렉토리에 만들기만 하면, 파셀이 자동으로 파일을 읽어와서 세팅을 한다.
      - `.babelrc`로 사용자가 직접 설정한 트랜스파일 외에도, 파셀은 항상 모든 모듈에서 Babel을 사용하여 최신 JavaScript를 브라우저에서 지원하는 형식으로 컴파일 한다.
- 단점
  - 웹팩이나 롤업에 비해 좁은 생태계
  - 떨어지는 안정성
  - 일반적인 케이스만 다룰 뿐, 커스텀한 설정이 필요한 경우 설정 파일을 다시 작성해야 한다.

## 결론

- 프로젝트 목적에 알맞는 번들러를 선정해야 한다.
  - 웹팩
    - 많은 서드파티를 필요로 하는 복잡한 애플리케이션 제작
  - 롤업
    - 최소한의 서드파티로 라이브러리를 제작
  - 파셀
    - 복잡한 설정을 피하고 비교적 간단한 애플리케이션 제작
- Tolling.Report
  - 구글이 만든, 번들러 비교 사이트
  - <https://bundlers.tooling.report/>

## 참고

- <https://yozm.wishket.com/magazine/detail/1261/>

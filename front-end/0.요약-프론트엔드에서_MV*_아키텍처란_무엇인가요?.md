
# 프론트엔드에서 MV* 아키텍처란 무엇인가요?

## 프롤로그

- 옷이 많아지면 큰 옷장이 필요해진다.
- 옷장에 옷을 넣기만 하면 옷장의 첫번째 역할인 보관한다는 목적에는 충실하지만, 만약 내가 원했을 때 필요한 옷을 쉽게 꺼낸다는 목적성을 잃게 된다.
- 즉 잘 꺼낼 수 있도록 잘 넣어두는 방법을 고려해야 한다.
- 불편한 부분을 찾고, 해결하기 위한 패턴을 찾게 된다.
- 예시로, 비슷한 것끼리 분류해서 모으게 된다.
- 이러한 과정에서 패턴이 만들어지면, 추후 이 패턴에 맞는 목적성을 가진 특수한 옷장이 등장하게 된다.
- **(점진적인 세분화)** 처음에는 단순히 상의, 하위를 구분하는 칸만 나누어져 있다가 양말을 보관하는 칸은 다르게 생기고, 외투를 걸 수 있는 공간, 모자, 허리띠 등 각 용도에 맞는 구조로 가구가 만들어지게 된다.
- 그 결과로, 처음의 단순한 옷장에 비해 세부적인 규칙을 잘 알지 못하더라도, 옷을 정리하기가 한결 편해지게 된다.
- 현실적으로, 옷은 서로 데이터를 주고 받지 않지만, 소프트웨어의 각 모듈들은 서로 데이터를 주고 받아야 한다.
- 아키텍처를 단순히 분류를 넘어서 데이터를 주고 받는 인터페이스 설계가 훨씬 더 중요하기 때문에, 앞으로 나올 아키텍처 이야기는 **분류와 인터페이스 관점**을 둘 다 생각하고 읽어야 한다.
- 결론으로 아키텍처란 구조화된 옷장과 비슷하다.
- 처음 개발할 때에는 규칙 없이 그냥 코드를 만들다 보면 덩치가 커지고,계속 불편함이 생기고 정리가 안되는 시점이 발생한다.
- 이를 해결하기 위해서, 처음부터 특정한 규칙을 만들어서 개발을 하는게 좋다는 것을 알게 된다면, 규칙을 하나씩 체계화하면서 개발한다면, 특정한 반복은 곧 하나의 특정 패턴으로 귀결된다.
- 이러한 패턴들을 모두가 이해하고, 따를 수 있도록 하는 구조를 아키텍처라고 부른다.
- 프론트엔드 개발 변천사 또한, **패턴에서 찾은 해결책을 통해 다른 패턴이 파생되고… 이를 반복**한다.
- 소프트웨어 관점에서, 지속적으로 관리가 잘되는 코드를 위해서는 좋은 아키텍처가 필요하다.
- 웹은 지속적으로 좋은 아키텍처의 모습으로 진화하고 있다.

## 아키텍처의 이해를 도울 수 있는 영상

- <https://www.youtube.com/watch?v=4E1BHTvhB7Y>

## 웹 프론트엔드 아키텍처 이야기

- UI를 포함하는 소프트웨어를 만들 때는, MVC (Model, View, Controller)라는 영역으로 나누면 효과적이ㅣ다..
- 의문
  - Model에서 바로 View를 호출하는 경우는, 초기 페이지 랜더링 때만 발생함?
- UI 소프트웨어의 본질은 단순하다. 우선 데이터를 화면에 그린다. 그리고 우리가 어떤 동작을 취하면 데이터가 바뀐다. 데이터가 바뀌면 다시 화면이 바뀐다.

### 웹 아키텍처 기준

- View (화면)
  - HTML , CSS로 만들어지는 결과물
- Model (데이터)
  - 화면의 특정 영역에, 실제의 데이터가 반영이 되어 나타나야 한다.
  - 데이터를 주관하는 영역을 Model이라고 부른다.
  - 모델의 범주
        1. JS의 Object
        2. 서버에 존재하는 DB
        3. 서버의 API로 받는 데이터
- Controller (컨트롤러)
  - Model의 데이터를 받아서 화면에 그리고, 화면으로부터 사용자의 동작을 받아서 Model을 변경한다.
  - Model과 View 사이의 중간 역할을 하는 것을 Controller라고 한다.
- MVC가 나뉘어진 이유

  - 화면을 다루는 문제와 데이터를 다루는 문제의 성격이 다르므로, 관심사 측면에서 분리됨.
  - Model과 View 간의 의존관계를 최소화하여, 화면의 코드 수정이 데이터 코드 수정에 영향을 미치지 않고(또는 최소화), 데이터 코드 수정이 화면 코드 수정에 영향을 미치지 않고자 함.

## 초창기 웹 서비스의 MVC 아키텍처

- 웹 프론트엔드라는 개념도 없던, 웹 서비스 초창기 시절의 MVC

  - 데이터베이스를 Model로 취급함.
  - View는 HTML과 CSS, JS까지 포함한 클라이언트 영역이다.
  - Controller는 중간의 라우터를 통해 데이터를 처리하면서 새로운 HTML을 만들어서 보여주는 백엔드 영역이다.
  - 이 시절에는 루비 온 레일즈, PHP, JSP 등에서 라우터 영역을 Controller로 정의한 프레임워크 등이 많았다.

## JQuery 시절의 MVC 아키텍처

- 프론트엔드의 역할이 추가되고, Ajax라는 기술이 생기면서, 이제는 HTML을 서버에서 직접 만들 필요가 없게 되었다.
- 웹 프론트엔드의 MVC 개념이 조금씩 바뀌게 된다.
- Ajax로 부터 받은 데이터를, **Model로 취급**한다.
- HTML과 CSS로 만들어지는 화면을, **View로 취급**한다.
- Javascript가 중간에서 서버의 데이터를 받아 화면을 바꾸고, 이벤트를 처리해서 서버에 데이터를 전달하는 **Controller의 역할**을 수행한다.
- *기존의 서버 라우터에서 수행하던 어떤 역할들은, 이제 클라이언트의 자바스크립트가 처리하게 되었고, Database는 백엔드의 역할이며, REST API의 Ajax 데이터가 Model이 된다.*
- 이 시절 Controller의 가장 주요한 역할 담당은 바로 JQuery이다.
- JQuery 핵심 기능

  - DOM Traversal and Manipulation (DOM 방문 및 조작)
  - Event Handling
  - Ajax

- 이 당시 가장 중요한 패러다임은 관점의 분리로서, Model과 View의 종속성을 최대한 분리하는 원칙으로, HTML과 JQuery를 별도로 관리하는 것이 주효했다.
- 이후 보다 더 MVC스러움을 추구하는 Backbone.JS와 같은 프레임워크 등이 만들어지기도 하였다.

## MVVM 아키텍처의 등장 (Angular,  React, Vue)

- JQuery로 작업 시, 상당히 불편한 점을 발견하게 된다.
- 데이터를 찾아서 데이터를 바꾸고 데이터를 수정하고,이벤트를 연결하고 이벤트를 수정하는 부분들에서 피로도가 높은 반복적인 패턴이 나타난다는 것을 알게 된다.
- 서버에서 개발을 할 때에는 html이 전체적으로 렌더링으로 되다보니 ‘<%= %>’와 같은 치환자를 통해 선언적으로 편리하게 개발을 하는 반면, JQuery의 경우 html을 갱신했다가는 번쩍거리는 화면을 연출할 수 있으므로, 수정해야 할 부분을 일일이 찾아서 수정을 해야만 한다.
- 이 때부터, **클라이언트 개발도 서버처럼 템플릿과 같은 선언적인 방식으로 개발하는 방식을 고려**하게 된다.
- 선언적 프로그래밍이란, 코드로 로직을 만들지 않고 약속된 선언을 바탕으로, 자동으로 필요한 코딩을 하는 것이다.
- 예시로 html, css, jsx와 같은 템플릿이 있다.
- 2013년 AngularJS를 통해서 템플릿과 바인딩이라는 중요한 개념들이 등장하였고, 이후 웹 개발하는 방식의 패러다임이 완전히 바뀌게 된다.
- Model이 변하면 View가 변경되고, View에서 이벤트를 받아서 Model을 변경한다는 Controller의 역할은 그대로이지만, 이를 구현하는 방식이 Jquery와 같은 Dom 조작에서, 템플릿과 바인딩을 통한 선언적인 방법으로 변하게 된다.
- 코드에서 DOM을 조작하는 코드가 사라지고, 이 기능들은 프레임워크가 담당하게 된다.
- 개발자는 화면에 그려져야 할 데이터만 만들어서 프레임워크에 전달해주면 프레임워크가 알아서 그려준다.
- 이를 **View를 그리는 Model만 다루게 되었다는 의미로 ViewModel이라고 부르며 MVVM**이라고 부르게 된다.
- 이후 나오는 프레임워크인 React, Vue, Angular2, Sevelt 등은 본질적으로, 어떤 방식의 템플릿과 바인딩 문법을 쓰느냐 방식만 다를 뿐이고, MVVM이라는 아키텍처는 그대로 유지하게 된다.
- **MVC에서 MVVM**으로 오면서 달라진 부분
  - 컨트롤러의 반복적인 기능이 선언적인 방법으로 개선이 되었다.
  - Model과 View의 관점을 분리하려 하지 않고, 하나의 템플릿으로 관리하려는 방식으로 발전했다. (기존에는 class나 id등으로 간접적으로 HTML에 접근하려고 했다면, 이제는 직접적으로 HTML에 접근하는 방식으로 확장이 되었다.)

## 컴포넌트 그리고 Container-Presenter 패턴

- MVVM을 얻은 웹 프론트엔드 개발은 높은 생산성의 변화가 생겨난다.
- *웹의 DOM API를 잘 다루지 못하더라도, 비즈니스 로직에만 집중한다면 빠르게 서비스를 만들 수 있게 되었다. (DOM 관리 및 조작을 프레임워크 또는 라이브러리에게 위임)*
- 웹 서비스가 발전하게 되면서, 이제는 하나의 Page 단위가 아닌, Page 안에 여러가지 모듈이 있고, Model이나 여러 화면들이 하나의 화면에서 구성이 될 수 있도록 발전을 하게 된다.
- 즉 MVVM은 화면단위가 아니라, 조금 더 작게 재사용 할 수 있는 단위로 만들어서 조립하는 방식으로 발전을 하게 된다.
- 이를 **Component 패턴** 이라고 함
- 컴포넌트는 재사용이 가능해야 한다는 원칙에 따라, 가급적 비즈니스 로직을 포함시키지 않으려고 개발을 하게 된다.
- 이유는 비즈니스 로직이 들어가게 되면 컴포넌트의 재활용성은 상당히 떨어지게 된다.
- *비즈니스 로직을 관장하고 있는 컴포넌트를 Container 컴포넌트*, *비즈니스 로직을 가지고 있지 않고 데이터만ㅊ화면에 출력하는 형태의 컴포넌트를 Presenter 컴포넌트*라고 하며, 이를 분리하여 최상단 혹은 1 Depth에 Container를 두고 비즈니스 로직을 관리하는 **Container-Presenter 아키텍처**가 만들어지게 된다.
- **(React를 기준으로) Props Drilling Problem**이 존재한다. 컴포넌트 구조가 복잡해짐에 따라, 하위에 특정 값을 전달하기 위해서는 중간 레벨에 있는 컴포넌트들은 전부 그 props를 가지고 있어야 하는 문제가 발생한다.
- 이러한 문제를 해결하기 위한 새로운 아키텍처(FLUX 패턴과 Redux)를 생각하게 된다.

## FLUX 패턴과 Redux

- FLUX 패턴은 이제, MVC의 개념에서 벗어난 단방향 아키텍처 (uni-directional architecture)를 구성한다.

- MVC에는 문제점이 있다.
  - 의문
    - 어떤 문제? 구체적인 예시?
- 발생한 문제점으로, 컴포넌트의 재사용과 독립성을 지나치게 강조하다보니 같은 데이터를 공유하는 과정에서 props를 통해서 데이터를 전달하는 문제들로 하여금 Model의 관리가 파편화 되는 문제가 발생하게 된다.
- MVC 문제점은 컴포넌트 레벨로 Props Drilling 문제와 같은 의미였다. (이해가 안됨)
  - 한 Model이 변경됨에 따라 props Drilling에 의해 관계된 컴포넌트들에 영향을 주게 된다.
  - 최적화 기법이 존재하나, 적용 시 많은 비용이 소비됨.
  - 코드를 파악하지 않는 이상, props 변경에 의한 모든 계층의 컴포넌트 간 사이드 이펙트를 감지하기 어려움.

- 기존의 컴포넌트를 지향하는 MVC가 아니라, View를 하나의 범주로 두고 View에서 Action을 호출하면 Dispatcher를 통해 Store라는 공간에 Data가 보관이 되고 다시 뷰로 전달되는 흐름을 설명한다.
- 참고로, Flux는 아키텍처만 공개 되었을 뿐, 실체가 없었기에 바로 쓰이지는 않았고, 아젠다를 만들어 주는 정도에 그쳤다.

## 상태 관리 정의

- 기존 컴포넌트 단위의 MVC 개념, MVVM개념에서 완전히 비즈니스 로직과 View 로직이 Layer 개념으로 물리적으로, 논리적으로 분리된 개념.

- 베이스는 FLUX이다.

## Redux

- Props Drilling Problem의 문제점을 정확하게 짚어줌.
- Store, Dispatcher, Reducer에 대한 개념을 정확하게 다시 정리함.
- *Flux 패턴은 View를 각각의 MVC 컴포넌트 관점으로 보는 것이 아니라, 하나의 큰 View로 이해하고 view에서는 Dispatch를 통해서 action을 전달하면, action은 reducer를 통해서 data가 store에 보관이 되고, store에 들어있는 데이터는 다시 view로 연결이 되는 방식을 지향한다.*
- 기존의 컴포넌트 단위의 MVC개념, MVVM개념에서 완전히 비즈니스 로직과 View 로직이 분리하면서, 이 분리된 개념을 **상태 관리(state management)라고 부르게 된다.**
- MVC에서 FLUX로 변하면서 달라진 부분
  - 공통적으로 사용되는 비즈니스 로직의 Layer와 View의 Layer를 완전히 분리되어, 상태관리라는 방식으로 관리한다.
  - 각각의 독립된 컴포넌트가 아닌(Higher-Order Component), 하나의 거대한 View 영역으로 간주한다.
  - 둘 사이의 관계는 Action과 Reduce라는 인터페이스로 분리하며, Controller는 이제 양방향이 아니라 단방향으로 Cycle을 이루도록 설계한다.
- FLUX 패턴은 각 프레임워크 진영에게 많은 영감을 주었으며, 프레임워크와 더불어 본격적인 상태관리 라이브러리들이 만들어지기 시작하게 되었다.

## FLUX 패턴의 한계

- 문제
  - 높은 학습곡선
  - 장황한 문법
- 간단한 구조에서는 Props Drilling Problem이 치명적이지 않았고, 상태를 관리하기 위해서는 Action, Dispatch, Reducer를 만들고 관리하는 데 필요한 많은 부수적인 코드들로 인해 관리가 되려 어려워진다는 문제가 있었다.

## Observer-Observable Pattern

- Props Drilling Problem 문제를 다른 식으로 풀어본다는 시각도 나왔다.
- FLUX와 동일하게 거대한 View와 상태 관리인 Model을 나누는 관점은 동일했다.
- 다른 점은, 복잡함을 야기하는 Dispatch와 Action을 배제하고 값이 바뀌면 바뀐 값을 모두에게 전달을 한다는 개념이다.
- 초창기 Mobx가 이러한 방식을 기반으로 하되 Redux의 영향을 받아 용어는 Action과 Reaction이라는 방식을 취했다.
- Angular에서는 rxjs를 받아들이고, FLUX패턴까지 결합해 FLUX와 Observable이 혼합이 된 상태관리(NGRX)를 만들기도 하였다.

## MVI 패턴

- cycle.js이라는 라이브러리에서 먼저 소개된 개념이다.
- 기존 FLUX 패턴을 Dispach와 Action과 Update의 인터페이스를 전부 Observable를 이용한 스트림(stream)의 하나의 방식으로 만듬으로써, 비동기 문제를 해결하고 장황한 문법을 하나의 인터페이스로 만든 점이 인상적이다.
- MVI 아키텍처는 ios와 android에서 새로운 아키텍처로 부상하고 있다.

## 현대 웹 프론트엔드의 아키텍처 방향성

- (React를 기준으로) Context와 hook, props drilling에 중점을 두고,

- 만약 Props Drilling Problem이 문제라면, 새로운 개념을 만들기보다 props만 새로 뚫지 않는 방법등을 제공하면 되지 않느냐는 시각이다.
- 컴포넌트 트리에서 Context라는 거대한 공통 조상을 만들고, 그 Context로 부터 데이터를 제공을 받는 방식이다.
- 개념적으로 별도의 Store라는 거대한 공통 조상을 만들고, 그 Context로 부터 데이터를 제공을 받는 방식이다.
- 개념적으로는 별도의 Store를 두는 FLUX와 비슷한 느낌이 있지만, 최근 트렌드에서는, 복잡한 문법을 가지고 만들어야 하는 Redux보다는 React의 기본 기능인 Context API를 쓰겠다는 움직이 생기고 있다.
- svelte에서도 React와 동일한 Context라는 개념을 제공하고 있다. 또한 별도의 props를 선언하지 않고 모든 props를 자식으로 전달해주는 기능들도 제공하고 있다.
- 개선방향
  1. View와 Model은 분리한다.
  2. 프레임워크에서 props drilling problem을 막는 방법을 제공하자.

## atomic 패턴 - Recoil, Svelt Store, Vue Composition, Jotai

- 거대한 View 영역과 store 영역을 나누는 이분법으로 생각하자는 의견에는 동의하지만, Action, Dispatch, Reducer와 같은 복잡한 구조를 가져야 하는가에 대한 방법에 대해서는 회의적인 시각으로 만들어진 방법이다.

- 간단한 문법으로 컴포넌트 외부에서 공통 데이터를 set, get을 할 수 있게 하면서 동시에 동기화 할 수 있는 방향성이다.
- 이와 더불어 computed, derived, select와 같은 반응형 기능을 제공하여 관련된 데이터의 동시 업데이트를 제공하고 있다.
- 개선 방향
  - View와 Model을 분리한다.
  - 중간의 과정은 자율에 맡기고, 간단하게 Model에 접근하는 법만 제공하자.
  - 동기화, 동시성 처리가 중요하다.

## React Query - MVC의 개념 확대

- 상태관리에 편향되어 있던 시각에서 벗어나, 고전적인 Ajax의 데이터를 Model로 간주한다.
- 요점은 대부분 프론트엔드 개발은 서버 데이터를 CRUD하여서, 시각으로 그리는 것에 중점이 되어 있는데, FLUX나 Actomic 패턴 마저도 너무 복잡한 방법이라는 것이다.
- 예시, React Query
  - 서버와의 fetch 영역을 Model로 간주
  - View는 React
  - Controller는 query와 mutation이라는 2가지 인터페이스를 통해서 서버 데이터의 상태를 관리하고 캐싱, 동기화, refetch등을 관리해주는 역할
- 기존의 많은 복잡함을 덜어냈다.

## GraphQL, firebase - Schema Based 아키텍처

- 미리 스키마를 정의하고, 스키마를 기반으로 해서 데이터를 교환한다는 개념이다.
- React Query와 마찬가지로, 서버 데이터를 Model로 간주하며, 서버와의 query와 mutation 통신을 통해서 view에게 데이터를 전달하는 방식이다.

## MVI 보충 설명

- FLUX의 단순화 버전인가?

- FLUX는
  - 서버 연동을 고려하지는 않음.
- 반응형 프로그래밍이라고 볼 수 있는가

- 단방향 아키텍처
- 선언적 프로그래밍을 통한 Controller
- 뷰와 비즈니스 로직의 분리 (상태관리)
- 반응형 프로그래밍
- 서버와 연동을 Controller로 간주하는 움직임

## 사실 이름은 중요하지 않다. MV*

- MVC, MVVM, FLUX, MVI, Atomic, Observable…

- 현재 쓰고 있는 라이브러리들이 저런 아키텍처에 딱 맞아 떨어지지는 않는다. 
- 아키텍처란 비슷한 것들을 묶어서 기존과 다른 이름을 붙이는, 우리가 개념의 범주를 만들기 좋게 하기 위한 일종의 마인드 셋이다.
- 어떤 이름들은 라이브러리가 출시되고 나서 설명을 하기 위해 만들어졌고, 어떤 이름들은 전략적으로 이전과 다른 차별화를 강조하기 위해서 이름을 새로 짓기도 한다.
- 각 아키텍처의 이름보다는 웹 프론트엔드의 막연히라도 전반적인 아키텍처의 구성과 변화의 흐름을 이해해서, 아키텍처의 본래 이유였던 지속적으로 잘 관리되는 코드를 짜기 위해서, 지금 쓰는 아키텍처에 맞는 방식으로 더 코드를 잘 작성할 수 있는 기반 지식이 되었으면 한다.

## 불편함을 느끼자

- 현재의 개발 방식에서 불편함을 느껴야한다.
- 패러다임의 확장과 개선이 있기까지는 많은 시간이 걸린다.
- 아키텍처의 시작은 불편한 것을 찾고, 하지 말아야 할 규칙을 찾는 것부터 시작한다. 그리고 그것을 개선하는 방법을 찾으므로써 새로운 패러다임이 생겨나게 된다.
- 내가 당장 새로운 라이브러리를 개발할 수 없겠지만, 언제나 이 불편함을 주시하고 있어야만, 앞으로 새로운 라이브러리가 나왔을 때, 그것이 개선이 되었는지 아니면 새롭지 않은 기존 라이브러리의 아류인지 판단할 수 있다.
- 웹은 계속 무서운 속도로 발전하고 있다. 내 코드는 언젠가 레거시가 된다. 새로운 것으로 갈아타야 할 준비는 언제든지 해야하나, 너무 빨리 갈아타도 탈이나고 너무 늦게 갈아타도 문제가 된다.
- 결론으로 웹의 발전 역사와 방향성을 이해하면서, 그 안에서 아직도 해결되지 않은 여러 불편함들에 대해서 숙지하고, 그것들을 해소해주는 라이브러리나 패러다임에 대해서 빨리 깨닫고 공부해야 할 것을 찾고, 새로운 기술로 갈아탈 수 있는 눈을 가져야 한다.

## 참고

- <https://velog.io/@teo/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C%EC%97%90%EC%84%9C-MV-%EC%95%84%ED%82%A4%ED%85%8D%EC%B3%90%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80%EC%9A%94>

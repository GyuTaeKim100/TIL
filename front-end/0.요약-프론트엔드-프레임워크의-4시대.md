
# 자바스크립트 프레임워크의 4시대

- 일반적인 웹사이트가 굳이 React로 작성될 필요가 있나?

## 고대 시대

- Internet Explorer와 Netscape는 Event시, 한쪽은 이벤트 버블링, 한쪽은 이벤트 캡처링을 사용헀다.
  - 둘 모두 웹 표준에 반영되어 있다.
  - 당시에는 두 브라우저에서 모두 동작하는 코드를 구현하려면 라이브러리를 사용해야 헀다.
- 당시 라이브러리들은 작고 독립적으로 동작하는 UI 위젯을 만드는데 주로 사용됨.
- 어플리케이션의 주요 비즈니스 로직은 여전히 form과 HTTP 리퀘스트에 의해 이뤄졌고, HTML을 서버에서 렌더링하여 클라이언트에게 제공하는 방식을 사용헀다.
- 자바스크립트 모듈이 없었고, 코드를 import가 불가능했다.
  - 즉 모든 것이 전역 공간에 존재하므로, 코드 정리를 하는 것이 어려웠다.
- 풀 어플리케이션을 작성 시에, 자바스크립트는 고려할만한 언어로 인식되지 않았다.
- 자바스크립트의 주요 용도
  - 몇 개의 UI 위젯 동작에 필요한 스크립트를 JQuery와 함께 불러와 호출하는 것이었다.
- **시간이 흐르면서 XHR이 도입되었고, 사람들은 클라이언트와 백엔드 사이의 복잡한 플로우가 필요한 UI의 일부분을 싱글 페이지로 구현**하기 시작했다.
- 하지만 앱의 중요한 부분은 여전히 서버에 견고히 유지되었다.
- *iOS와 Android 앱은 처음부터 완전히 API 기반의 언어*였다.
  - 모든 UI 로직은 디바이스 위에서 돌아가며, 서버와의 통신은 단순히 데이터 포맷만 전달하는 것으로 가능했다. 이는 더 나은 사용자 경험을 가능하게 했고, 모바일 앱의 인기는 폭발적으로 성장헀다.
- 자바스크립트도 시간이 흐르면서 등장한 소셜 네트워크 프로덕트(예시, 페이스)는 채팅과 DM 등의 실시간 기능을 추가했고, Gmail과 Google Docs는 데스크탑 어플리케이션과 똑같은 기능을 브라우저에서 구현할 수 있다는 것을 보여주었다.
- 점점 더 많은 사용 사례를 웹 앱으로 구현하기 시작했다. 웹은 어디서든 동작하며 유지보수 및 배포가 더 쉽기 때문이다.
- NPM이 없어서 개발자는 외부 라이브러리를 직접 다운로드해서 프로젝트 소스코드에서 정적인 파일들이 있는 폴더로 옮겨둔 후, HTML 파일에 script 태그를 추가하여 불러와야만 했다.
- 앱의 대부분은 페이지마다 맞춤 형식으로 개발되었는데, 상태 관리와 렌더링 업데이트가 플러그인마다 다른 시스템을 사용하는 식이었다.
  - 의문
    - 예시?
- 이러한 이슈들을 해결하기 위해서, 최초의 프레임워크가 수면 위로 떠오르기 시작했다.

## 최초의 프레임워크

- Backbone, angular1, knockout.js, sproutCore, Ember.js, Meteor.js
  - 미지의 영토에 발을 들여놓으려는 세대들의 프레임워크였다. 야심적이었다.
  - 많은 사람이 결코 할 수 없을 것이라고 생각했던 것이었다.
- 당시 싱글 페이지 자바스크립트는 근본적으로 나쁘다고 비방하는 여론이 컸다.
  - 사실 많은 면에서 옳다.
  - 단점으로,
    - 클라이언트 사이드 렌더링은 검색 엔진이 페이지를 쉽게 크롤링하지 못하도록 했다.
    - 유저는 웹 페이지가 페인팅을 시작하기 전까지 몇 초 이상 기다려야 하기도 했다.
    - 많은 앱이 웹 접근성에서 최악이었고, 심지어 브라우저에서 자바스크립트 기능을 꺼버리면 아예 동작하지 않았다.
- 대부분 프레임워크는 다른 프레임워크에 기반한 변형 Form이었다.
  - 대부분 모델-뷰-something 패턴 (Model-View-Controller, Model, View-Producer, Model-View-ViewModel, 기타 등등)의 반복이었다.
  - **어떤 프레임워크도 특별히 직관적이지 못했고, 사용하다 보면 순식간에 복잡해져 버리곤 했다.**
- 자바스크립트를 컴파일 하는 방법에 대한 실험이 제대로 시작된 시대이다.
  - Node.js는 2009년에 릴리즈 되었다.
  - NPM이 2010년에 도입되었다.
  - CommonJS와 AMD는 JS 모듈을 어떻게 정의하는 것이 최선인지에 대해 경쟁 했다.
  - Grunt, Gulp, Broccoli 같은 빌드 툴은 모듈들을, 어떻게 프로덕션 빌드에 묶어낼 것인지를 놓고 경쟁헀다.
    - 이들 대부분은 일반적인 태스크 러너 툴이었다.
    - 무엇이든 빌드할 수도 있었다.
    - 앱 안에 들어가는 요소는 자바스크립트, HTML, CSS/SASS/LESS, 그 외 다양한 것들을 빌드하는 데 쓰이게 되었다.
- 교훈
  - URL 기반의 라우팅은 필수적이다.
    - 프레임워크의 시작부터 고려되어야 한다.
    - 만약 없다면, 앱은 웹을 망가트린다.
  - 템플릿 언어로 HTML을 확장하는 것은 강력한 추상화 계층이다. (선언형 프로그래밍)
    - 다소 투박하게 느껴질지 몰라도, UI를 앱의 상태와 동기화시키는 것을 더 쉽게 만들어준다.
  - SPA에서 퍼포먼스를 높이는 것은 어렵다.
    - 네이티브 앱에는 존재하지 않는 많은 제한 요소가 있다.
      - 앱의 코드르 전부 네트워크에 실어서 전송해야 하는데, 그 전송을 가능한 빨리 끝내고 앱을 실행시켜야 한다.
      - 반면 네이티브 앱은 이미 다운로드와 컴파일이 끝난 상태로 제공된다.
      - 웹 앱을 시작하기 위한 그 일련의 과정들은 엄청난 작업이다.
  - 자바스크립트는 언어로서 많은 이슈를 가지고 있었다.
    - 개선되어야 할 부분들이 정말로 많았다.
    - 그 부분을 프레임워크가 모두 감당 할수 없다.
  - 더 큰 규모의 앱을 구현하기 위해서는 정말로 더 좋은 빌드 툴, 모듈, 패키징이 필요로 했다.
- 결론
  - 생산적인 시대가 도래함.
  - 어려 결점에도 불구하고, 많은 경우에 백엔드 API에서 클라이언트를 분리함에서 오는 이익에 의해 앱의 사이즈가 비례해서 커졌고, 그에 따라 사용자 경험이 향상 되었다.
  - 다가오는 멸종 시킬 소행성의 이름은 React이다.

## 컴포넌트 중심 뷰 레이어

- 어떤 아이디어가 등장하면, 모든 메이저 프레임워크는 그것을 재빠르게 수용한다.
- 컴포넌트는 모든 것을 잘 동작하도록 만들었다.
- 전역에서 오랫동안 살아남는 상태 변수를 최소화하고,
- 자바스크립트 비즈니스 로직이 템플릿에 확실히 연결되도록 했다 (JSX, Handlerbar 또는 Directives 등)
- 컴포넌트 기반의 어플리케이션은 기존 방식에서 필요했던 추상화의 대부분을 제거했다.
  - 의문
    - 예시는?
- 코드의 라이프 사이클을 현저히 단순하게 만들었다.
- 앱의 라이프사이클 아닌 컴포넌트의 라이프사이클과 묶이게 되었고, 개발자로서는 구현 중에 고려해야 할 사항을 훨씬 적게 만들었다.
- 뷰 레이어 프레임워크의 등장하였다.
- 프론트엔드 앱에 요구되는 모든 문제를 해결하기보다는, 오직 렌더링 이슈를 해결하는 데 초점을 맞추고 있었다.
- 프론트엔드 앱의 다른 문제로는 API 통신, 상태 관리 등이 있는데 그것들은 프레임워크단이 아닌, 프로그래머에게 위임했다.
- 종류는 React.js, Vue.js, svelte, polymer.js가 있다.
- 뷰 레이어 프레임워크는 장점
  - 스코프를 엄청나게 줄여버렸다. (관심사 분리)
  - 모든 문제를 해결하려는 대신, 프레임워크의 핵심인 렌더링에 집중했다.
  - 상태 관리 같은 다른 문제들은 개발 생태계 속에서 많은 아이디어와 방향이 탐구되었다.
  - 프레임워크를 도입하기 쉽게 만들었다. (부품)
- Monolith 모노리스 서버 사이드 앱에서 풀 프레임워크를 도입한다는 것은, 사실 기존의 앱의 대부분을 새로 작성한다는 말과 같다.
- 단 React, Vue같은 프레임워크는 서비스 중인 앱에도 중간에 도입해서 1개의 위젯이나 컴포넌트로부터 시작해서 기존의 코드를 점진적으로 마이그레이션 하는 것이 가능하다.
- 주요 논쟁
  - “더 빠르게, 더 작게, 당신에게 필요한 것”
  - 뷰 레이어 컴포넌트는 작고(처음에는) 그리고 빠르고(처음에는) 그리고 당신에게 필요한 모든 것이다(당신이 만약 다른 많은 것들을 스스로 한땀 한땀 구현했다면 …? 무슨 의미).
  - 함수형 프로그래밍이냐 객체지향 프로그래밍이냐
    - 함수형 프로그래밍 패턴은 자바스크립트를 오염시킨 수많은 문제를 해결했다.
  - 자바스크립트 코드의 품질이 그들 덕분에 좋아졌다.
  - 은탄환 따위는 없으며, 결코 있을 수 없다.
  - 뷰 중심의 프레임워크들을 사용해도 여전히 앱은 비대해지고 복잡해진다.
  - 상태 관리는 여전히 어렵다.
  - 라우팅 이나 SSR 같은 근본적인 문제도 풀어야 할 문제이다.
- 대부분 사람은 마치 모든 것을 해결하려는 솔루션을 버리고 사용자에게 그 연습을 맡기는 프레임워크를 원하는 것 같다.
- 이러한 현상은 새로운 제품이나 기능을 출시하려는 엔지니어링 조직에 보편적으로 존재하는 현상이다. 그리고 그 모든 기능을 개발하는 데 시간을 충분히 투자하지 못하곤 한다.
- 기존의 첫 번째 풀서비스 프레임워크도 이 문제를 제대로 풀지 못하고 있었다.
- 부분적으로, 이는 수많은 기술적 부채 때문이었다.
- ES6가 나오기 전, 모듈이 있기전, Babel과 Webpack이 있기 전이었으며, 그리고 우리가 찾아낸 수많은 해법이 존재하기 전에 만들어 졌다.
- 이러한 기술들을 꾸준히 도입하며 프레임워크를 발전시키기는 무척 어려운 일이다.
- Angular 2처럼, 프레임워크를 완전히 새롭게 개발하는 것은 커뮤니티 활동 모멘텀을 크게 낮춰버리는 일이기도 하다.
- 자바스크립트 프레임워크 세계로 오는 개발자들은 바위가 있는 힘든 환경에 오는 것과 같았다.
- 생긴지 얼마 안 된 All in one 솔루션을 선택하거나, 모든 것을 자유롭게 고르되 그 길이 최선이길 바라며 프레임워크의 절반을 DIY 해야 한다.
- 결과적으로 이들 뷰 레이어와 함께 구성된 수제 프레임워크가 만들어지고, 그런것들은 또 커지고, 복잡해지고, 작업하기가 매우 어렵게 되어버린다.
- 사람들이 SPA를 사용하면서 생기는 많은 문제는 파편화된 에코 시스템이며, 그 문제는 SPA가 폭발적으로 성장하기 시작한 그 시기에서 왔다.
- 탄생한 혁신적인 기술
  - Babel
  - 트랜스파일러의 사용이 일반화되어 언어를 현대화 했다.
    - 새로운 기능이 언어의 표준이 되기까지 몇 년을 기다리는 대신 오늘 당장 사용할 수 있게 되었다.
  - 자바스크립트 언어 자체도 더 빠른 주기로 새로운 기능을 추가하기 시작했다.
  - Rollup, Webpack, Parcel 등이 개발될 수 있도록 했다.
  - import 기반의 번들링은 서서히 일반화되었고, 이제는 자바스크립트가 아닌 스타일 시트, 이미지 파일 같은 자원들도 번들링이 가능하다.
  - 설정이 단순해지면서 빌드 툴들은 전반적으로 더 가볍고, 더 빠른 성능을 보여준다.
    - 점점 더 많은 API가 표준화 되면서, Node와 웹 표준 사이의 차이가 조금씩이지만 확실히 줄어들었다. SSR은 실제로 가능성을 가지기 시작했고, 어떤 앱들은 이미 사용하고 있었다. 하지만 매번 앱마다 맞춤 설정이 필요했다.
    - 엣지 컴퓨팅이 공개되었고, 자바스크립트 기반의 서버 앱에 배포/응답 시간 측면에서 SPA에 있는 장점을 제공해줬다 (SPA는 일반적으로 사용자로부터 가까이 있는 CDN에 있는 정적인 파일들 덕분에 로딩 시작을 빨리할 수 있었다. 비록 종단의 디바이스에서는 그 로딩이 완전히 끝나 렌더링이 되기까지 조금 더 오래 걸린다고 하더라도)
- 일부 문제는 여전히 남아 있었다.
  - 더 좋은 패턴을 찾아냈음에도 상태 관리와 반응성은 여전히 어려운 문제였다(지금도 그렇다).
  - 퍼포먼스는 여전히 어려운 문제이다.
  - 상황은 조금씩 나아지고 있긴 하지만 여전히 헤아릴 수 없이 많은 수의 비대한 SPA가 웹에 존재한다.
  - 웹 접근성 상황은 개선되었지만, 기술조직에서는 여전히 사후 고려 대상이었다.

## 풀-스택 프레임워크

- 3번째 세대의 모든 프레임워크들은 더욱 발전하였고, 이전 세대의 뷰 레이어 프레임워크를 기반으로 만들어졌기 때문이기도 하다.
- 예시로 Nest.js, Next.js, Remix, SveltKit, Gatsby, Astro가 있다.
- 이들 프레임워크의 시작은 뷰 레이어의 고도화부터다.
- 뷰 레이어 컴포넌트는 프레임워크의 상위에 올라가는 핵심 요소이다.
- 앱의 다른 부분인 라우터, 빌드 시스템, 폴더 구조 등의 표준화를 시작하는 것이 합리적이라고 동의한다.
- 느리지만 확실히, 이 메타-프레임워크들은 첫 번째 세대가 제안했던, 즉시 사용할 수 있는 올인원 솔루션을 만들기 시작했다.
- 필요한 기능들은 오픈소스 생태계에서 최선의 패턴을 골라내어, 충분히 성숙한 상태에 있다면 프레임워크에 통합하고 있다.
- SPA는 전적으로 클라이언트에 포커스를 맞추고 있었다.
  - SSR은 모든 프레임워크가 간절히 해결하기 바랐으나, 궁극적으로는 서버에서 렌더링 된 HTML을 메가바이트 단위의 자바스크립트 로딩이 완료된 후 교체하기 위한 최적의 수단이었다.
  - 1세대 프레임워크 중 하나인 Meteo.js만이 더 크게 생각했지만, 그들의 아이디어인 동형(isomorphic) JS는 결코 뜨지 못헀다.
- 그 아이디어는 앱의 사이즈와 복잡도가 커지면서 다시 주목 받았다.
  - 백엔드와 프론트엔드가 함께할 때 정말 유용하다는 것을 알았다.
  - 어떤 리퀘스트에 사용할 API 시크릿을 숨기거나(??), 페이지를 리턴할 때 헤더를 수정하거나(??), API 리퀘스트 프록시를 구성하는 것 같은 일이 가능하다.
  - Node와 Deno가 점점 더 많은 웹 표준을 구현헀고, 서버 사이드 JS와 클라이언트 사이드 JS의 간격이 매년 줄어들면서, 이제는 동형 JS가 그렇게 미친 아이디어는 아니었다고 여겨지기 시작한 것 같다.
  - 엣지 컴퓨팅, 멋진 도구들을 함께 조합하면 당신은 놀랄 만한 가능성을 얻게 된다.
- 쉽게 처리한 작업 목록
        - 어플리케이션에 서버 사이드 OAuth 인증을 추가해서 인증 토큰이 결코 서버 밖으로 나가지 않도록 했다. (??)
            - API에 리퀘스트를 보낼 때마다 헤더에 토큰을 추가해주는 API 프록시도 함께 구성했다.
  - 프록시를 사용해 앱의 특정 라우트를 우리의 CDN으로 연결되도록 하여, 어떤 프레임워크에서 만들어진 HTML 페이지든 호스팅이 가능하도록 했다.
  - 이를 통해 유저들이 그들의 커스텀 페이지를 만들 수 있었다.
  - 시크릿 키가 필요한 외부 서비스가 필요할 때, 여러가지 1회용 API 라우트를 추가했다
  - 우리의 API에 완전히 새로운 라우트를 추가할 필요가 없고, 백엔드 개발자들과 조율할 필요도 없다.
  - LaunchDarkly가 사용되는 곳을 서버 사이드로 옮김으로써 더 작은 자바크립트를 로드하여 전체적인 비용을 줄였다. (??)
  - 백엔드 라우트에 Sentry 리퀘스트를 위한 프록시를 추가하여 광고 차단 확장 프로그램 떄문에 기록되지 않는 에러를 확인할 수 있다.
  - 그 외
    - 서버와 클라이언트가 결합한 특징을 사용해서, 클라이언트 디바이스에 자바스크립트가 비활성화 되었을 때, 완전한 앱 대신 기본적인 HTML과 HTTP를 제공할 수 있게 되었다.
    - 프로그래스 웹앱!
  - 이전에는 해결이 어렵거나 불가능헀던 문제들은, 이제 응답처리 로직을 조금 바꿈으로서 처리되는 사소한 문제가 되었다. 확실한 성능과 UX는 이제 별도의 설정 없이 즉시 사용 가능하다. 새로운 서비스를 구성하고 만드는 대신 별도의 엔드 포인트를 추가하거나 미들웨어를 필요한 만큼 추가할 수 있다.
  - 무설정(zero-config) 방식으로 옮겨가는 데서 시작했지만, 나는 그것이 궁극적으로는 2세대 프레임워크를 발전시키고 안정화하려고 노력한 오픈소스 생태계가 이끌었다고 생각한다. 그것은 문화적인 변화였다. 세 번째 세대의 프레임워크는 렌더링만이 아닌 프론트엔드 개발에서 우리가 해결해야 하는, 모든 근본적인 문제를 해결하려고 하면서 이제 다시 첫 번째 세대 같은 올인원 솔루션으로 회귀하려고 하고 있다.

## 다음은 어디로 갈까?

- 뷰 레이어만이 아닌, 풀 어플리케이션을 처음부터 만들어낼 수 있는 성숙한 솔루션을 개발하고 있다.
- 모든 도구가 처음부터 바로 제공되는 네이티브 앱의 SDK와 같은 필드에서 경쟁할 수 있게 되었다.
- 하지만 여전히 할 일들이 많이 남아있다.
- SPA에서 웹 접근성은 언제나 뒷전이었다.
  - 의문
    - 왜? 무슨 의미?
- 해당 발전 패턴이 웹 플랫폼 그 자체에 적용되었을 때 잠재성에 대해서 무척 기대가 된다.
- 웹 컴포넌트는 조용하지만, 여전히 진행되고 있고, SSRr과 전역 등록 이슈 해결을 위한 작업이 진행 중이다. 그 스펙은 3세대 프레임워크들과 더 높은 호환성을 가지게 해줄 것이다.
- 웹 어셈블리도 이 발전 패턴을 적용하여 놀라운 결과를 낳도록 만들 수 있다.
- 어떤 언어로도 작성할 수 있는 풀-스택 프레임워크를 상상해보자.
- 동형 러스트, 동형 파이썬, 동형 스위프트, 동형 자바 등등
- 프론트엔드와 백엔드 사이의 장벽을 시스템 끝부분에 아주 조금의 **HTML 템플릿만 남겨두고** 거의 사라지도록 만들 수도 있다.
- 현재 파편화의 시대를 지나왔다.
- 매일 매일 새로운 자바스크립트 프레임워크(춘추 전국시대)의 시대는 이제 지났다.
- 자유와 유연성은 혁신을 낳았지만, 그것들은 지저분하고, 끊어져 있고, 종종 근본적으로 망가진 웹 경험을 낳기도 했다.
- 이전에는, 개발자들이 한정된 자원과 빡빡한 일정 속에서 수십 가지 옵션들 중에서 고른 도구들을 직접 조립해야 했었다.
  - 그 결과 어떤 앱들은 놀라울 정도로 빠르고, 안정적이고, 신뢰할 수 있고 사용하기 즐거운 반면, 어떤 다른 앱들은 불편하고, 어렵고, 느리고, 망가져 있었다.
- *처음부터 올바른 일을 해주는* 도구를 사용함으로써 개발이 더 쉬워지게 만들 수 있다. 웹 사이트의 평균적인 품질이 조금 더 좋아질 수 있고, 평균적인 웹 경험이 더 부드러워질 수 도 있다.
- 좋은 도구가 모든 사이트를 좋게 만들지는 못한다.
- 평균적인 웹 경험이 더 부드러워 질 수도 있다.
- 좋은 도구가 모든 사이트를 좋게 만들지는 못한다.
- 코드의 양은 나쁜 UX에 대한 해결책이 될 수 없다.
- 같은 기반을 제공함으로써 모든 사이트는 조금 더 나은 상태에서 시작하게 될 것이다.
- 그리고 모든 개발은 보다 더 중요한 일에 집중할 수 있게 될 것이다.

## 참고

- <https://blog.rhostem.com/posts/2022-05-27-Four-Eras-of-JavaScript-Frameworks>

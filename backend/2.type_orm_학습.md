# typeorm

- Active Record
  - 참고
    - <https://en.wikipedia.org/wiki/Active_record_pattern>
- data Mapper
  - 참고
    - <https://en.wikipedia.org/wiki/Data_mapper_pattern>
- Custom repositories
  - 참고
    - <https://typeorm.io/custom-repository#>
- 의문
  - Active record, data mapper, custom repositories의 차이점?
  - Repository 가 EntityManager보다 편리한 이유는?
    - <https://typeorm.io/#loading-from-the-database>
  - Repository 로 mocking 또는 stub으로 테스트 가능?
    - <https://typeorm.io/#updating-in-the-database>
  - model과 entity 차이?
    - model은 단순 class, entity는 (데코레이터를 통해서) class가 DB Table과 매핑 됨.
  - 왜 relation 시, 데코레이터 인자로 함수를 강제함? (entity를 바로 안 넣고?)
    - <https://typeorm.io/#creating-a-one-to-one-relation>
      - instead of using the class directly, because of the language specifics. We can also write it as () => Photo, but we use type => Photo as a convention to increase code readability. **The type variable itself does not contain anything.**
      - (I cannot understand the syntax of callback passed to the TypeORM Relations decorator) <https://stackoverflow.com/questions/66409746/i-cannot-understand-the-syntax-of-callback-passed-to-the-typeorm-relations-decor>
        - <https://github.com/typeorm/typeorm/blob/master/src/metadata-args/RelationMetadataArgs.ts#L48>
    - (Relation decorators: allow to pass string instead of typeFunction) <https://github.com/typeorm/typeorm/issues/4190>
      - The following pattern would now prevent circular dependency issues
  - relation을 단방향으로 소유권을 가지게 하는 이유는?
    - Foreign key를 관계 소유권 entity가 가짐
      - Foreign key를 가진 의미는?
      - Foreign key가 된 객체는 상대방의 존재를 알지 못함.
  - relation을 양방향으로 하는 이유는?
    - 프로덕트에서 그렇게 쓰이려고
  - QueryBuilder가 대부분의 복잡한 SQL 쿼리를 대체한다고 하는데, 대체 못하는 쿼리는 무엇이 있을까?

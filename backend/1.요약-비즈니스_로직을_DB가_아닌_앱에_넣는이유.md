
# 비즈니스 로직

- 도메인 로직 또는 애플리케이션 로직을 의미하고, 프로그램의 핵심 로직.
- 업무에 필요한 데이터를 처리를 수행하는 응용 프로그램의 일부
  > 데이터 생성, 입력, 수정, 조회, 보고서 처리 등을 수행하는 루틴
- 예시, 쇼핑몰 장바구니
  - 기능 설명: 장바구니 물품을 추가할 때마다, 결제예정 금액이 추가된 물품 금액이 반영됨.
  - 장바구니의 결제예정 금액이 물품이 추가됨에 따라 결제 예정 금액이 수정되는 로직이 바로, 비즈니스 로직이다.
- CRUD를 포함한 복잡한 로직을 구현해야 할 때.
- 유지보수, 확장성에 큰 영향을 줌.
- 참고
  - <https://medium.com/@su_bak/term-business-logic%EC%9D%B4%EB%9E%80-6d53c4782d73>

# 비즈니스 로직을 DB가 아닌 앱에 넣어야 하는 이유

- 데이터베이스 내에 애플리케이션 비즈니스 로직을 추가하는 것은 최대한 지양
- 애플리케이션 리소스가 더 확장하기 쉽다
  - 이유는, 애플리케이션 서버 리소스가 데이터베이스 서버 리소스보다 확장하기 훨씬 더 쉽다.
  - 웹 애플리케이션에서 트래픽이 증가하면, 쉽게 애플리케이션 서버를 추가해 늘어난 부하를 처리할 수 있다.
  - 반면에 SQL 데이터베이스 확장은 애플리케이션 서버를 추가하는 것 보다 보다 비용이 높다.
- 복잡한 필터링 처리는 데이터베이스의 일
  - 예시
    - 반환되는 결과의 양을 통제하려면 데이터베이스 티어에 넣는 것이 타당하다.
    - 매우 큰 데이터베이스 테이블에 대한 복잡한 필터 조건을 가진 쿼리를 생각해보자.
      - Select * from mutable where
    - 데이터베이스 대신 어플리케이션 계층에서 이 복잡한 필터 쿼리를 실행하려면 일반적으로, 먼저 데이터베이스에서 모든 데이터를 불러와야 한다.
      - Select * from mytable
      - 이 경우 mytable의 모든 데이터가 애플리케이션 계층에 반환된다.
      - 이후 애플리케이션 계층은 이 데이터를 대상으로 적용한 필터 조건에 맞지 않는 모든 행을 버린다.
      - 문제는 이 요청을 처리하려면 mytable의 모든 내용을 애플리케이션 계층으로 전송해야 한다는 것이다.
      - 대용량 데이터 집합의 경우 현실적으로 불가능한 일이다.
    - 많은 경우 쿼리 또는 일련의 쿼리를 리팩토링 하는 것만으로 이와 같은 문제를 피하고, 과도한 데이터 트래픽 없이 애플리케이션에서 더 많은 로직을 실행할 수 있다.
- 추출과 필터링 분리하기
  - 흔히 결과 필터링과 결과 추출의 개념을 하나의 쿼리로 결합한다.
  - 특히 대량의 데이터가 포함된 큰 테이블을 다룰 때는 필요한 행을 선택하기 위한 모든 필터링과 사양을 수행하는 쿼리를 작성한 다음, 이 쿼리를 통해 선택된 행에서 필요한 모든 데이터를 반환한다.
  - Select * from mutable where
  - 얼핏 괜찮아 보이지만, 쿼리에 복잡한 조인이나 다른 작업이 포함되는 경우, 데이터베이스에 큰 부담이 되고 데이터베이스 리소스가 소진될 수 있다.
  - 이 문제를 피하는 방법의 하나는 모든 행에서 필터 쿼리에 필요한 필드만 반환하는 첫 쿼리를 수행한 다음 애플리케이션에서 필터링 로직을 수행하는 것이다.
  - Select id, field1, field2 from my_table
  - 그런 다음, 애플리케이션에서 field1과 field2에 대해 복잡한 필터 쿼리 로직을 수행할 수 있다.
  - 결과는 복잡한 쿼리에 일치하는 mytable의 행 ID 목록이다.
  - 일치하는 ID 목록을 구하고나면 사전에 필터링된 행에서 실제 데이터를 가져오는 후속 쿼리를 수행한다.
  - Select * from my_table where id in (3,5,123,392)
  - 두 쿼리 모두 매우 간단하게 실행할 수 있다.
  - 데이터베이스에서 해야 하는 복잡한 작업은 없다. 반환할 데이터를 선택하는 데 필요한 비즈니스 로직이 애플리케이션 계층에서 실행되지만 데이터베이스에서 애플리케이션으로 전송해야 하는 부가적인 데이터는 극히 미미하다.
  - 별도의 필터링 쿼리와 데이터 추출 쿼리로 쿼리를 분할함으로써 요청을 리팩토링해서 복잡하고 리소스 소비량이 큰 비즈니스 로직을 데이터베이스가 아닌 애플리케이션에서 실행했다.
- 반환되는 결과를 대상으로 하는 작업 피하기
  - 비즈니스 로직을 데이터베이스에서 꺼내 애플리케이션 계층으로 옮기는 또 다른 쉬운 방법은 반환된 결과에 대한 계산을 데이터베이스에서 수행하지 말고 애플리케이션에서 수행하는 것이다.
  - 이런 형식의 쿼리는 지양한다.
    - Select POWER (SQRT(field1) * SIN(field2), 5) from my_table where …
  - 대신 다음과 같이 한다.
    - Select field1, field2 from my_table where …
  - 그런 다음 반환된 결과로 애플리케이션에서 POWER(SEQRT(field1) * SIN(field2),5)등의 작업을 수행한다.
  - 결과적으로, 계산을 수행하는 데 필요한 모든 컴퓨팅이 희소한 데이터베이스 리소스가 아닌 풍부한 애플리케이션 리소스를 활용하게 된다.
- 조인을 애플리케이션 계층으로 옮기기
  - 복잡한 조인은 데이터베이스 리소스가 필요한 또 다른 영역이다.
  - 데이터베이스에서 데이터를 조인하지 말고, 조인 로직을 최대한 애플리케이션 계층으로 옮긴다.
  - 이렇게 코드를 리팩토링하면 확장성을 늘리면서 데이터베이스에 대한 부하를 대폭 줄일 수 있다.
- 고리 끊기
  - 항상 이런 방식으로 쿼리를 리팩토링 할 수 있는 것은 아니다.
  - 데이터베이스 자체 내에서 복잡한 쿼리를 수행해야 할 때도 있다.
  - 그러나 복잡한 쿼리를 최대한 제거하면, 빈약한 데이터베이스 리소스에 대한 의존을 줄이고 풍족한 애플리케이션 수준 리소스에 대한 의존을 늘릴 수 있다.
- 참고
  - <https://www.itworld.co.kr/news/208352>

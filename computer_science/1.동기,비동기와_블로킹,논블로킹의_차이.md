# 동기,비동기와_블로킹,논블로킹의_차이
- 서로 독립된 개념이고, 단지 조합하여 사용한다.

## 동기, 비동기 
- 핵심
    - 프로세스의 수행 순서 보장에 대한 매커니즘.
- 국어 사전상 의미
    - 동기: 사전 상 의미는 같은 시기
    - 비동기: 정보·통신 앞에서 행하여진 사상(事象)이나 연산이 완료되었다는 신호를 받고 비로소 특정한 사상이나 연산이 시작되는 방식.
- 동기화와 다른 의미를 가짐.
    > 동기화는 서로 다른 상태를 같은 것으로 만드는 것.
- 영어 사전상 의미
    - synchronous [adjective]
        - happening, existing, or arising(생기다) at precisely(바로) the same time
        - 동일한 시간(형용사 이므로, 구체적이지 않음)에 발생 또는 존재하는 것
    - synchronization
        - the state of being synchronous
    - 예시) 아이폰과 아이튠스가 작업이 끝남과 동시에 Synchronous한 상태가 된다.
    - 결론으로, Synchronization은 Synchrous한 상태이다. 동기와 동기화는 근본적으로 같은 뜻이다. 같은 단어를 공유하는 이 두 단어가 한국어로 변형되며 다른 뜻이 되는 것은 영어를 한국어로 번역하는 과정에서 영어 특유의 뉘앙스를 제대로 표현하기 어렵기 때문에 발생하는 문제이다. (교수님 또는 과학자들이 한국어로 말하는 중간에 영어 단어를 섞어가면서 사용하는 이유도 됨.)
- 컴퓨터 공학
    - 동기
        - **현재 작업의 응답이 발생함과 동시에 다음 작업을 요청하는 것. 즉 정해진 순서를 가지고 진행함.**
        - 정제
            - 현재 작업의 응답이 발생함과 동시에 다음 작업을 요청한다는 것은, 작업이 어떠한 순서를 가지고 진행됨을 의미한다.
            - 즉, 현재 작업의 응답과 다음 작업의 요청의 타이밍을 맞추는 방식이다.

## 블로킹, 논블로킹
- 프로세스의 유휴 상태에 대한 개념.


## 동기 방식 + 블로킹 방식
- 동기
    - 작업의 흐름과 순차적으로 진행됨을 보장 된다.
- 블로킹
    - 어떠한 작업이 진행 중일 때 다른 작업을 동시에 할 수 없다.
- 예시)
    - 반복문
    - ```
        function employee () {
            for (let i = 1; i < 101; i++) {
                console.log(`직원: 인형 눈알 붙히기 ${i}번 수행`);
            }
        }

        function boss () {
            console.log('사장: 출근');
            employee();
            console.log('사장: 퇴근');
        }

        boss();
      ```
- 결과
    - Stack에 의해서 함수 호출이 Last In First Out으로 진행됨.
    - [!img1](./imgs/1.png)
    - 상위 Process인 boss 함수는 출근 작업을 수행한 후, 하위 프로세스인 employee 함수에게 작업을 요청하고, employee는 작업을 완료 후 boss 함수는 퇴근을 할 수 있다.
    - 즉, 작업을 지시한 상위 프로세스는 하위 프로세스가 종료될 때 까지 종료할 수 없다. 또한 상위 프로세스는 대기 중 아무 일도 할 수 없다.
    - "employee가 작업 중에 boss가 다른 일을 할 수 있는 방식이 존재할까" 란 의문을 가질 수 있다.

## 동기 방식 + 논블로킹 방식
- 예시 
    - ```
        function* employee () {
            for (let i = 1; i < 101; i++) {
                console.log(`직원: 인형 눈알 붙히기 ${i}번 수행`);
                yield;
            }
            return;
        }

        function boss () {
        console.log('사장: 출근');

        const generator = employee();
        let result = {};

        while (!result.done) {
            result = generator.next();
            console.log(`사장: 유튜브 시청...`);
        }

        console.log('사장: 퇴근');
        }

        boss();
      ```
        - 콘솔 로그 결과 출력
            - ```
                사장: 출근
                직원: 인형 깔알 붙히기 1번 수행
                사장: 유튜브 시청...
                직원: 인형 눈알 붙히기 2번 수행
                사장: 유튜브 시청...
                ...
                직원: 인형 눈알 붙히기 100번 수행
                사장: 유튜브 시청...
                사장: 퇴근
              ```
    - 결과
        - 상위 프로세스인 boss 함수는 출근 후, 하위 프로세스인 employee를 호출해서 매 작업에 대해서 작업이 끝났음을 확인 후 끝나지 않은 경우 작업을 지시한다.
        - 만약 상위 프로세스인 boss는 employee가 작업을 완료하지 않았다면, 자신 또한 열심히 유투브 시청을 수행한다.
        - 코드는 동기적인 흐름을 가지고 진행하지만, boss 함수 또한 중간중간 자신의 작업을 수행하고 있으므로 블로킹이 아닌 논블로킹 방식을 사용하고 있다.
        - [!img2](./imgs/2.png)
        - boss는 employee 함수의 작업이 끝나기 전까지는 절대 퇴근을 할 수 없다. 즉 작업의 순서가 지켜지고 있는 것이다.
        - 결론으로 동기 방식은 작업의 순차적인 흐름만 지켜진다면 (boss 프로세스 기준으로) 블로킹이든 논블로킹이든 아무 상관이 없다고 할 수 있다.
        - 주의할 점은 Generator를 실행시킨 순간에는 순간 Boss 프로세스는 동기이므로, 대기를 한다. 

## 컴퓨터 공학에서 비동기
- 핵심
    - 현재 작업의 응답과 다음 작업의 요청 타이밍이 일치하지 않아도 되는 것
- 추가 설명
    - 동기의 경우 상위 프로세스가 하위 프로세스에게 작업을 지시할 때 작업의 종료 시점을 알고 있어야 한다. 하위 프로세스의 작업 종료 시점(정상 종료, 비정상 종료를 포함한)은 항상 작업을 지시한 상위 프로세스의 관심사이다.
    - 비동기 방식은 다르다. 상위 프로세스는 작업을 지시 후 하위 프로세스와 하위 프로세스의 작업 그리고 작업 종료 여부는 관심사가 아니다.
    - 즉 상위 프로세스가 하위 프로세스의 작업이 순차적으로 이루어짐을 보장할 수 없다.
    - 참고로 동기와 같은 원리로, 상위 프로세스가 블로킹인지 논블로킹인지 여부는 중요하지 않다.

## 비동기 방식 + 논블로킹 방식
- 핵심
    - 상위 프로세스는 하위 프로세스의 작업 종료 여부가 관심사가 아니다.
    - 하위 프로세스는 작업이 종료되면, 스스로 상위 프로세스에게 보고를 하거나 다른 프로세스에게 일을 맡기거나 할 것이다.
    - 논블로킹 방식이므로, 상위 프로세느느 하위 프로세스에게 작업을 맡긴 후 자신의 작업을 계속 수행할 수도 있다.
- 예제
    - ```
        function employee (maxDollCount = 1, callback) {
        let dollCount = 0;
        const interval = setInterval(() => {
            if (dollCount > maxDollCount) {
            callback();
            clearInterval(interval);
            }
            dollCount++;
            console.log(`직원: 인형 눈알 붙히기 ${dollCount}번 수행`);
        }, 10);
        }

        function boss () {
        console.log('사장: 출근');
        employee(100, () => console.log('직원: 눈알 결산 보고'));
        console.log('사장: 퇴근');
        }

        boss();
      ```
        - 콘솔 결과
            - ```
                사장: 출근
                사장: 퇴근
                직원: 인형 눈알 붙히기 1번 수행
                직원: 인형 눈알 붙히기 2번 수행
                ...
                직원: 인형 눈알 붙히기 100번 수행
                직원: 눈알 결산 보고
              ```
- 결론
    - [!img3](./imgs/3.png)
    - boss는 employee에게 작업을 지시 후 바로 퇴근 했다. 
    - 상위 프로세스인 boss 함수는 employee 함수의 작업의 종료시점이 관심이 없으며, 작업의 완료 신호는 콜백으로 넘겨진 눈알 결산보고 작업이 대신 받아서 처리하고 있다.
    - 장점으로 비동기 + 논블로킹 방식은 여러 개의 작업을 동시에 처리할 수 있는 부분에서 효율적이지만, 단점으로 너무 복잡하게 얽힌 비동기 처리에 의해서 개발자가 어플리케이션의 흐름을 읽기 어려워지는 등의 문제가 있을 수 있다.
    - JS에서는,  Promise와 async/await와 같은 문법을 사용하는 이유는 이러한 비동기 처리의 흐름을 조금 더 명확하게 인지하고자 하기 때문이다.
        - 의문
            - async/await는 호출한 곳 입장에서 비동기가 아닌 동기이지 않을까? Promise는 비동기가 맞다고 생각은 함.
    - 또한 NodeJS에서는, 이벤트 루프와 같은 비동기 방식도 내부 구현을 분석하면 동기적인 패턴이 포함되어 있기 떄문에 남발 시 병목 현상이 생길 확률이 높다.

## 비동기 방식 + 블로킹 방식
- 일반적인 어플리케이션 레이어에서 자주 사용되지 않고, Linux와 Unix 등의 운영체제의 I/O 다중화 모델
- 비동기 방식의 장점은 하위 프로세스의 작업이 끝나는 것을 기다리지 않음으로서 여러 개의 작업을 동시에 처리할 수 있다는 점이다. 이유는 프로세스가 블로킹 된 경우 유휴 상태가 되서 아무 것도 처리할 수 없기 때문이다.
- 해당 개념이 나오게 된 배경
    - 동기 + 블로킹 I/O의 경우 직관적이나, 동시에 여러 개의 I/O를 처리할 수 없다.
    - 논블로킹 I/O는 프로세스들의 작업을 컨트롤 하는 것이 까다롭다.
        - C로 구현함.
    - 동기 + 블로킹 I/O와 멀티 프로세싱이나 스레딩을 결합해서 쓰는 경우 자원 문제가 발생할 수 있고, 프로세스/스레드 간 통신과 동기화가 어려움.
- "프로세스를 블로킹 시키고 비동기로 여러 개의 I/O를 다중화해서 처리하는 역할을 하나 만드는 것이 어떨까"이다. 
    - 이를 통해 직관적인 코드의 흐름을 유지하면서도 작업을 동시에 처리할 수 있다.
    - 참고
        - (Boost application performance using asynchronous I/O) https://developer.ibm.com/articles/l-async/
- [!img4](./imgs/4.png) 
    - `select()`는 프로세스를 블로킹함과 동시에 여러 개의 I/O를 처리하는 역할을 한다.
- 인터페이스 명세
    - ```
        int select (int nfds, fd_set *readfds, fd_set *writefds,  fd_set *exceptfds, struct timeval *timeout);
        ```
        - nfds는 감시할 파일의 개수.
        - fd_set 구조체는 각각 읽을 데이터, 쓰여진 데이터, 예외처리가 발생한 것을 감시할 파일 목록이다.
            - fd는 File Descriptor의 약자.
            - 파일을 감시하면서 해당 I/O가 발생하면 자신의 비트 배열 구조체의 해당 값을 1로 변경한다.
        - timeval 구조체인 timeout은 감시할 시간을 의미한다. 해당 시간 동안 상위 프로세스를 블로킹 하면서 자신이 넘겨 받은 파일 목록을 지속적으로 감시하는 것이다.
        - 감시하는 동안 파일에 읽기, 쓰기, 예외가 발생하면 select 함수가 종료될 때 자신이 감시하는 파일들 중 해당 변경 사항이 발생한, 즉 처리해야 하는 파일의 개수를 반환한다.
- 결론
    - select 함수는 일정 시간 동안 프로세스를 정지시키고 자신이 감시하고 있는 파일에서 I/O가 발생하는지 감시한다. 그러다가 일정 시간이 지나면 함수가 종료되며 그 동안 감시했던 파일들의 I/O 결과를 반환하고 프로세스의 블로킹을 해제한다.
    - 블로킹으로 진행되는 측면에서 개발자에게도 직관적으로 다가오고, 비동기 방식이기 때문에 여러 개의 I/O를 동시에 감시하며 처리할 수 있다.
    - 단점으로 성능이 좋은 편은 아니므로, 높은 성능이 필요한 어플리케이션에서는 되도록 사용을 자제한다.


## 질문
 - multiplexing? (select/pool)
 - AIO?
 - JS, generator는 어떤 방식으로 구현되었을까? Iterable?
 - Promise와 Async/await의 동기, 비동기적인 정확한 차이점

## 참고
- https://evan-moon.github.io/2019/09/19/sync-async-blocking-non-blocking/
    - 해당 아티클을 중점으로 요약 정리를 함.
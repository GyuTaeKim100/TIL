# fx-js-응용 시간을 이터러블로 다루기
## range와 take의 재해석

### 즉시 평가 예제
- 각 파이프 내 함수는 1번씩만 실행되는 유틸성 함수의 특성을 가진다.
```js
    _.go(
        _.range(10), // 0부터 9까지의 배열 생성한다.
        _.take(3), // 앞에서 3개만 자른다.
        _.each(console.log) // [1,2,3] 
    )
```

### 지연 평가 예제 1
- 전 상태에 실행이 의존된다.
    - 지연평가 L은 전 함수의 실행에 의존한다.
    - 세로로 위, 아래로 왕복 형식의 실행 흐름을 보인다.
- 실행 흐름이 의미적인 차이를 만든다.
```js
    _.go(
         // 0부터 9까지의 이터러블 
         //     최대 10번 일어날 일 (예약어 개념)
         // Infinity도 인자로 허용됨.
        L.range(10),

        // 최대 3개의 값을 필요로 한다. (예약어 개념)
        L.take(3),
        _.each(console.log)
        // 0
        // 1
        // 2
    )
```

### 지연 평가 예제 2
```js
    _.go(
        L.range(10),    // 최대 10번 실행 흐름 발생시킨다.

        // _.delay 설명
        //   Promise를 반환한다.
        //  첫 인자는 시간, 두번째 인자는 반환값이다.
        //  커링 처리 되어 있다. (인자 2개에 대해서)
        L.map(_.delay(1000)),  
        L.take(3),  // 최대 성공은 3
        _.each(console.log)
    )
```
#### 의문
1. _.delay의 반환값은 Promise이고 이는 선언 즉시 실행되는데, 순차적으로 1초 단위로 Promise 평가되면서 take가 가능할까?
    - 된다.
    - 구현 구조가 제너레이터 yield이므로, 선언은 yield 후 평가 된다.

### 지연 평가 예제 3 - lisp로 바라보기
- 배열 요소라는 관점에서 확장해서, '...가 일어날 것이다'라는 선언적으로 바라보면서, 이터러블로, 또는 Lisp으로 바라보기
- 효과를 만드는 일을 시점, 시간으로 프로그래밍이 가능하다. (예시: _.delay)
- 즉, 이터레이터, 이터러블로 시간을 표현할 수 있다.
    - 발전 시 rx 프로그래밍이다.

#### 의문
- rx는 시간을 표현하기 위해서 어떻게 보다 발전했는가?

## takeWhile, takeUntil
- take는 일어날 일을 제한 하였었다.
- 보다 동적으로 효과적으로 제한 할 수 있는 헬퍼 함수인 takeWhile과 takeUntil이 존재한다.

### takeWhile 즉시 평가
- 단순 배열 범위를 좁히기이다. (부분 집합 추출)
```js
    _.go(
        [1,2,3,4,5,6,7,8,9,0,0,0],
        _.takeWhile(a=>a), // 1부터 8까지 실행한다.
        _.each(console.log)
    )
```

### takeWhile 지연 평가
- 이전 함수의 결과가 지연평가인 여부가 중요하다.
```js
    _.go(
        [1,2,3,4,5,6,7,8,9,0,0,0],
        L.map(_.delay(1000)),
        _.takeWhile(a=>a), // 1부터 8까지 순차적으로 실행된다.
        _.each(console.log)
    )
```

### takeUntil 즉시 평가
- 단순 배열 범위를 좁히기이다. (부분 집합 추출)
```js
    _.takeUntil(a => a) // 1만 실행, '~까지'란 의미
    _.takeUntil(a=> !a) // 8까지 실행
```

### takeUntil 지연 평가
- 이전 함수의 결과가 지연평가인 여부가 중요하다.
```js
    _.go(
        [1,2,3,4,5,6,7,8,9,0,0,0],
        L.map(_.delay(1000)),
        _.takeUntil(a=>!a), // 1부터 8까지 순차적으로 실행된다.
        _.each(console.log)
    )
```

### take 동시 평가 예제
```js
    _.go(
        [0, false, undefined, null, 10, 20, 30],
        _.take(3), // 모아서 한 번에 다음 함수에게 인자를 전달한다.
        _.each(console.log) // 3개 동시 평가

    )
```





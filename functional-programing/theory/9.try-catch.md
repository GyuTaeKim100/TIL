# Try-catch
 - 목표
     - Try-catch가 어떻게 참조에 투명하지 않은지 파악
     - throw의 단점

## 예제 / Try-catch 및 throw의 단점
   - 베이스 예제
       - ```
            console.clear();

            const tenDivideBy = (n: number): number => {
                if(n ===0) {
                    throw Error("0으로 나눌 수 없습니다.");
                }
                return 10 / n;
            }

            const test =() => {
                try {
                    return tenDivideBy(0);
                } catch (e){
                    return 1;
                }
            }

            export const main = () => {
                const x = test();
                console.log(x);
                console.log('프로그램이 종료 되었습니다.');
            }
         ```
          - tenDivideBy 함수의 문제점
              - 리턴 타입에 의해서 참조가 투명하지 않음 
                - 리턴 타입이 number 임에 주의
                - 숫자는 0으로 나눌 수 없다.
                    - 이 경우 throw를 통해서 에러 발생시킨다.
                - throw Error가 함수 구현에 추가되었지만, return type이 number이다. 
                - 이를 통해 함수의 return type만으로는 함수가 에러를 발생하는 지를 파악하기 어렵다.
                - 값의 부재 측면에서 return 타입 중 일부를 값의 부재로 표현 또는 undefined로 return 됨을 타입에 명시되었지만, 에러는 리턴 타입 추론이 작동하지 않는다.
                - 결론으로 해당 함수의 리턴값은 참조에 투명하지 않다. 이에 의해 Try-catch 구문이 포함된 test 함수 또한 참조에 투명하지 않게 된다.
                - 이를 해결하기 위해서 에러를 사전에 파악하려면, 별도 에러에 대해서 문서화 또는 주석을 달거나, 해당 함수의 코드를 분석해야만 한다.
                - 이런 문제점을 해결하기 위해 throw로 에러를 해결하는 대신,명시적인 값으로 리턴하는 방법도 존재한다.
  - 예제 1 
       - ```
            console.clear();

            const tenDivideBy = (n: number): number => {
                if(n ===0) {
                    throw Error("0으로 나눌 수 없습니다.");
                }
                return 10 / n;
            }

            // 코드 변경!
            const test =() => {
                try {
                    const y = tenDivideBy(0);
                    return y;
                } catch (e){
                    return 1;
                }
            }

            export const main = () => {
                const x = test();
                console.log(x);
                console.log('프로그램이 종료 되었습니다.');
            }
          ```
           - 의문
             - 프로그램에 변화가 없다. 이는 참조에 투명한 것일까?
- 예제 2 / Throw를 리턴하는 함수를 try 밖으로 빼기 
       - ```
            console.clear();

            const tenDivideBy = (n: number): number => {
                if(n ===0) {
                    throw Error("0으로 나눌 수 없습니다.");
                }
                return 10 / n;
            }

            // 코드 변경!
            const test =() => {
                const y = tenDivideBy(0);
                try {
                    return y;
                } catch (e){
                    return 1;
                }
            }

            export const main = () => {
                const x = test();
                console.log(x);
                console.log('프로그램이 종료 되었습니다.');
            }
         ```
          - 결과로 1을 리턴하는 것이 아닌, console Error를 출력하고 프로그램이 중단된다.
          - Error를 발생하는 즉시 프로그램이 중단되었기 떄문에, '프로그램이 종료 되었습니다'라는 문자열도 출력되지 않았다.
          - 이를 통해 알 수 있는 사실은 예외가 발생하는 표현식은 try-catch 블록의 안과 밖에 존재하는지에 따라 프로그램의 동작이 달라지기 떄문에 참조에 투명하지 않다.
          - 의문으로 이 참조에 투명하지 않은 문제를 해결할 수 있는 방법은 없을까?
          - 에러가 발생했을 때 Throw 대신 에러를 명시적인 값으로 반환하는 방법이 있따.
          - 에러를 명시적으로 값으로 반환하면 try-catch문 대신 에러가 아닐때와 에러일 때 코드를 별도로 작성 할 수 있다.
          - 이는 값의 부재를 다루는 Option 타입을 만든 것과 맥락이 같다.



## 참고
 - https://fastcampus.co.kr/courses/207789/clips/
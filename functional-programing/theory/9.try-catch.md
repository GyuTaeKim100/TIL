# Try-catch
 - 목표
     - Try-catch가 어떻게 참조에 투명하지 않은지 파악
     - throw의 단점

## 예제 / Try-catch 및 throw가 참조에 투명하지 않은 이유
   - 베이스 예제
       - ```
            console.clear();

            const tenDivideBy = (n: number): number => {
                if(n ===0) {
                    throw Error("0으로 나눌 수 없습니다.");
                }
                return 10 / n;
            }

            const test =() => {
                try {
                    return tenDivideBy(0);
                } catch (e){
                    return 1;
                }
            }

            export const main = () => {
                const x = test();
                console.log(x);
                console.log('프로그램이 종료 되었습니다.');
            }
         ```
          - tenDivideBy 함수의 문제점
              - 리턴 타입에 의해서 참조가 투명하지 않음 
                - 리턴 타입이 number 임에 주의
                - 숫자는 0으로 나눌 수 없다.
                    - 이 경우 throw를 통해서 에러 발생시킨다.
                - throw Error가 함수 구현에 추가되었지만, return type이 number이다. 
                - 이를 통해 함수의 return type만으로는 함수가 에러를 발생하는 지를 파악하기 어렵다.
                - 값의 부재 측면에서 return 타입 중 일부를 값의 부재로 표현 또는 undefined로 return 됨을 타입에 명시되었지만, 에러는 리턴 타입 추론이 작동하지 않는다.
                - 결론으로 해당 함수의 리턴값은 참조에 투명하지 않다. 이에 의해 Try-catch 구문이 포함된 test 함수 또한 참조에 투명하지 않게 된다.
                - 이를 해결하기 위해서 에러를 사전에 파악하려면, 별도 에러에 대해서 문서화 또는 주석을 달거나, 해당 함수의 코드를 분석해야만 한다.
                - 이런 문제점을 해결하기 위해 throw로 에러를 해결하는 대신,명시적인 값으로 리턴하는 방법도 존재한다.
  - 예제 1 
       - ```
            console.clear();

            const tenDivideBy = (n: number): number => {
                if(n ===0) {
                    throw Error("0으로 나눌 수 없습니다.");
                }
                return 10 / n;
            }

            // 코드 변경!
            const test =() => {
                try {
                    const y = tenDivideBy(0);
                    return y;
                } catch (e){
                    return 1;
                }
            }

            export const main = () => {
                const x = test();
                console.log(x);
                console.log('프로그램이 종료 되었습니다.');
            }
          ```
           - 의문
             - 프로그램에 변화가 없다. 이는 참조에 투명한 것일까?
- 예제 2 / Throw를 리턴하는 함수를 try 밖으로 빼기 
     - ```
          console.clear();

          const tenDivideBy = (n: number): number => {
              if(n ===0) {
                  throw Error("0으로 나눌 수 없습니다.");
              }
              return 10 / n;
          }

          // 코드 변경!
          const test =() => {
              const y = tenDivideBy(0);
              try {
                  return y;
              } catch (e){
                  return 1;
              }
          }

          export const main = () => {
              const x = test();
              console.log(x);
              console.log('프로그램이 종료 되었습니다.');
          }
       ```
        - 결과로 1을 리턴하는 것이 아닌, console Error를 출력하고 프로그램이 중단된다.
        - Error를 발생하는 즉시 프로그램이 중단되었기 떄문에, '프로그램이 종료 되었습니다'라는 문자열도 출력되지 않았다.
        - 이를 통해 알 수 있는 사실은 예외가 발생하는 표현식은 try-catch 블록의 안과 밖에 존재하는지에 따라 프로그램의 동작이 달라지기 떄문에 참조에 투명하지 않다.
        - 의문으로 이 참조에 투명하지 않은 문제를 해결할 수 있는 방법은 없을까?
        - 에러가 발생했을 때 Throw 대신 에러를 명시적인 값으로 반환하는 방법이 있따.
        - 에러를 명시적으로 값으로 반환하면 try-catch문 대신 에러가 아닐때와 에러일 때 코드를 별도로 작성 할 수 있다.
        - 이는 값의 부재를 다루는 Option 타입을 만든 것과 맥락이 같다.


## 에러를 값으로 다루는 타입
 - 실패하거나 성공했을 때 각각 다른 값을 가지는 자료 구조
 - ADT의 대수 자료형에서, 합 타입에 해당하는 tagged union을 흉내내도록 한다.
 - 예제 1 / Success 타입
    - ```
        type Success<R> = {
            readonly _tag : "success",
            readonly result : R
        };
      ```
 - 예제 2 / Failed 타입
     -  ```
          type Failed<E> = {
              readonly _tag : "failed",
              readonly result : E
          }; 
        ```
 - 예제 3 / Try 타입
     - ```
          type Success<R> = {
              readonly _tag : "success",
              readonly result : R
          }; 

          type Failed<E> = {
              readonly _tag : "failed",
              readonly result : E
          }; 

          // 에러가 발생하고 있다.
          export type Try = Failed | Success
       ```
        - Try 타입에서 에러가 발생하는 이유
          - Faild와 Success는 타입 파라미터가 각각 1개씩 필요하기 때문에 에러가 발생한다.
          - 둘은 서로 다른 타입을 허용해야 하므로, Try는 Failed와 Success에 대해 개별적으로 전달될 타입 파라미터를 각각 하나씩 입력해야 하므로, Try는 2가지 파라미터를 입력 받아야 한다.
 - 예제 4 / Try 타입 개선
     - ```
          type Success<R> = {
              readonly _tag : "success",
              readonly result : R
          }; 

          type Failed<E> = {
              readonly _tag : "failed",
              readonly result : E
          }; 

          export type Try<E, R> = Failed<E> | Success<R>;
       ```
 - 예제 5 / 성공과 실패를 만드는 함수 추가
     - ```
         type Success<R> = {
              readonly _tag : "success",
              readonly result : R
          }; 

          type Failed<E> = {
              readonly _tag : "failed",
              readonly result : E
          }; 

          export type Try<E, R> = Failed<E> | Success<R>; 

          export const success = <R>(result: R): Try<never, R> => ({
              _tag: 'success',
              result
          })
          
          export const failed = <E>(error: E): Try<E, never> => ({
              _tag: 'failed',
              error,
          })
       ``` 
        - success, failed 두 함수에서는 never이 사용되고 있다.
        - 이는 Try의 인터페이스에 의해서 사용하지 않는 타입에 대해서 never를 사용.
        - 리턴 타입에는 success 타입 또는 failed 타입이 아닌 Try 타입을 사용했다.
        - 이유는 값을 만들 때는 success 또는 failed 등 구체적인 타입으로 추론 시키는 것 보다 일반적인 Try로 만들고, 구체적인 타입을 알아야 할 때는 type을 구분해서 그에 맞는 동작을 하는 것이 더 범용적이기 때문이다.
        - 추가로 never를 사용할 때는 안 쓰는 타입 파라미터가 참조되지 않을 때이다.
- 예제 6 / 타입 확인 함수 추가
    - ```
          type Success<R> = {
              readonly _tag : "success",
              readonly result : R
          }; 

          type Failed<E> = {
              readonly _tag : "failed",
              readonly result : E
          }; 

          export type Try<E, R> = Failed<E> | Success<R>; 

          export const success = <R>(result: R): Try<never, R> => ({
              _tag: 'success',
              result
          })
          
          export const failed = <E>(error: E): Try<E, never> => ({
              _tag: 'failed',
              error,
          })

          export const isSuccess = <R>(ta: Try<unknown, R>): ta is Success<R> => ta._tag ==="success";
          export const isFailed = <E>(ta: Try<E, unknown>): ta is Failed<E> => ta._tag ==='failed';
      ```
        - isSuccess, isFailed 함수는 안쓰는 함수 인자를 unknown을 사용했는데, 만약 해당 함수 인자가 함수 내에서 사용 될 때는 never 보다 unknown이 더 적합하다.
        - unknown, never에 관련해서
           - 타입스크립트의 타입시스템이 subtype을 사용하기 때문인데, 인자 타입과 리턴 타입에 따라 subtype의 동작이 달라지기 떄문이다.
           - 이를 공변성과 반공변성이라고 표현한다. (이는 심화주제이므로 다음에 학습하자)
           - 이전 예제 중 Option을 처리하는 getOrElse를 사용햇었는데, 이는 값이 없으면 사용할 기본 값을 설정 후 Option을 제거한 타입으로 만드는 함수였다.
           - Try에서도 이러한 역할을 하는 함수를 만든다면 Option과 비슷한 방식으로 구현 할 수 있을것이다.
 - 예제 7 / Try를 대체 할 getOrElse 함수 제작
     - ```
           type Success<R> = {
                readonly _tag : "success",
                readonly result : R
            }; 

            type Failed<E> = {
                readonly _tag : "failed",
                readonly result : E
            }; 

            export type Try<E, R> = Failed<E> | Success<R>; 

            export const success = <R>(result: R): Try<never, R> => ({
                _tag: 'success',
                result
            })
            
            export const failed = <E>(error: E): Try<E, never> => ({
                _tag: 'failed',
                error,
            })

            export const isSuccess = <R>(ta: Try<unknown, R>): ta is Success<R> => ta._tag ==="success";
            export const isFailed = <E>(ta: Try<E, unknown>): ta is Failed<E> => ta._tag ==='failed'; 

            export const getOrElse = <R>(ta: Try<unknown, R>, defaultValue: R): R => {
              // 에러가 있을 경우 기본 값을 사용한다.
              if(isFailed(ta)) return defaultValue;              

              // 결과가 성공이라면 해당 값을 사용한다.
              return ta.result;
            }
       ```
        - 추가 개선 방향
          - error를 구분할 수 있다면 더 활용도가 높아질 것이다.
            - 이를 위해 getOrElse함수의 에러 처리 절은, default value는 값이 아니라 error type의 값을 입력 받아 성공 타입에 대한 값을 리턴하는 함수가 되어야 한다.
 - 예제 8 / getOrElse 개선
     - ```
           type Success<R> = {
                readonly _tag : "success",
                readonly result : R
            }; 

            type Failed<E> = {
                readonly _tag : "failed",
                readonly result : E
            }; 

            export type Try<E, R> = Failed<E> | Success<R>; 

            export const success = <R>(result: R): Try<never, R> => ({
                _tag: 'success',
                result
            })
            
            export const failed = <E>(error: E): Try<E, never> => ({
                _tag: 'failed',
                error,
            })

            export const isSuccess = <R>(ta: Try<unknown, R>): ta is Success<R> => ta._tag ==="success";
            export const isFailed = <E>(ta: Try<E, unknown>): ta is Failed<E> => ta._tag ==='failed'; 

            export const getOrElse = <R>(ta: Try<unknown, R>, defaultValue: (e: E)=> R): R => {
              // 에러가 있을 경우 에러에 기반하여 기본 값을 결정한다.
              if(isFailed(ta)) return defaultValue(ta.error);              

              // 결과가 성공이라면 해당 값을 사용한다.
              return ta.result;
            }
       ```
        - 알 수 있는 사실
          - 대수 자료형과 패턴 매칭을 제공하는 일부 언어들은, 언어에서 제공하는 Option 또는 Try를 만들 때 필요한 3~4줄 분량의 타입 선언만으로도 우리가 직접 만든 여러 가지 타입들과 타입들과 동일한 기능을 제공하기도 한다.
          - 그러한 언어는 조금 더 구현에 편할 수 있을지 모르나, 이러한 기법을 잘 안다면 타입 스크립트 뿐 아니라 다른 언어들에서도 충분히 직접 만들어서 사용 할 수 있을 것이다.
          - 직접 구현을 통해 Option과 상당히 비슷함을 알 수 있다. 
          - 다음 섹션에서는 Option과 Try의 트레이드 오프를 파악한다.

## Try Type을 이용한 try-catch와 Try 타입의 트레이드 오프 판단
 - 목적
     - 베이스 예제에서 상품 별 수량이 잘 못 지정된 경우 try-catch와 Try 타입의 트레이드 오프를 판단한다.
 - 추가 요구사항
     - 한 번에 구매할 수 있는 갯수 제한
         - 상품 당 최대 구매 수량을 10개로 제한 및 마이너스 수량을 제한
 - 베이스 예
     - ```
           type Success<R> = {
                readonly _tag : "success",
                readonly result : R
            }; 

            type Failed<E> = {
                readonly _tag : "failed",
                readonly result : E
            }; 

            export type Try<E, R> = Failed<E> | Success<R>; 

            export const success = <R>(result: R): Try<never, R> => ({
                _tag: 'success',
                result
            })
            
            export const failed = <E>(error: E): Try<E, never> => ({
                _tag: 'failed',
                error,
            })

            export const isSuccess = <R>(ta: Try<unknown, R>): ta is Success<R> => ta._tag ==="success";
            export const isFailed = <E>(ta: Try<E, unknown>): ta is Failed<E> => ta._tag ==='failed'; 

            export const getOrElse = <R>(ta: Try<unknown, R>, defaultValue: (e: E)=> R): R => {
              // 에러가 있을 경우 에러에 기반하여 기본 값을 결정한다.
              if(isFailed(ta)) return defaultValue(ta.error);              

              // 결과가 성공이라면 해당 값을 사용한다.
              return ta.result;
            }
       ```
     - ```
          export interface Item {
              readonly code: string;
              readonly outOfStock: boolean;
              readonly name: string;
              readonly price: number;
              readonly quantity: number;
              readonly discountPrice?: number;
          } 

          export const cart : ArrayItem = [
              {
                  code : 'tomato,
                  outOfStock: false,
                  name: '토마토',
                  price: 7000,
                  quantity: 2,
                  discountPrice: 1000
              },
              ... 생략

          {
                  code : 'orange,
                  outOfStock: false,
                  name: '오렌지',
                  price: 15000,
                  quantity: 3,
                  discountPrice: 2000
              },
          ]

          import {cart, Item} from './cart';
          import * as O from './option'

          const stockItem = (item:Item): string => {
               return `
                  <li>
                      <h2>${item.name}</h2>
                      <div>가격: ${item.price - discountPrice}원 ${saleText}</div>
                      <div>수량: ${item.quantity} 상자</div>
                  </li>
              `;
          }

          const outOfStockItem = (item:Item): string => {
              return `
                  <li class="gray">
                      <h2>${item.name} (품절)</h2>
                      <div class="strike">가격: ${item.price}원 (XX원 할인)</div>
                      <div class="strike">수량: ${item.quantity}상자</div>
                  </li>
              `
          }

          const item = (item: Item) : string => {
              if(item.outOfStock) {
                  return outOfStockItem(item);
              } else {
                  return stockItem(item);
              }
          }

          const totalCalculator = (list: ArrayItem, getValue: (item: Item) => number) : number {
              const result : Array<number> = [];

              list.forEach((function(item)){
                  result.push(getValue(item));
              })
          }

          const totalCount = (list:ArrayItem): string => {
              const totalCount = totalCalculator(list, (item)=> item.quantity);

              return `<h2>전체 가격 : ${totalCount} </h2>`;
          }

          const totalPrice = (list: ArrayItem) : string => {
                  const totalPrice = totalCalculator(list, (item)=> item.price * item.quantity);
              
                  
                  const totalDiscountPrice = totalCalculator(list, (item)=> {
                      let discountPrice = O.getOrElse(O.fromUndefined(item.discountPrice));

                      return discountPrice * item.quantity;
                  })

                  return `<h2>전체 가격: ${totalPrice - totalDiscountPrice}원 (총 ${totalDiscountPrice}원 할인)</h2>`;
              }

          const list = (list: ArrayItem) => {
              let html =""

              for(let i = 0; i < list.length ; i++>) {
                  html += item(cart[i]);
              }

              return `
                  <ul>
                      ${html}
                  </ul>
              `
          }

          const app = document.getElementById('app');
          if(app != null) {
              app.innerHTML = `
                  <h1> 장바구니 </h1>
                  ${list(cart)}
                  ${totalCount(cart)}
                  ${totalPrice(cart)}
              `
          }
       ```
 - 예제 1 -1 / try-catch를 통한 문제 해결 / try-catch 구문 추가
     - ```
          export interface Item {
              readonly code: string;
              readonly outOfStock: boolean;
              readonly name: string;
              readonly price: number;
              readonly quantity: number;
              readonly discountPrice?: number;
          }

          // 코드 변경!
          // 함수의 역할은 단순한 유효성 판단이므로 return type을 지정하지 않음
          const validateItem = (item: Item) => {
              if(item.qunatity < 1) {
                  throw new Error("상품은 반드시 한 개 이상 담아야 합니다.");
              } else if(item.quantity > 10) {
                  throw new Error('한 번에 10개를 초과하여 구매할 수 없습니다.');
              }
          }

          type ArrayItem = ArrayItem;
          
          export const cart :ArrayItem = [
              {
                  code : 'tomato,
                  outOfStock: false,
                  name: '토마토',
                  price: 7000,
                  quantity: 2,
                  discountPrice: 1000
              },
              ... 생략

          {
                  code : 'orange,
                  outOfStock: false,
                  name: '오렌지',
                  price: 15000,
                  quantity: 3,
                  discountPrice: 2000
              },
          ]

          import {cart, Item} from './cart';
          import * as O from './option'


          const stockItem = (item:Item): string => {
               return `
                  <li>
                      <h2>${item.name}</h2>
                      <div>가격: ${item.price - discountPrice}원 ${saleText}</div>
                      <div>수량: ${item.quantity} 상자</div>
                  </li>
              `;
          }

          const outOfStockItem = (item:Item): string => {
              return `
                  <li class="gray">
                      <h2>${item.name} (품절)</h2>
                      <div class="strike">가격: ${item.price}원 (XX원 할인)</div>
                      <div class="strike">수량: ${item.quantity}상자</div>
                  </li>
              `
          }

          // 코드 변경!
          // validateItem을 통해 try-catch 구현
          // try 구문에는 throw 하지 않는 구문을 추가해도 되므로, 우선 validateItem을 호출하는 부분을 포함해서 함수 전체를 try-catch로 감싸본다.
          // try-catch 구문 추가 시 catch block에 아무런 코드도 추가하지 않으면, item의 return type에서 에러가 발생하고 있고, return type이 undefined가 찍혀나오고 있다. 
          const item = (item: Item) : string => {
              Try {
                validateItem(item);
                if(item.outOfStock) {
                    return outOfStockItem(item);
                } else {
                    return stockItem(item);
                }
              } catch (e) {
                
              }
          }

          const totalCalculator = (list: ArrayItem, getValue: (item: Item) => number) : number {
              const result : Array<number> = [];

              list.forEach((function(item)){
                  result.push(getValue(item));
              })
          }

          const totalCount = (list:ArrayItem): string => {
              const totalCount = totalCalculator(list, (item)=> item.quantity);

              return `<h2>전체 가격 : ${totalCount} </h2>`;
          }

          const totalPrice = (list: ArrayItem) : string => {
                  const totalPrice = totalCalculator(list, (item)=> item.price * item.quantity);
              
                  
                  const totalDiscountPrice = totalCalculator(list, (item)=> {
                      let discountPrice = O.getOrElse(O.fromUndefined(item.discountPrice));

                      return discountPrice * item.quantity;
                  })

                  return `<h2>전체 가격: ${totalPrice - totalDiscountPrice}원 (총 ${totalDiscountPrice}원 할인)</h2>`;
              }

          const list = (list: ArrayItem) => {
              let html =""

              for(let i = 0; i < list.length ; i++>) {
                  html += item(cart[i]);
              }

              return `
                  <ul>
                      ${html}
                  </ul>
              `
          }

          const app = document.getElementById('app');
          if(app != null) {
              app.innerHTML = `
                  <h1> 장바구니 </h1>
                  ${list(cart)}
                  ${totalCount(cart)}
                  ${totalPrice(cart)}
              `
          }
       ```
 - 예제 1 - 2 / try-catch를 통한 문제 해결 / try-catch 구문 개선
     - ```
          export interface Item {
              readonly code: string;
              readonly outOfStock: boolean;
              readonly name: string;
              readonly price: number;
              readonly quantity: number;
              readonly discountPrice?: number;
          }

          const validateItem = (item: Item) => {
              if(item.qunatity < 1) {
                  throw new Error("상품은 반드시 한 개 이상 담아야 합니다.");
              } else if(item.quantity > 10) {
                  throw new Error('한 번에 10개를 초과하여 구매할 수 없습니다.');
              }
          }

          type ArrayItem = ArrayItem;
          


          export const cart :ArrayItem = [
              {
                  code : 'tomato,
                  outOfStock: false,
                  name: '토마토',
                  price: 7000,
                  quantity: 2,
                  discountPrice: 1000
              },
              ... 생략

          {
                  code : 'orange,
                  outOfStock: false,
                  name: '오렌지',
                  price: 15000,
                  quantity: 3,
                  discountPrice: 2000
              },
          ]

          import {cart, Item} from './cart';
          import * as O from './option'


          const stockItem = (item:Item): string => {
               return `
                  <li>
                      <h2>${item.name}</h2>
                      <div>가격: ${item.price - discountPrice}원 ${saleText}</div>
                      <div>수량: ${item.quantity} 상자</div>
                  </li>
              `;
          }

          const outOfStockItem = (item:Item): string => {
              return `
                  <li class="gray">
                      <h2>${item.name} (품절)</h2>
                      <div class="strike">가격: ${item.price}원 (XX원 할인)</div>
                      <div class="strike">수량: ${item.quantity}상자</div>
                  </li>
              `
          }

          // 코드 변경!
          // 에러 유무와 에러의 상세 정보를 알 수 있게 되었다.
          const item = (item: Item) : string => {
              Try {
                validateItem(item);
                if(item.outOfStock) {
                    return outOfStockItem(item);
                } else {
                    return stockItem(item);
                }
              } catch (e) {
                return `<li style="color:red"> 
                    <h2>
                        ${item.name}
                    </h2>
                    <div>
                        ${e}
                    </div>
                </li>`
              }
          }

          const totalCalculator = (list: ArrayItem, getValue: (item: Item) => number) : number {
              const result : Array<number> = [];

              list.forEach((function(item)){
                  result.push(getValue(item));
              })
          }

          const totalCount = (list:ArrayItem): string => {
              const totalCount = totalCalculator(list, (item)=> item.quantity);

              return `<h2>전체 가격 : ${totalCount} </h2>`;
          }

          const totalPrice = (list: ArrayItem) : string => {
                  const totalPrice = totalCalculator(list, (item)=> item.price * item.quantity);
              
                  
                  const totalDiscountPrice = totalCalculator(list, (item)=> {
                      let discountPrice = O.getOrElse(O.fromUndefined(item.discountPrice));

                      return discountPrice * item.quantity;
                  })

                  return `<h2>전체 가격: ${totalPrice - totalDiscountPrice}원 (총 ${totalDiscountPrice}원 할인)</h2>`;
              }

          const list = (list: ArrayItem) => {
              let html =""

              for(let i = 0; i < list.length ; i++>) {
                  html += item(cart[i]);
              }

              return `
                  <ul>
                      ${html}
                  </ul>
              `
          }

          const app = document.getElementById('app');
          if(app != null) {
              app.innerHTML = `
                  <h1> 장바구니 </h1>
                  ${list(cart)}
                  ${totalCount(cart)}
                  ${totalPrice(cart)}
              `
          }
       ```
        - 추가 개선 방향
            - 아직 전체 수량과 전체 가격은 요구사항에 맞춰서 기능이 변경되지 않았다.

 - 예제 1 - 3 / try-catch를 통한 문제 해결 / try-catch 구문 개선 2
     - ```
          export interface Item {
              readonly code: string;
              readonly outOfStock: boolean;
              readonly name: string;
              readonly price: number;
              readonly quantity: number;
              readonly discountPrice?: number;
          }

          const validateItem = (item: Item) => {
              if(item.qunatity < 1) {
                  throw new Error("상품은 반드시 한 개 이상 담아야 합니다.");
              } else if(item.quantity > 10) {
                  throw new Error('한 번에 10개를 초과하여 구매할 수 없습니다.');
              }
          }

          type ArrayItem = ArrayItem;
          


          export const cart :ArrayItem = [
              {
                  code : 'tomato,
                  outOfStock: false,
                  name: '토마토',
                  price: 7000,
                  quantity: 2,
                  discountPrice: 1000
              },
              ... 생략

          {
                  code : 'orange,
                  outOfStock: false,
                  name: '오렌지',
                  price: 15000,
                  quantity: 3,
                  discountPrice: 2000
              },
          ]

          import {cart, Item} from './cart';
          import * as O from './option'


          const stockItem = (item:Item): string => {
               return `
                  <li>
                      <h2>${item.name}</h2>
                      <div>가격: ${item.price - discountPrice}원 ${saleText}</div>
                      <div>수량: ${item.quantity} 상자</div>
                  </li>
              `;
          }

          const outOfStockItem = (item:Item): string => {
              return `
                  <li class="gray">
                      <h2>${item.name} (품절)</h2>
                      <div class="strike">가격: ${item.price}원 (XX원 할인)</div>
                      <div class="strike">수량: ${item.quantity}상자</div>
                  </li>
              `
          }

          const item = (item: Item) : string => {
              Try {
                validateItem(item);
                if(item.outOfStock) {
                    return outOfStockItem(item);
                } else {
                    return stockItem(item);
                }
              } catch (e) {
                return `<li style="color:red"> 
                    <h2>
                        ${item.name}
                    </h2>
                    <div>
                        ${e}
                    </div>
                </li>`
              }
          }

          // 코드 변경!
          const totalCalculator = (list: ArrayItem, getValue: (item: Item) => number) : number {
              return list
                .filter((item) => {
                    Try {
                       validateItem(item);
                       return item.outOfStock === false;
                    } catch (e) {
                       // 상품 수량에서 재외 처리를 한다.
                       return false; 
                    }
                    
                })
                .map(getValue)
                .reduce((total, value) => total + value, 0);
          }

          const totalCount = (list:ArrayItem): string => {
              const totalCount = totalCalculator(list, (item)=> item.quantity);

              return `<h2>전체 가격 : ${totalCount} </h2>`;
          }

          const totalPrice = (list: ArrayItem) : string => {
                  const totalPrice = totalCalculator(list, (item)=> item.price * item.quantity);
              
                  
                  const totalDiscountPrice = totalCalculator(list, (item)=> {
                      let discountPrice = O.getOrElse(O.fromUndefined(item.discountPrice));

                      return discountPrice * item.quantity;
                  })

                  return `<h2>전체 가격: ${totalPrice - totalDiscountPrice}원 (총 ${totalDiscountPrice}원 할인)</h2>`;
              }

          const list = (list: ArrayItem) => {
              let html =""

              for(let i = 0; i < list.length ; i++>) {
                  html += item(cart[i]);
              }

              return `
                  <ul>
                      ${html}
                  </ul>
              `
          }

          const app = document.getElementById('app');
          if(app != null) {
              app.innerHTML = `
                  <h1> 장바구니 </h1>
                  ${list(cart)}
                  ${totalCount(cart)}
                  ${totalPrice(cart)}
              `
          }
       ```
        - 아쉬운 점 & 개선 방향
            - isValidateItem을 유효한 한 곳에서 사용하는 게 아닌 여러 곳에서 많이 사용 하고 있다.
            - 입력 폼 등에서 값을 검증하는 모든 곳에서 이것과 비슷하게 매번 validation 관련 코드를 작성한 경험이 존재한다.
            - for, if 등의 구문을 사용 할 때와 비슷하게 판에 박힌 코드를 반복하는 경향이 존재한다.
            - 판에 박힌 코드를 반복해야만 할까?
            - 값이 올바른지를 매번 검사가 아닌 한 번에 검사하면 안될까?
            - validateItem은 단순히 정보의 유효성만 검사할 뿐, 검증이 완료되었음을 프로그램 전체에 전파시키기는 어렵다.
            - validation을 사용해서 값의 유효성만 판단하는 것 뿐 아니라, 임의의 데이터를 구체적인 데이터로 변환하는 과정인 파싱을 사용한다면 이러한 문제를 일부 해결할 수 있다. 
            - JSON.parse 함수는 대표적인 파싱 함수이다. 이 함수는 임의의 문자열을 구체적인 오브젝트 객체로 변환하고, 만일 임의의 문자열이 규칙에 맞지 않으면 throw를 뱉는다.
            - 예제에서 사용하는 item이라는 타입도 파싱 함수를 만들고 Try 타입을 통해 성공과 실패를 다룬다면, 코드의 반복을 제거하면서 문제를 해결 할 수 있을 것이다. 

 - 예제 2 - 1 / Type 도입 / Try Type 추가
     - 개선 방향
        - 함수가 필요할 때 함수의 타입을 고민 할 때, 타입이 우리가 무엇을 하는 지 안내해준다.
        - Type을 도입한다면 validateItem은 어떤 타입이 되어야 할까?
        - validatieItem 함수가 검증해야 하는 부분은 Item 타입의 값이다.
        - return type은, parsing은 실패할 수도 있는 값이므로 Try 타입을 리턴 해야 한다.
     - ```
          export interface Item {
              readonly code: string;
              readonly outOfStock: boolean;
              readonly name: string;
              readonly price: number;
              readonly quantity: number;
              readonly discountPrice?: number;
          }

          import * as T from './try

          // 코드 추가
          // 인터섹션 타입 사용해서 기존 item 타입을 확장한다.
          type ParsedItem = { _tag: "parsedItem"} & item;

          // 코드 추가
          type ParseError = {
              name: string;
              message: string;
          }

          // 코드 변경!
          // 함수명을 validateItem이 아닌 parseItem으로 변경
          const parseItem = (item: Item): T.Try<ParseItem, ParseError> => {
              if (item.quantity <1) {
                return T.failed({
                    name: item.name,
                    message: "상품은 반드시 한 개 이상 담아야 합니다";
                })
              } else if(item.quantity > 10) {
                return T.failed({
                    name: item.name,
                    message: "한 번에 10개를 초과하여 구매할 수 없습니다.";
                }) 
              }

              result T.success({
                  _tag: 'parsedItem',
                  ...item
              })
             
          }

          type ArrayItem = ArrayItem;
          


          export const cart :ArrayItem = [
              {
                  code : 'tomato,
                  outOfStock: false,
                  name: '토마토',
                  price: 7000,
                  quantity: 2,
                  discountPrice: 1000
              },
              ... 생략

          {
                  code : 'orange,
                  outOfStock: false,
                  name: '오렌지',
                  price: 15000,
                  quantity: 3,
                  discountPrice: 2000
              },
          ]

          import {cart, Item} from './cart';
          import * as O from './option'


          const stockItem = (item:Item): string => {
               return `
                  <li>
                      <h2>${item.name}</h2>
                      <div>가격: ${item.price - discountPrice}원 ${saleText}</div>
                      <div>수량: ${item.quantity} 상자</div>
                  </li>
              `;
          }

          const outOfStockItem = (item:Item): string => {
              return `
                  <li class="gray">
                      <h2>${item.name} (품절)</h2>
                      <div class="strike">가격: ${item.price}원 (XX원 할인)</div>
                      <div class="strike">수량: ${item.quantity}상자</div>
                  </li>
              `
          }

          const item = (item: Item) : string => {
              Try {
                validateItem(item);
                if(item.outOfStock) {
                    return outOfStockItem(item);
                } else {
                    return stockItem(item);
                }
              } catch (e) {
                return `<li style="color:red"> 
                    <h2>
                        ${item.name}
                    </h2>
                    <div>
                        ${e}
                    </div>
                </li>`
              }
          }

          const totalCalculator = (list: ArrayItem, getValue: (item: Item) => number) : number {
              return list
                .filter((item) => {
                    Try {
                       validateItem(item);
                       return item.outOfStock === false;
                    } catch (e) {
                       // 상품 수량에서 재외 처리를 한다.
                       return false; 
                    }
                    
                })
                .map(getValue)
                .reduce((total, value) => total + value, 0);
          }

          const totalCount = (list:ArrayItem): string => {
              const totalCount = totalCalculator(list, (item)=> item.quantity);

              return `<h2>전체 가격 : ${totalCount} </h2>`;
          }

          const totalPrice = (list: ArrayItem) : string => {
                  const totalPrice = totalCalculator(list, (item)=> item.price * item.quantity);
              
                  
                  const totalDiscountPrice = totalCalculator(list, (item)=> {
                      let discountPrice = O.getOrElse(O.fromUndefined(item.discountPrice));

                      return discountPrice * item.quantity;
                  })

                  return `<h2>전체 가격: ${totalPrice - totalDiscountPrice}원 (총 ${totalDiscountPrice}원 할인)</h2>`;
              }

          const list = (list: ArrayItem) => {
              let html =""

              for(let i = 0; i < list.length ; i++>) {
                  html += item(cart[i]);
              }

              return `
                  <ul>
                      ${html}
                  </ul>
              `
          }

          const app = document.getElementById('app');
          if(app != null) {
              app.innerHTML = `
                  <h1> 장바구니 </h1>
                  ${list(cart)}
                  ${totalCount(cart)}
                  ${totalPrice(cart)}
              `
          }
       ```

- 예제 2 - 2 / Type 도입 / Try Type을 통한 분기문 처리 
     - ```
          export interface Item {
              readonly code: string;
              readonly outOfStock: boolean;
              readonly name: string;
              readonly price: number;
              readonly quantity: number;
              readonly discountPrice?: number;
          }

          import * as T from './try

          type ParsedItem = { _tag: "parsedItem"} & item;

          type ParseError = {
              name: string;
              message: string;
          }

          const parseItem = (item: Item): T.Try<ParseItem, ParseError> => {
              if (item.quantity <1) {
                return T.failed({
                    name: item.name,
                    message: "상품은 반드시 한 개 이상 담아야 합니다";
                })
              } else if(item.quantity > 10) {
                return T.failed({
                    name: item.name,
                    message: "한 번에 10개를 초과하여 구매할 수 없습니다.";
                }) 
              }

              result T.success({
                  _tag: 'parsedItem',
                  ...item
              })
             
          }

          type ArrayItem = ArrayItem;
          
          export const cart :ArrayItem = [
              {
                  code : 'tomato,
                  outOfStock: false,
                  name: '토마토',
                  price: 7000,
                  quantity: 2,
                  discountPrice: 1000
              },
              ... 생략

          {
                  code : 'orange,
                  outOfStock: false,
                  name: '오렌지',
                  price: 15000,
                  quantity: 3,
                  discountPrice: 2000
              },
          ]

          import {cart, Item} from './cart';
          import * as O from './option'


        // 코드 변경!
        // 함수 인자 타입 변경함
        const stockItem = (item: ParsedItem): string => {
              return `
                  <li>
                      <h2>${item.name}</h2>
                      <div>가격: ${item.price - discountPrice}원 ${saleText}</div>
                      <div>수량: ${item.quantity} 상자</div>
                  </li>
              `;
          }

          // 코드 변경!
          // 함수 인자 타입 변경함
          const outOfStockItem = (item: ParsedItem): string => {
              return `
                  <li class="gray">
                      <h2>${item.name} (품절)</h2>
                      <div class="strike">가격: ${item.price}원 (XX원 할인)</div>
                      <div class="strike">수량: ${item.quantity}상자</div>
                  </li>
              `
          }

          // 코드 변경!
          const item = (item: Item) : string => {
              Try {
                // parseItem의 반환값은 Try 타입이다.
                // parsedItem을 outOfStockItem과 stockItem에 직접 넘기지 못한다.
                // 어떻게 이 문제를 해결 할 수 있을까?
                // Try의 map을 통해 해결이 가능하다.
                // 이전 Option에제에서는 Option에서는 값이 존재할 때만 어떤 계산을 실행하기 위해서 map을 사용해왔다.
                // Try에서의 map은 어떤 동작을 해야 할까?
                // Try의 map은 실패했을 때는 인자를 그대로 리턴하고, 성공일 때만 인자로 전달된 함수를 자신의 데이터에 적용하고 결과를 리턴하면 된다.
                // 이 과정에서 성공과 실패의 여부에 영향을 주어서는 안된다.
                // 자세히 말하자면, 구조가 보존되면서 성공과 실패를 반환한다.
                const parsedItem = parseItem(item);
                if(item.outOfStock) {
                    return outOfStockItem(item);
                } else {
                    return stockItem(item);
                }
              } catch (e) {
                return `<li style="color:red"> 
                    <h2>
                        ${item.name}
                    </h2>
                    <div>
                        ${e}
                    </div>
                </li>`
              }
          }

          const totalCalculator = (list: ArrayItem, getValue: (item: Item) => number) : number {
              return list
                .filter((item) => {
                    Try {
                       validateItem(item);
                       return item.outOfStock === false;
                    } catch (e) {
                       // 상품 수량에서 재외 처리를 한다.
                       return false; 
                    }
                    
                })
                .map(getValue)
                .reduce((total, value) => total + value, 0);
          }

          const totalCount = (list:ArrayItem): string => {
              const totalCount = totalCalculator(list, (item)=> item.quantity);

              return `<h2>전체 가격 : ${totalCount} </h2>`;
          }

          const totalPrice = (list: ArrayItem) : string => {
                  const totalPrice = totalCalculator(list, (item)=> item.price * item.quantity);
              
                  
                  const totalDiscountPrice = totalCalculator(list, (item)=> {
                      let discountPrice = O.getOrElse(O.fromUndefined(item.discountPrice));

                      return discountPrice * item.quantity;
                  })

                  return `<h2>전체 가격: ${totalPrice - totalDiscountPrice}원 (총 ${totalDiscountPrice}원 할인)</h2>`;
              }

          const list = (list: ArrayItem) => {
              let html =""

              for(let i = 0; i < list.length ; i++>) {
                  html += item(cart[i]);
              }

              return `
                  <ul>
                      ${html}
                  </ul>
              `
          }

          const app = document.getElementById('app');
          if(app != null) {
              app.innerHTML = `
                  <h1> 장바구니 </h1>
                  ${list(cart)}
                  ${totalCount(cart)}
                  ${totalPrice(cart)}
              `
          }
       ```
        - item 함수 고찰 & 개선 방향
           - parseItem의 반환값은 Try 타입이다.
           - parsedItem을 outOfStockItem과 stockItem에 직접 넘기지 못한다.
           - 어떻게 이 문제를 해결 할 수 있을까?
           - Try의 map을 통해 해결이 가능하다.
           - 이전 Option에제에서는 Option에서는 값이 존재할 때만 어떤 계산을 실행하기 위해서 map을 사용해왔다.
           - Try에서의 map은 어떤 동작을 해야 할까?
           - Try의 map은 실패했을 때는 인자를 그대로 리턴하고, 성공일 때만 인자로 전달된 함수를 자신의 데이터에 적용하고 결과를 리턴하면 된다.
           - 이 과정에서 성공과 실패의 여부에 영향을 주어서는 안된다.
           - 자세히 말하자면, 구조가 보존되면서 성공과 실패를 반환한다.

- 예제 2 - 3 / Type 도입 / Try Type을 통한 분기문 처리 / Try의 map 함수 추가
    - Try의 map
        - Option의 map과 거의 다르지 않다.
        - 한 가지 주의점은 성공에 대한 결과의 타입은 인자로 주어진 함수에 의해 변경 될 수 있지만, 에러의 타입은 변경되지 않는다.
     - ```
          export interface Item {
              readonly code: string;
              readonly outOfStock: boolean;
              readonly name: string;
              readonly price: number;
              readonly quantity: number;
              readonly discountPrice?: number;
          }

          import * as T from './try

          type ParsedItem = { _tag: "parsedItem"} & item;

          type ParseError = {
              name: string;
              message: string;
          }

          // 코드 추가!
          // try의 map
          export const map = <E, A, B>(ta: Try<E, A>, f: (a: A)=> B): Try<E, B> => {
              if (isFailed(ta)) return ta;
              return success(f(ta.result));
          }

          const parseItem = (item: Item): T.Try<ParseItem, ParseError> => {
              if (item.quantity <1) {
                return T.failed({
                    name: item.name,
                    message: "상품은 반드시 한 개 이상 담아야 합니다";
                })
              } else if(item.quantity > 10) {
                return T.failed({
                    name: item.name,
                    message: "한 번에 10개를 초과하여 구매할 수 없습니다.";
                }) 
              }

              result T.success({
                  _tag: 'parsedItem',
                  ...item
              })
             
          }

          type ArrayItem = ArrayItem;
          
          export const cart :ArrayItem = [
              {
                  code : 'tomato,
                  outOfStock: false,
                  name: '토마토',
                  price: 7000,
                  quantity: 2,
                  discountPrice: 1000
              },
              ... 생략

          {
                  code : 'orange,
                  outOfStock: false,
                  name: '오렌지',
                  price: 15000,
                  quantity: 3,
                  discountPrice: 2000
              },
          ]

          import {cart, Item} from './cart';
          import * as O from './option'

          const stockItem = (item: ParsedItem): string => {
              return `
                  <li>
                      <h2>${item.name}</h2>
                      <div>가격: ${item.price - discountPrice}원 ${saleText}</div>
                      <div>수량: ${item.quantity} 상자</div>
                  </li>
              `;
          }

          const outOfStockItem = (item: ParsedItem): string => {
              return `
                  <li class="gray">
                      <h2>${item.name} (품절)</h2>
                      <div class="strike">가격: ${item.price}원 (XX원 할인)</div>
                      <div class="strike">수량: ${item.quantity}상자</div>
                  </li>
              `
          }

          const item = (item: Item) : string => {
              Try {
                const parsedItem = parseItem(item);
                if(item.outOfStock) {
                    return outOfStockItem(item);
                } else {
                    return stockItem(item);
                }
              } catch (e) {
                return `<li style="color:red"> 
                    <h2>
                        ${item.name}
                    </h2>
                    <div>
                        ${e}
                    </div>
                </li>`
              }
          }

          const totalCalculator = (list: ArrayItem, getValue: (item: Item) => number) : number {
              return list
                .filter((item) => {
                    Try {
                       validateItem(item);
                       return item.outOfStock === false;
                    } catch (e) {
                       // 상품 수량에서 재외 처리를 한다.
                       return false; 
                    }
                    
                })
                .map(getValue)
                .reduce((total, value) => total + value, 0);
          }

          const totalCount = (list:ArrayItem): string => {
              const totalCount = totalCalculator(list, (item)=> item.quantity);

              return `<h2>전체 가격 : ${totalCount} </h2>`;
          }

          const totalPrice = (list: ArrayItem) : string => {
                  const totalPrice = totalCalculator(list, (item)=> item.price * item.quantity);
              
                  
                  const totalDiscountPrice = totalCalculator(list, (item)=> {
                      let discountPrice = O.getOrElse(O.fromUndefined(item.discountPrice));

                      return discountPrice * item.quantity;
                  })

                  return `<h2>전체 가격: ${totalPrice - totalDiscountPrice}원 (총 ${totalDiscountPrice}원 할인)</h2>`;
              }

          const list = (list: ArrayItem) => {
              let html =""

              for(let i = 0; i < list.length ; i++>) {
                  html += item(cart[i]);
              }

              return `
                  <ul>
                      ${html}
                  </ul>
              `
          }

          const app = document.getElementById('app');
          if(app != null) {
              app.innerHTML = `
                  <h1> 장바구니 </h1>
                  ${list(cart)}
                  ${totalCount(cart)}
                  ${totalPrice(cart)}
              `
          }
       ```

- 예제 2 - 4 / Type 도입 / Try Type을 통한 분기문 처리 / Try의 map 함수 적용
    - Try의 map
        - Option의 map과 거의 다르지 않다.
        - 한 가지 주의점은 성공에 대한 결과의 타입은 인자로 주어진 함수에 의해 변경 될 수 있지만, 에러의 타입은 변경되지 않는다.
     - ```
          export interface Item {
              readonly code: string;
              readonly outOfStock: boolean;
              readonly name: string;
              readonly price: number;
              readonly quantity: number;
              readonly discountPrice?: number;
          }

          import * as T from './try

          type ParsedItem = { _tag: "parsedItem"} & item;

          type ParseError = {
              name: string;
              message: string;
          }

          // map of try
          export const map = <E, A, B>(ta: Try<E, A>, f: (a: A)=> B): Try<E, B> => {
              if (isFailed(ta)) return ta;
              return success(f(ta.result));
          }

          const parseItem = (item: Item): T.Try<ParseItem, ParseError> => {
              if (item.quantity <1) {
                return T.failed({
                    name: item.name,
                    message: "상품은 반드시 한 개 이상 담아야 합니다";
                })
              } else if(item.quantity > 10) {
                return T.failed({
                    name: item.name,
                    message: "한 번에 10개를 초과하여 구매할 수 없습니다.";
                }) 
              }

              result T.success({
                  _tag: 'parsedItem',
                  ...item
              })
             
          }

          type ArrayItem = ArrayItem;
          
          export const cart :ArrayItem = [
              {
                  code : 'tomato,
                  outOfStock: false,
                  name: '토마토',
                  price: 7000,
                  quantity: 2,
                  discountPrice: 1000
              },
              ... 생략

          {
                  code : 'orange,
                  outOfStock: false,
                  name: '오렌지',
                  price: 15000,
                  quantity: 3,
                  discountPrice: 2000
              },
          ]

          import {cart, Item} from './cart';
          import * as O from './option'

          const stockItem = (item: ParsedItem): string => {
              return `
                  <li>
                      <h2>${item.name}</h2>
                      <div>가격: ${item.price - discountPrice}원 ${saleText}</div>
                      <div>수량: ${item.quantity} 상자</div>
                  </li>
              `;
          }

          const outOfStockItem = (item: ParsedItem): string => {
              return `
                  <li class="gray">
                      <h2>${item.name} (품절)</h2>
                      <div class="strike">가격: ${item.price}원 (XX원 할인)</div>
                      <div class="strike">수량: ${item.quantity}상자</div>
                  </li>
              `
          }

          // 코드 변경!
          // 의문
          //    - 만일 parsing에 실패했을 경우 어떻게 해야 할까?
          const item = (item: Item) : string => {
              Try {
                const parsedItem = parseItem(item);
                const render = T.map(parsedItem, (item) => {
                    if(item.outOfStock) {
                        return outOfStockItem(item);
                    } else {
                        return stockItem(item);
                    }
                });
              } catch (e) {
                return `<li style="color:red"> 
                    <h2>
                        ${item.name}
                    </h2>
                    <div>
                        ${e}
                    </div>
                </li>`
              }
          }

          const totalCalculator = (list: ArrayItem, getValue: (item: Item) => number) : number {
              return list
                .filter((item) => {
                    Try {
                       validateItem(item);
                       return item.outOfStock === false;
                    } catch (e) {
                       // 상품 수량에서 재외 처리를 한다.
                       return false; 
                    }
                    
                })
                .map(getValue)
                .reduce((total, value) => total + value, 0);
          }

          const totalCount = (list:ArrayItem): string => {
              const totalCount = totalCalculator(list, (item)=> item.quantity);

              return `<h2>전체 가격 : ${totalCount} </h2>`;
          }

          const totalPrice = (list: ArrayItem) : string => {
                  const totalPrice = totalCalculator(list, (item)=> item.price * item.quantity);
              
                  
                  const totalDiscountPrice = totalCalculator(list, (item)=> {
                      let discountPrice = O.getOrElse(O.fromUndefined(item.discountPrice));

                      return discountPrice * item.quantity;
                  })

                  return `<h2>전체 가격: ${totalPrice - totalDiscountPrice}원 (총 ${totalDiscountPrice}원 할인)</h2>`;
              }

          const list = (list: ArrayItem) => {
              let html =""

              for(let i = 0; i < list.length ; i++>) {
                  html += item(cart[i]);
              }

              return `
                  <ul>
                      ${html}
                  </ul>
              `
          }

          const app = document.getElementById('app');
          if(app != null) {
              app.innerHTML = `
                  <h1> 장바구니 </h1>
                  ${list(cart)}
                  ${totalCount(cart)}
                  ${totalPrice(cart)}
              `
          }
       ```

- 예제 2 - 5 / Type 도입 / Try Type을 통한 분기문 처리 / Try의 map 함수 적용2
    - Try의 map
        - Option의 map과 거의 다르지 않다.
        - 한 가지 주의점은 성공에 대한 결과의 타입은 인자로 주어진 함수에 의해 변경 될 수 있지만, 에러의 타입은 변경되지 않는다.
     - ```
          export interface Item {
              readonly code: string;
              readonly outOfStock: boolean;
              readonly name: string;
              readonly price: number;
              readonly quantity: number;
              readonly discountPrice?: number;
          }

          import * as T from './try

          type ParsedItem = { _tag: "parsedItem"} & item;

          type ParseError = {
              name: string;
              message: string;
          }

          // map of try
          export const map = <E, A, B>(ta: Try<E, A>, f: (a: A)=> B): Try<E, B> => {
              if (isFailed(ta)) return ta;
              return success(f(ta.result));
          }

          const parseItem = (item: Item): T.Try<ParseItem, ParseError> => {
              if (item.quantity <1) {
                return T.failed({
                    name: item.name,
                    message: "상품은 반드시 한 개 이상 담아야 합니다";
                })
              } else if(item.quantity > 10) {
                return T.failed({
                    name: item.name,
                    message: "한 번에 10개를 초과하여 구매할 수 없습니다.";
                }) 
              }

              result T.success({
                  _tag: 'parsedItem',
                  ...item
              })
             
          }

          type ArrayItem = ArrayItem;
          
          export const cart :ArrayItem = [
              {
                  code : 'tomato,
                  outOfStock: false,
                  name: '토마토',
                  price: 7000,
                  quantity: 2,
                  discountPrice: 1000
              },
              ... 생략

          {
                  code : 'orange,
                  outOfStock: false,
                  name: '오렌지',
                  price: 15000,
                  quantity: 3,
                  discountPrice: 2000
              },
          ]

          import {cart, Item} from './cart';
          import * as O from './option'

          const stockItem = (item: ParsedItem): string => {
              return `
                  <li>
                      <h2>${item.name}</h2>
                      <div>가격: ${item.price - discountPrice}원 ${saleText}</div>
                      <div>수량: ${item.quantity} 상자</div>
                  </li>
              `;
          }

          const outOfStockItem = (item: ParsedItem): string => {
              return `
                  <li class="gray">
                      <h2>${item.name} (품절)</h2>
                      <div class="strike">가격: ${item.price}원 (XX원 할인)</div>
                      <div class="strike">수량: ${item.quantity}상자</div>
                  </li>
              `
          }

          // 코드 변경!
          // 개선 방향
          //    parseItem의 실패에 대한 에러 타입을 가질 수 있다.
          //    parseError 타입을 출력하는 html을 리턴하는 함수를 만든다.
          const item = (item: Item) : string => {
              Try {
                const parsedItem = parseItem(item);
                const render = T.map(parsedItem, (item) => {
                    if(item.outOfStock) {
                        return outOfStockItem(item);
                    } else {
                        return stockItem(item);
                    }
                });
              } catch (e) {
                return `<li style="color:red"> 
                    <h2>
                        ${item.name}
                    </h2>
                    <div>
                        ${e}
                    </div>
                </li>`
              }
          }

          const totalCalculator = (list: ArrayItem, getValue: (item: Item) => number) : number {
              return list
                .filter((item) => {
                    Try {
                       validateItem(item);
                       return item.outOfStock === false;
                    } catch (e) {
                       // 상품 수량에서 재외 처리를 한다.
                       return false; 
                    }
                    
                })
                .map(getValue)
                .reduce((total, value) => total + value, 0);
          }

          const totalCount = (list:ArrayItem): string => {
              const totalCount = totalCalculator(list, (item)=> item.quantity);

              return `<h2>전체 가격 : ${totalCount} </h2>`;
          }

          const totalPrice = (list: ArrayItem) : string => {
                  const totalPrice = totalCalculator(list, (item)=> item.price * item.quantity);
              
                  
                  const totalDiscountPrice = totalCalculator(list, (item)=> {
                      let discountPrice = O.getOrElse(O.fromUndefined(item.discountPrice));

                      return discountPrice * item.quantity;
                  })

                  return `<h2>전체 가격: ${totalPrice - totalDiscountPrice}원 (총 ${totalDiscountPrice}원 할인)</h2>`;
              }

          const list = (list: ArrayItem) => {
              let html =""

              for(let i = 0; i < list.length ; i++>) {
                  html += item(cart[i]);
              }

              return `
                  <ul>
                      ${html}
                  </ul>
              `
          }

          const app = document.getElementById('app');
          if(app != null) {
              app.innerHTML = `
                  <h1> 장바구니 </h1>
                  ${list(cart)}
                  ${totalCount(cart)}
                  ${totalPrice(cart)}
              `
          }
       ```

- 예제 2 - 6 / Type 도입 / Try Type을 통한 분기문 처리 / Try의 map 함수 적용3
    - Try의 map
        - Option의 map과 거의 다르지 않다.
        - 한 가지 주의점은 성공에 대한 결과의 타입은 인자로 주어진 함수에 의해 변경 될 수 있지만, 에러의 타입은 변경되지 않는다.
     - ```
          export interface Item {
              readonly code: string;
              readonly outOfStock: boolean;
              readonly name: string;
              readonly price: number;
              readonly quantity: number;
              readonly discountPrice?: number;
          }

          import * as T from './try

          type ParsedItem = { _tag: "parsedItem"} & item;

          type ParseError = {
              name: string;
              message: string;
          }

          // map of try
          export const map = <E, A, B>(ta: Try<E, A>, f: (a: A)=> B): Try<E, B> => {
              if (isFailed(ta)) return ta;
              return success(f(ta.result));
          }

          const parseItem = (item: Item): T.Try<ParseItem, ParseError> => {
              if (item.quantity <1) {
                return T.failed({
                    name: item.name,
                    message: "상품은 반드시 한 개 이상 담아야 합니다";
                })
              } else if(item.quantity > 10) {
                return T.failed({
                    name: item.name,
                    message: "한 번에 10개를 초과하여 구매할 수 없습니다.";
                }) 
              }

              result T.success({
                  _tag: 'parsedItem',
                  ...item
              })
             
          }

          type ArrayItem = ArrayItem;
          
          export const cart :ArrayItem = [
              {
                  code : 'tomato,
                  outOfStock: false,
                  name: '토마토',
                  price: 7000,
                  quantity: 2,
                  discountPrice: 1000
              },
              ... 생략

          {
                  code : 'orange,
                  outOfStock: false,
                  name: '오렌지',
                  price: 15000,
                  quantity: 3,
                  discountPrice: 2000
              },
          ]

          import {cart, Item} from './cart';
          import * as O from './option'

          const stockItem = (item: ParsedItem): string => {
              return `
                  <li>
                      <h2>${item.name}</h2>
                      <div>가격: ${item.price - discountPrice}원 ${saleText}</div>
                      <div>수량: ${item.quantity} 상자</div>
                  </li>
              `;
          }

          const outOfStockItem = (item: ParsedItem): string => {
              return `
                  <li class="gray">
                      <h2>${item.name} (품절)</h2>
                      <div class="strike">가격: ${item.price}원 (XX원 할인)</div>
                      <div class="strike">수량: ${item.quantity}상자</div>
                  </li>
              `
          }

          // 코드 추가!
          const errorItem = (e: ParseError): string => {
              return `<li style="color:red"> 
                    <h2>
                        ${e.name}
                    </h2>
                    <div>
                        ${e.message}
                    </div>
                </li>`
          }


          // 코드 변경!
          const item = (item: Item) : string => {
                const parsedItem = parseItem(item);
                const render = T.map(parsedItem, (item) => {
                    if(item.outOfStock) {
                        return outOfStockItem(item);
                    } else {
                        return stockItem(item);
                    }
                });

                // Try - catch 대체
                return T.getOrElse(render, errorItem); 
          }

          const totalCalculator = (list: ArrayItem, getValue: (item: Item) => number) : number {
              return list
                .filter((item) => {
                    Try {
                       validateItem(item);
                       return item.outOfStock === false;
                    } catch (e) {
                       // 상품 수량에서 재외 처리를 한다.
                       return false; 
                    }
                    
                })
                .map(getValue)
                .reduce((total, value) => total + value, 0);
          }

          const totalCount = (list:ArrayItem): string => {
              const totalCount = totalCalculator(list, (item)=> item.quantity);

              return `<h2>전체 가격 : ${totalCount} </h2>`;
          }

          const totalPrice = (list: ArrayItem) : string => {
                  const totalPrice = totalCalculator(list, (item)=> item.price * item.quantity);
              
                  
                  const totalDiscountPrice = totalCalculator(list, (item)=> {
                      let discountPrice = O.getOrElse(O.fromUndefined(item.discountPrice));

                      return discountPrice * item.quantity;
                  })

                  return `<h2>전체 가격: ${totalPrice - totalDiscountPrice}원 (총 ${totalDiscountPrice}원 할인)</h2>`;
              }

          const list = (list: ArrayItem) => {
              let html =""

              for(let i = 0; i < list.length ; i++>) {
                  html += item(cart[i]);
              }

              return `
                  <ul>
                      ${html}
                  </ul>
              `
          }

          const app = document.getElementById('app');
          if(app != null) {
              app.innerHTML = `
                  <h1> 장바구니 </h1>
                  ${list(cart)}
                  ${totalCount(cart)}
                  ${totalPrice(cart)}
              `
          }
       ```
- 예제 2 - 7 / Type 도입 / Try Type을 통한 분기문 처리 / Try의 map 함수 적용4
    - Try의 map
        - Option의 map과 거의 다르지 않다.
        - 한 가지 주의점은 성공에 대한 결과의 타입은 인자로 주어진 함수에 의해 변경 될 수 있지만, 에러의 타입은 변경되지 않는다.
     - ```
          export interface Item {
              readonly code: string;
              readonly outOfStock: boolean;
              readonly name: string;
              readonly price: number;
              readonly quantity: number;
              readonly discountPrice?: number;
          }

          import * as T from './try

          type ParsedItem = { _tag: "parsedItem"} & item;

          type ParseError = {
              name: string;
              message: string;
          }

          // map of try
          export const map = <E, A, B>(ta: Try<E, A>, f: (a: A)=> B): Try<E, B> => {
              if (isFailed(ta)) return ta;
              return success(f(ta.result));
          }

          const parseItem = (item: Item): T.Try<ParseItem, ParseError> => {
              if (item.quantity <1) {
                return T.failed({
                    name: item.name,
                    message: "상품은 반드시 한 개 이상 담아야 합니다";
                })
              } else if(item.quantity > 10) {
                return T.failed({
                    name: item.name,
                    message: "한 번에 10개를 초과하여 구매할 수 없습니다.";
                }) 
              }

              result T.success({
                  _tag: 'parsedItem',
                  ...item
              })
             
          }

          type ArrayItem = ArrayItem;
          
          export const cart :ArrayItem = [
              {
                  code : 'tomato,
                  outOfStock: false,
                  name: '토마토',
                  price: 7000,
                  quantity: 2,
                  discountPrice: 1000
              },
              ... 생략

          {
                  code : 'orange,
                  outOfStock: false,
                  name: '오렌지',
                  price: 15000,
                  quantity: 3,
                  discountPrice: 2000
              },
          ]

          import {cart, Item} from './cart';
          import * as O from './option'

          const stockItem = (item: ParsedItem): string => {
              return `
                  <li>
                      <h2>${item.name}</h2>
                      <div>가격: ${item.price - discountPrice}원 ${saleText}</div>
                      <div>수량: ${item.quantity} 상자</div>
                  </li>
              `;
          }

          const outOfStockItem = (item: ParsedItem): string => {
              return `
                  <li class="gray">
                      <h2>${item.name} (품절)</h2>
                      <div class="strike">가격: ${item.price}원 (XX원 할인)</div>
                      <div class="strike">수량: ${item.quantity}상자</div>
                  </li>
              `
          }

          const errorItem = (e: ParseError): string => {
              return `<li style="color:red"> 
                    <h2>
                        ${e.name}
                    </h2>
                    <div>
                        ${e.message}
                    </div>
                </li>`
          }

          const item = (item: Item) : string => {
                const parsedItem = parseItem(item);
                const render = T.map(parsedItem, (item) => {
                    if(item.outOfStock) {
                        return outOfStockItem(item);
                    } else {
                        return stockItem(item);
                    }
                });

                // Try - catch 대체
                return T.getOrElse(render, errorItem); 
          }

          // 코드 변경!
          //       아직 코드를 작동되게 변경한 것은 아니다.
          //       이유는 parseItem은 error를 throw 하지못하므로 catch문을 작동 시키지 못한다.
          //       parseItem를 통해 이전에 적용된 parseItem를 다시 한번 더 반복해야 하는지 의문이 들 수 있다.
          //       다음 섹션에서 이 의문을 해결하자.
          const totalCalculator = (list: ArrayItem, getValue: (item: Item) => number) : number {
              return list
                .filter((item) => {
                    Try {
                       parseItem(item);
                       return item.outOfStock === false;
                    } catch (e) {
                       // 상품 수량에서 재외 처리를 한다.
                       return false; 
                    }
                    
                })
                .map(getValue)
                .reduce((total, value) => total + value, 0);
          }

          const totalCount = (list:ArrayItem): string => {
              const totalCount = totalCalculator(list, (item)=> item.quantity);

              return `<h2>전체 가격 : ${totalCount} </h2>`;
          }

          const totalPrice = (list: ArrayItem) : string => {
                  const totalPrice = totalCalculator(list, (item)=> item.price * item.quantity);
              
                  
                  const totalDiscountPrice = totalCalculator(list, (item)=> {
                      let discountPrice = O.getOrElse(O.fromUndefined(item.discountPrice));

                      return discountPrice * item.quantity;
                  })

                  return `<h2>전체 가격: ${totalPrice - totalDiscountPrice}원 (총 ${totalDiscountPrice}원 할인)</h2>`;
              }

          const list = (list: ArrayItem) => {
              let html =""

              for(let i = 0; i < list.length ; i++>) {
                  html += item(cart[i]);
              }

              return `
                  <ul>
                      ${html}
                  </ul>
              `
          }

          const app = document.getElementById('app');
          if(app != null) {
              app.innerHTML = `
                  <h1> 장바구니 </h1>
                  ${list(cart)}
                  ${totalCount(cart)}
                  ${totalPrice(cart)}
              `
          }
       ```
        - item 함수에서도 parseItem이 쓰이고, totalCalucator에서도 parseItem이 중복되어 쓰이고 있다. 
        - 이 중복을 제거하는 방법은 다음 섹션에서 다루도록 한다.
  
## Try Type을 이용한 try-catch와 Try 타입의 트레이드 오프 판단2
- 목적
  - 이전 섹션에서는 item 함수에서 parseItem을 하고 있는데, 이는 같은 레벨(?)의 함수인 totalCalulator에서도 parseItem를 사용하게 하는 반복의 문제가 존재헀다.
  - 이를 해결해보도록 한다.
- 베이스 예제 1
    - ```
        type Success<R> = {
            readonly _tag : "success",
            readonly result : R
        }; 

        type Failed<E> = {
            readonly _tag : "failed",
            readonly error : E
        }; 

        export type Try<E, R> = Failed<E> | Success<R>; 

        export const success = <R>(result: R): Try<never, R> => ({
            _tag: 'success',
            result
        })
        
        export const failed = <E>(error: E): Try<E, never> => ({
            _tag: 'failed',
            error,
        })

        export const isSuccess = <R>(ta: Try<unknown, R>): ta is Success<R> => ta._tag ==="success";
        export const isFailed = <E>(ta: Try<E, unknown>): ta is Failed<E> => ta._tag ==='failed'; 

        export const getOrElse = <R>(ta: Try<unknown, R>, defaultValue: (e: E)=> R): R => {
        if(isFailed(ta)) return defaultValue(ta.error);              

        return ta.result;
        }
      ```
 - 예제 1 - 1  
   - ```
        type Success<R> = {
            readonly _tag : "success",
            readonly result : R
        }; 

        type Failed<E> = {
            readonly _tag : "failed",
            readonly error : E
        }; 

        export type Try<E, R> = Failed<E> | Success<R>; 

        export const success = <R>(result: R): Try<never, R> => ({
            _tag: 'success',
            result
        })
        
        export const failed = <E>(error: E): Try<E, never> => ({
            _tag: 'failed',
            error,
        })

        export const isSuccess = <R>(ta: Try<unknown, R>): ta is Success<R> => ta._tag ==="success";
        export const isFailed = <E>(ta: Try<E, unknown>): ta is Failed<E> => ta._tag ==='failed'; 

        export const getOrElse = <R>(ta: Try<unknown, R>, defaultValue: (e: E)=> R): R => {
            if(isFailed(ta)) return defaultValue(ta.error);              

            return ta.result;
        }

        export const map = <E, A, B>(ta: Try<E, A>, f: (a: A)=> B): Try<E, B> => {
            if (isFailed(ta)) return ta;
            return success(f(ta.result));
        }

        // Array<T, Try<ParsedError, ParsedItem>> => Array<ParsedItem>
        export const KeepSuccess = (tas: Array<T, Try<ParsedError, ParsedItem>>) : Array<ParsedItem> => {
            
        })

     ```
- 예제 1 - 2
   - ```
        type Success<R> = {
            readonly _tag : "success",
            readonly result : R
        }; 

        type Failed<E> = {
            readonly _tag : "failed",
            readonly error : E
        }; 

        export type Try<E, R> = Failed<E> | Success<R>; 

        export const success = <R>(result: R): Try<never, R> => ({
            _tag: 'success',
            result
        })
        
        export const failed = <E>(error: E): Try<E, never> => ({
            _tag: 'failed',
            error,
        })

        export const isSuccess = <R>(ta: Try<unknown, R>): ta is Success<R> => ta._tag ==="success";
        export const isFailed = <E>(ta: Try<E, unknown>): ta is Failed<E> => ta._tag ==='failed'; 

        export const getOrElse = <R>(ta: Try<unknown, R>, defaultValue: (e: E)=> R): R => {
            if(isFailed(ta)) return defaultValue(ta.error);              

            return ta.result;
        }

        export const map = <E, A, B>(ta: Try<E, A>, f: (a: A)=> B): Try<E, B> => {
            if (isFailed(ta)) return ta;
            return success(f(ta.result));
        }

        // 코드 변경!
        // (매우 중요) KeepSuccess는 특정 타입에서만 동작하는 함수가 아니므로, Error의 타입과 Success의 타입을 제네릭으로 만든다.
        export const KeepSuccess = <E, R>(tas: Array<T, R>>) : Array<R> => {
            const ret = tas.map((ta)=> {
                // 타입스크립트 타입 에러 발생 이유 
                // 함수 타입이 배열을 배열로 변경하고 있다.
                // 만약 else 구문을 삭제한다고 해도 에러가 여전하다.이는 함수 리턴 타입이 자동으로 undefined가 타입 추론 되게 만든다.
                // 결론적으로 해당 문제는 map 함수로 keepSuccess를 구현하는 것은 역부족이다.
                // 근거는 map은 구조를 보존하는 성질을 가지기 때문이다.
                // 해법은 map이면서 구조를 변경할 수 있는 flatMap을 사용한다.
                // 참고
                //      map과 flatMap의 차이점
                //          flatMap :: (A => Array<B>) => (Array<A> => Array<B>)
                //          map     :: (A => B)        => (Array<A> => Array<B>)

                if(isSuccess(ta)) return ta.result;

                // 실패 시 무엇을 리턴해야 할까?
                // tag를 제외하고는 error 밖에 없다.
                // 하지만 현재 KeepSuccess의 return type은 Array<R>이고 이는 ta.error와 타입이 일치하지 않는다.
                // 이런 경우에는 아무것도 리턴하면 안된다를 의미한다.
                // 해결 하기 위해 return 을 없애도 타입스크립트 에러가 발생한다.
                // 그 이유는 이런 상황에서는 자동으로 undefined으로 리턴타입으로 포함되기 때문이다.
                // 즉 에러일 때는 undefined를 리턴하는 것과 똑같은 상황이 된다.
                else return ta.error
            })

            return ret
        })
      ```
        - KeepSuccess는 특정 타입에서만 동작하는 함수가 아니므로, Error 타입과 Success 타입을 제네릭으로 처리한다. 

- 예제 1 - 3
   - ```
        type Success<R> = {
            readonly _tag : "success",
            readonly result : R
        }; 

        type Failed<E> = {
            readonly _tag : "failed",
            readonly error : E
        }; 

        export type Try<E, R> = Failed<E> | Success<R>; 

        export const success = <R>(result: R): Try<never, R> => ({
            _tag: 'success',
            result
        })
        
        export const failed = <E>(error: E): Try<E, never> => ({
            _tag: 'failed',
            error,
        })

        export const isSuccess = <R>(ta: Try<unknown, R>): ta is Success<R> => ta._tag ==="success";
        export const isFailed = <E>(ta: Try<E, unknown>): ta is Failed<E> => ta._tag ==='failed'; 

        export const getOrElse = <R>(ta: Try<unknown, R>, defaultValue: (e: E)=> R): R => {
            if(isFailed(ta)) return defaultValue(ta.error);              

            return ta.result;
        }

        export const map = <E, A, B>(ta: Try<E, A>, f: (a: A)=> B): Try<E, B> => {
            if (isFailed(ta)) return ta;
            return success(f(ta.result));
        }

        // 코드 변경!
        // KeepSuccess 함수 작동함
        export const KeepSuccess = <E, R>(tas: Array<T, R>) => Array<R> => {
            const ret = tas.flatMap((ta)=> {
                if(isSuccess(ta)) return [ta.result];

                else return [];
            })

            return ret
        })
      ```
        - 왜 굳이 KeepSuccess와 같이 함수형을 사용 할까? 이럴바에는 for 루프를 사용하면 더 쉽고 직관적이지 않을까
            - 다음 섹션에서 설명 예정


 - 베이스 예제 2
    - ```
        export interface Item {
            readonly code: string;
            readonly outOfStock: boolean;
            readonly name: string;
            readonly price: number;
            readonly quantity: number;
            readonly discountPrice?: number;
        } 

        export const cart : ArrayItem = [
            {
                code : 'tomato,
                outOfStock: false,
                name: '토마토',
                price: 7000,
                quantity: 2,
                discountPrice: 1000
            },
            ... 생략

        {
                code : 'orange,
                outOfStock: false,
                name: '오렌지',
                price: 15000,
                quantity: 3,
                discountPrice: 2000
            },
        ]

        import {cart, Item} from './cart';
        import * as O from './option'

        import * as T from './try

        type ParsedItem = { _tag: "parsedItem"} & item;

        type ParseError = {
            name: string;
            message: string;
        }

        const parseItem = (item: Item): T.Try<ParseItem, ParseError> => {
            if (item.quantity <1) {
            return T.failed({
                name: item.name,
                message: "상품은 반드시 한 개 이상 담아야 합니다";
            })
            } else if(item.quantity > 10) {
            return T.failed({
                name: item.name,
                message: "한 번에 10개를 초과하여 구매할 수 없습니다.";
            }) 
            }

            result T.success({
                _tag: 'parsedItem',
                ...item
            })
            
        }

        type ArrayItem = Array<T.Try<ParseError, ParsedItem>>;

        const stockItem = (item:Item): string => {
             return `
                <li>
                    <h2>${item.name}</h2>
                    <div>가격: ${item.price - discountPrice}원 ${saleText}</div>
                    <div>수량: ${item.quantity} 상자</div>
                </li>
            `;
        }

        const outOfStockItem = (item:Item): string => {
            return `
                <li class="gray">
                    <h2>${item.name} (품절)</h2>
                    <div class="strike">가격: ${item.price}원 (XX원 할인)</div>
                    <div class="strike">수량: ${item.quantity}상자</div>
                </li>
            `
        }

        const item = (item: Item) : string => {
            if(item.outOfStock) {
                return outOfStockItem(item);
            } else {
                return stockItem(item);
            }
        }

        const totalCalculator = (list: ArrayItem, getValue: (item: Item) => number) : number {
            return list
            .filter((item)=> {
                try {
                    return item.outOfStock === false;
                } catch(e) {
                    return false;
                }
            })
            .map(getValue)
            .reduce((total, value)=> total + value, 0)
        }

        const totalCount = (list:ArrayItem): string => {
            const totalCount = totalCalculator(list, (item)=> item.quantity);

            return `<h2>전체 가격 : ${totalCount} </h2>`;
        }

        const totalPrice = (list: ArrayItem) : string => {
                const totalPrice = totalCalculator(list, (item)=> item.price * item.quantity);
            
                
                const totalDiscountPrice = totalCalculator(list, (item)=> {
                    let discountPrice = O.getOrElse(O.fromUndefined(item.discountPrice));

                    return discountPrice * item.quantity;
                })

                return `<h2>전체 가격: ${totalPrice - totalDiscountPrice}원 (총 ${totalDiscountPrice}원 할인)</h2>`;
            }

        const list = (list: ArrayItem) => {
            return `
                <ul>
                    ${list
                        .map(item)
                        .reduce((tags, tag)=> tags +tag, "")
                    }
                </ul>
            `
        }

        const render = (cart: ArrayItem) => {
            O.map(O.fromNull(document.getElementById('app')), (app) => {
                app.innerHTML = `
                    <h1> 장바구니 </[h1>
                    ${list(cart)}
                    ${totalCount(cart)}
                    ${totalPrice(car]t)}
                `
            })
        }

        export const main = () => {
            render(cart.map(parseItem));
        }

      ``` 
 - 예제 2 - 1
   - ```
        export interface Item {
            readonly code: string;
            readonly outOfStock: boolean;
            readonly name: string;
            readonly price: number;
            readonly quantity: number;
            readonly discountPrice?: number;
        } 

        export const cart : ArrayItem = [
            {
                code : 'tomato,
                outOfStock: false,
                name: '토마토',
                price: 7000,
                quantity: 2,
                discountPrice: 1000
            },
            ... 생략

        {
                code : 'orange,
                outOfStock: false,
                name: '오렌지',
                price: 15000,
                quantity: 3,
                discountPrice: 2000
            },
        ]

        import {cart, Item} from './cart';
        import * as O from './option'

        import * as T from './try

        type ParsedItem = { _tag: "parsedItem"} & item;

        type ParseError = {
            name: string;
            message: string;
        }

        const parseItem = (item: Item): T.Try<ParseItem, ParseError> => {
            if (item.quantity <1) {
            return T.failed({
                name: item.name,
                message: "상품은 반드시 한 개 이상 담아야 합니다";
            })
            } else if(item.quantity > 10) {
            return T.failed({
                name: item.name,
                message: "한 번에 10개를 초과하여 구매할 수 없습니다.";
            }) 
            }

            result T.success({
                _tag: 'parsedItem',
                ...item
            })
            
        }

        // 코드 변경!
        type ArrayItem = Array<T.Try<ParseError, ParsedItem>>;

        // 코드 변경!
        const stockItem = (item:ParsedItem): string => {
             return `
                <li>
                    <h2>${item.name}</h2>
                    <div>가격: ${item.price - discountPrice}원 ${saleText}</div>
                    <div>수량: ${item.quantity} 상자</div>
                </li>
            `;
        }

        // 코드 변경!
        const outOfStockItem = (item: ParsedItem): string => {
            return `
                <li class="gray">
                    <h2>${item.name} (품절)</h2>
                    <div class="strike">가격: ${item.price}원 (XX원 할인)</div>
                    <div class="strike">수량: ${item.quantity}상자</div>
                </li>
            `
        }

        // 코드 변경!
        const item = (item: ParsedItem) : string => {
            if(item.outOfStock) {
                return outOfStockItem(item);
            } else {
                return stockItem(item);
            }
        }

        // 코드 변경!
        const totalCalculator = (list: ArrayItem, getValue: (item: ParsedItem) => number) : number {
            return list
                .filter((item)=> {
                    try {
                        return item.outOfStock === false;
                    } catch(e) {
                        return false;
                    }
                })
                .map(getValue)
                .reduce((total, value)=> total + value, 0)
        }

        const totalCount = (list:ArrayItem): string => {
            const totalCount = totalCalculator(list, (item)=> item.quantity);

            return `<h2>전체 가격 : ${totalCount} </h2>`;
        }

        const totalPrice = (list: ArrayItem) : string => {
            const totalPrice = totalCalculator(list, (item)=> item.price * item.quantity);
        
            
            const totalDiscountPrice = totalCalculator(list, (item)=> {
                let discountPrice = O.getOrElse(O.fromUndefined(item.discountPrice));

                return discountPrice * item.quantity;
            })

            return `<h2>전체 가격: ${totalPrice - totalDiscountPrice}원 (총 ${totalDiscountPrice}원 할인)</h2>`;
        }

        const list = (list: ArrayItem) => {
            return `
                <ul>
                    ${list
                        .map(item)
                        .reduce((tags, tag)=> tags +tag, "")
                    }
                </ul>
            `
        }

        const render = (cart: ArrayItem) => {
            O.map(O.fromNull(document.getElementById('app')), (app) => {
                app.innerHTML = `
                    <h1> 장바구니 </[h1>
                    ${list(cart)}
                    ${totalCount(cart)}
                    ${totalPrice(car]t)}
                `
            })
        }

        export const main = () => {
            render(cart.map(parseItem));
        }
     ``` 
- 예제 2 - 3 (중간에 에제 2 -2 지움)
   - ```
        export interface Item {
            readonly code: string;
            readonly outOfStock: boolean;
            readonly name: string;
            readonly price: number;
            readonly quantity: number;
            readonly discountPrice?: number;
        } 

        export const cart : ArrayItem = [
            {
                code : 'tomato,
                outOfStock: false,
                name: '토마토',
                price: 7000,
                quantity: 2,
                discountPrice: 1000
            },
            ... 생략

        {
                code : 'orange,
                outOfStock: false,
                name: '오렌지',
                price: 15000,
                quantity: 3,
                discountPrice: 2000
            },
        ]

        import {cart, Item} from './cart';
        import * as O from './option'

        import * as T from './try

        type ParsedItem = { _tag: "parsedItem"} & item;

        type ParseError = {
            name: string;
            message: string;
        }

        const parseItem = (item: Item): T.Try<ParseItem, ParseError> => {
            if (item.quantity <1) {
            return T.failed({
                name: item.name,
                message: "상품은 반드시 한 개 이상 담아야 합니다";
            })
            } else if(item.quantity > 10) {
            return T.failed({
                name: item.name,
                message: "한 번에 10개를 초과하여 구매할 수 없습니다.";
            }) 
            }

            result T.success({
                _tag: 'parsedItem',
                ...item
            })
            
        }

        type ArrayItem = Array<T.Try<ParseError, ParsedItem>>;

        const stockItem = (item:ParsedItem): string => {
             return `
                <li>
                    <h2>${item.name}</h2>
                    <div>가격: ${item.price - discountPrice}원 ${saleText}</div>
                    <div>수량: ${item.quantity} 상자</div>
                </li>
            `;
        }

        const outOfStockItem = (item: ParsedItem): string => {
            return `
                <li class="gray">
                    <h2>${item.name} (품절)</h2>
                    <div class="strike">가격: ${item.price}원 (XX원 할인)</div>
                    <div class="strike">수량: ${item.quantity}상자</div>
                </li>
            `
        }

        const item = (item: ParsedItem) : string => {
            if(item.outOfStock) {
                return outOfStockItem(item);
            } else {
                return stockItem(item);
            }
        }

        // 코드 변경!
        //      타입 시스템의 feedbackd에 의해 리팩토링하고 있다는 것을 명심하고 일하자. 
        //      list는 Array<Try<ParseError, ParsedItem>> 타입이다.
        //      totalCalulator는 파싱이 성공했을 때만 계산을 수행 해야한다.
        //      KeepSuccess를 통해 해결한다.
        const totalCalculator = (list: ArrayItem, getValue: (item: ParsedItem) => number) : number {
            // list의 타입을 Array<T, Try<ParseError, ParsedItem>> 을 Array<parsedItem>로 변화하는 KeepSuccess가 필요로 하다.
            return T.KeepSuccess(list)
                .filter((item)=> {
                   return item.outOfStock === false;
                })
                .map(getValue)
                .reduce((total, value)=> total + value, 0)
        }

        const totalCount = (list:ArrayItem): string => {
            const totalCount = totalCalculator(list, (item)=> item.quantity);

            return `<h2>전체 가격 : ${totalCount} </h2>`;
        }

        const totalPrice = (list: ArrayItem) : string => {
            const totalPrice = totalCalculator(list, (item)=> item.price * item.quantity);
        
            
            const totalDiscountPrice = totalCalculator(list, (item)=> {
                let discountPrice = O.getOrElse(O.fromUndefined(item.discountPrice));

                return discountPrice * item.quantity;
            })

            return `<h2>전체 가격: ${totalPrice - totalDiscountPrice}원 (총 ${totalDiscountPrice}원 할인)</h2>`;
        }

        // 코드 변경!
        //      코드가 작동 안하는 이유
        //          - T.map은 여전히 Try 타입을 리턴한다.
        //      개선 방향
        //          - parsing이 실패하면 getOrElse를 통해 error item을 호출하도록 변경해야 한다.
        const list = (list: ArrayItem) => {
            return `
                <ul>
                    ${list
                        .map(item => T.map(item, parsedItem => renderItem(parsedItem))) 
                        .reduce((tags, tag)=> tags +tag, "")
                    }
                </ul>
            `
        }

        const render = (cart: ArrayItem) => {
            O.map(O.fromNull(document.getElementById('app')), (app) => {
                app.innerHTML = `
                    <h1> 장바구니 </[h1>
                    ${list(cart)}
                    ${totalCount(cart)}
                    ${totalPrice(car]t)}
                `
            })
        }

        export const main = () => {
            render(cart.map(parseItem));
        }
     ```  

- 예제 2 - 4
   - ```
        export interface Item {
            readonly code: string;
            readonly outOfStock: boolean;
            readonly name: string;
            readonly price: number;
            readonly quantity: number;
            readonly discountPrice?: number;
        } 

        export const cart : ArrayItem = [
            {
                code : 'tomato,
                outOfStock: false,
                name: '토마토',
                price: 7000,
                quantity: 2,
                discountPrice: 1000
            },
            ... 생략

        {
                code : 'orange,
                outOfStock: false,
                name: '오렌지',
                price: 15000,
                quantity: 3,
                discountPrice: 2000
            },
        ]

        import {cart, Item} from './cart';
        import * as O from './option'

        import * as T from './try

        type ParsedItem = { _tag: "parsedItem"} & item;

        type ParseError = {
            name: string;
            message: string;
        }

        const parseItem = (item: Item): T.Try<ParseItem, ParseError> => {
            if (item.quantity <1) {
            return T.failed({
                name: item.name,
                message: "상품은 반드시 한 개 이상 담아야 합니다";
            })
            } else if(item.quantity > 10) {
            return T.failed({
                name: item.name,
                message: "한 번에 10개를 초과하여 구매할 수 없습니다.";
            }) 
            }

            result T.success({
                _tag: 'parsedItem',
                ...item
            })
            
        }

        type ArrayItem = Array<T.Try<ParsedItem, ParseError>>;

        const stockItem = (item:ParsedItem): string => {
             return `
                <li>
                    <h2>${item.name}</h2>
                    <div>가격: ${item.price - discountPrice}원 ${saleText}</div>
                    <div>수량: ${item.quantity} 상자</div>
                </li>
            `;
        }

        const outOfStockItem = (item: ParsedItem): string => {
            return `
                <li class="gray">
                    <h2>${item.name} (품절)</h2>
                    <div class="strike">가격: ${item.price}원 (XX원 할인)</div>
                    <div class="strike">수량: ${item.quantity}상자</div>
                </li>
            `
        }

        const item = (item: ParsedItem) : string => {
            if(item.outOfStock) {
                return outOfStockItem(item);
            } else {
                return stockItem(item);
            }
        }

        // 코드 변경!
        const totalCalculator = (list: ArrayItem, getValue: (item: ParsedItem) => number) : number {
            return T.KeepSuccess(list)
                .filter((item)=> {
                    return item.outOfStock === false;
                })
                .map(getValue)
                .reduce((total, value)=> total + value, 0)
        }

        const totalCount = (list:ArrayItem): string => {
            const totalCount = totalCalculator(list, (item)=> item.quantity);

            return `<h2>전체 가격 : ${totalCount} </h2>`;
        }

        const totalPrice = (list: ArrayItem) : string => {
            const totalPrice = totalCalculator(list, (item)=> item.price * item.quantity);
            
            const totalDiscountPrice = totalCalculator(list, (item)=> {
                let discountPrice = O.getOrElse(O.fromUndefined(item.discountPrice));

                return discountPrice * item.quantity;
            })

            return `<h2>전체 가격: ${totalPrice - totalDiscountPrice}원 (총 ${totalDiscountPrice}원 할인)</h2>`;
        }

        // 코드 변경!
        const list = (list: ArrayItem) => {
            return `
                <ul>
                    ${list
                        .map(item => 
                            T.getOrElse(
                                T.map(item, parsedItem => item(parsedItem)),
                                errorItem
                            ))
                        .reduce((tags, tag)=> tags +tag, "")
                    }
                </ul>
            `
        }

        const render = (cart: ArrayItem) => {
            O.map(O.fromNull(document.getElementById('app')), (app) => {
                app.innerHTML = `
                    <h1> 장바구니 </[h1>
                    ${list(cart)}
                    ${totalCount(cart)}
                    ${totalPrice(car]t)}
                `
            })
        }

        export const main = () => {
            render(cart.map(parseItem));
        }
      ```
        - 고찰
          - 타입 시스템의 feedback에 의해 리팩토링하고 있다는 것을 명심하고 일하자. 
          - try-catch의 적용 범위는 하나의 기능의 범위에서 처리하는 것과 큰 범위에서 처리하는 것으로 나뉠 수 있다.
          - 전역적으로 try-catch 구문을 적용하는 예시로는 react sentry logging이 존재한다.
          - 해당 예제에서는 기능 별 예외처리가 필요하므로 기능 별 try-catch 구문을 적용하였다.
          - 정답은 없고, 상황에 따라 try-catch 구문 범위를 효과적으로 적용하면 좋겠다는 생각이 든다.
        - 결과
          - validation 위주의 프로그래밍에서 parsing 위주의 프로그래밍으로 리팩토링 됨. 
        - 의문
          - 왜 기능의 구현에 대한 각 함수의 인자의 타입은 Item 타입이 아니라 ParsedItem 타입을 사용할까?
            - 만약 Item 타입을 이용해서 각 기능 함수를 호출하려면, ParsedItem의 타입 중 하나인 Try 타입을 제거하고 Item만을 peek해야 한다.
            - 이러한 추가 로직은 부수효과를 발생시킬 위험성 측면 및 함수 합성 측면에서 이점은 없어보인다. 
            - 굳이 ParsedItem을 번거롭게 Peek을 하는 방식보다는, 각 함수의 인자의 타입을 Try Type만 허용하는 것이 일반적으로 더 효율적이라고 판단된다.
          - 만약 Item과 ParsedItem을 각 함수의 인자의 타입으로 허용하고 싶으면 함수의 인자 타입을 두 타입의 Union을 쓰는 것도 하나의 방법이라고 생각이 들었다. 
            - 이는 명백히 참조 투명성 측면에서 옳지는 않다. 
          - 각 type인자로 호출하면서 동일한 기능을 하는 함수에 대해서 객체지향의 override 개념을 적용할 수 없을까란 의문도 들었다.
            - 이는 override의 근본적인 목적과는 일치하지 않는 측면이 존재한다.
            - override에 대한 좋은 예시로 패킷 직렬화 객체의 연산자 override <를 통한 패킷의 직렬화를 하는 객체의 경우, <의 대상은 타입과 상관없이 문자열, 숫자, 기타 객체를 모두 동일하게 직렬화 버퍼에 알맞는 데이터로 override를 통해서 처리하기 때문에 분명한 이점이 존재한다고 본다. 
            - 패킷 직렬화 객체의 예시에서 알 수 있는 override의 장점과 다르게, 해당 예제에 대해서는 같은 기능의 함수를 여러 가지의 함수로 관리하는 것은 다형성 측면에서는 좋은 해결 방안 같지는 않다.
            - 이유는 함수 호출의 인자 type만 다르고 기능적으로 동일하기 때문이다.
            - 여러 메서드의 type에 대한 객체의 override는 참조가 투명함 측면에서는 큰 장점이기는 할 것으로 추측된다.
            - 객체지향 패러다임 관점에서 만약 다른 다형성의 예시로 추상 클래스를 상속받아 추상 클래스를 구현하는 방식을 통한 객체 다형성 활용이 참조 투명성이 보장되는 방식은 아닌 것 같다는 생각이 들었다.
            - 예시로 aninal 이란 추상 클래스에, human과 lion의 구현체가 존재하는 경우 human.eat()과 lion.eat()을 animal.eat()으로 다형성 처리가 가능하지만 예시로 변수 Animal animal은 대입하는 객체에 따라 human, lion 객체를 참조하기 때문이다.
            - 아직 객체지향과 함수형 패러다임에 대한 지식이 부족해서 이 주제는 조금 더 생각해볼 주제인 것 같다.
          - 스트레터지 패턴을 통해 각 타입 별 함수의 인자를 받는 함수를 만들고, 만일 Try Type을 인자로 받지 않는 함수의 경우 해당 인자를 Try 타입으로 만들고 기능 함수의 인자값으로 Try 타입만을 통해서 기능 함수를 호출하는 방식의 객체지향의 스트레터지 방식을 도입할 수 있지 않을까 싶기도 하다.
            - 함수형 프로그래밍에서는 getOrElse 또는 parseItem 함수로 처리 하고 있다. 
            - 함수형 프로그래밍의 불변성 측면에서는 main에서 parseItem을 하는 것이 가장 옳다고 본다.
          - 정말 순수한 함수 합성을 만들기 위해서 main에서 parseItem을 처리하면서 동시에 요구사항을 구현 기능 구현 함수를 호출 하기 이전에 Try Type이 아닌 item에 대해서 Try Type로 parseItem 처리 어떨까란 생각이 들었다.
            - 위 예제는 각 함수의 기능이 render(cart.map(parseItem))에 의해 ParseItem 타입인 인자에 의한 호출에서만 동작하기 때문이다.
            - 이러한 점에 의한 단점으로 특정 타입에 종속적인(강제적인) 함수 호출은 사용성을 떨어트리지 않을까 생각이 들기는 한다.
            - 장점은 이러한 함수 호출에서 강한 타입에 대한 강제성은 (참조 투명성 측면을 포함한) 순수함수와 부수효과 최소화 측면에서 장점이 크다고 생각이 든다.
            - 경우에 따라 함수의 인자의 타입의 강제성 수준을 조절해야 할 경우도 존재할 것 같다. 이는 경험을 통해 알 수 있을 것 같다.

## 명령형 vs 선언형
 - 베이스 예제
   - ```
        type Success<R> = {
            readonly _tag : "success",
            readonly result : R
        }; 

        type Failed<E> = {
            readonly _tag : "failed",
            readonly error : E
        }; 

        export type Try<E, R> = Failed<E> | Success<R>; 

        export const success = <R>(result: R): Try<never, R> => ({
            _tag: 'success',
            result
        })
        
        export const failed = <E>(error: E): Try<E, never> => ({
            _tag: 'failed',
            error,
        })

        export const isSuccess = <R>(ta: Try<unknown, R>): ta is Success<R> => ta._tag ==="success";
        export const isFailed = <E>(ta: Try<E, unknown>): ta is Failed<E> => ta._tag ==='failed'; 

        export const getOrElse = <R>(ta: Try<unknown, R>, defaultValue: (e: E)=> R): R => {
            if(isFailed(ta)) return defaultValue(ta.error);              

            return ta.result;
        }

        export const map = <E, A, B>(ta: Try<E, A>, f: (a: A)=> B): Try<E, B> => {
            if (isFailed(ta)) return ta;
            return success(f(ta.result));
        }

        export const KeepSuccess =
            <E, R>(tas: Array<Try<E, R>>): Array<R> => {
                const ret = tas.flatMap((ta) => {
                    if(isSuccess(ta)) return [ta.result];
                })
                return ret;
            }
   - ```
     - keepSuccess는 flatMap을 통해 `Array<R>` 타입을 반환이 가능했다. (동작의 추상화)
     - 이는 값이 무엇이 되어야 하는 가에 대한 선언적인 사고가 자연스럽게 도와준다.
     - 선언적으로 작성하기 위해서 꼭 Try Type, Option Type, 기타 함수 등이 필요로 하지 않다.
     - 중요한 점은 부수효과가 어떤 것인지 파악하고, 격리하는지에 대한 아이디어만 있다면 사용하는 언어나 라이브러리와 관계없이 이러한 방식의 코드 작성이 얼마든지 가능함이다.
 - 예제 1 - 1 / KeepSuccess를 for loop로 구현 
     - ```
          export const KeepSuccessWithFor =  <E, R>(tas: Array<Try<E, R>>): Array<R> => {
              const ret : Array<R> = [];
              for(const ta of tas) {
                  if (isSuccess(ta)) {
                      ret.push(ta.result);
                  }
              }
              return ret;
          } 
       ```
        - KeepSuccessWithFor은 loop안에서 값을 리턴하면 안되기 때문에, 값을 중심으로 사고하기가 어렵다.
        - 성공 시 어떤 작업을 해야하는 지 명령적으로 사고를 해야 한다.
        - KeepSuccess보다 모든 면에서 나음을 이야기하는 것은 아니다.
  - flat 함수 구현
    - ```
        // flat :: Array<Array<A>> => Array<A>
      ``` 
    - 기타
        - ```
              // flatMap :: (A => Array<B>) => (Array<A> => Array<B>)
              // map     :: (A => B)        => (Array<A> => Array<B>) 
          ```
              - map은 구조를 보존한다.
              - flatMap은 구조를 변경한다.
              - 배열의 다른 메서드는 flat이라는 함수가 존재한다.
              - flat 함수
              -  2차원 배열을 합쳐서 1차원 배열로 만든다.
              - flat 함수의 역할을 배열에만 한정짓지 않고, 동일한 효과가 중첩되어 있을 때 하나의 함수로 합치는 역할을 할 수 있다.
  - 예제 2 - 1 / Try의 flatMap 구현을 위한 준비
    - ```
         // flat :: Array<Array<A>> => Array<A>
         
         // 변경 과정 1
         // flat :: Try<Try<A>> => Try<A>

         // 변경 과정 2
         //     - Try는 Type인자가 E, R이므로, 둘다 표기를 해야 한다.
         // flat :: Try<E, Type<E,A>> => Try<E, A>

         // 변경 과정 3
         //     - Try E는 하나의 제네릭 타입으로 이해 할 수 있다.
         // flat :: Try<E, Type<E,A>> => Try<E, A>

      ```
        - 제네릭 타입은 타입 함수로 생각할 수 있다.
        - Try를 타입 인자가 두 개인 타입함수로 생각한다면, Try의 E라는 타입 인자를 먼저 적용하여 partial application으로 사용한다고 생각해도 좋다.
        - Try라는 인자가 2개인 함수에 E라는 인자 하나를 먼저 적용해서 사용하는 것과 마찬가지이다.
  - 예제 2 - 2 / Try의 flat 구현
    - ```
         export const flat = <E, A>(tta: Try<E, Try<E, A>>): Try<E, A> => {
             if (isSuccess(tta)) return tta.result;
             return tta;
         }
      ```
        - tta의 Try의 2번째 타입은 함수의 리턴타입과 같다.
        - 의문
          - isFailed 시 함수의 return 값이 tta이다. 어떻게 `Try<E,A>`가 될까?
              - Try 타입은 실패와, 성공의 타입이 나뉜다. 표현하면 `type Try<E, R> = Failed<E> | Success<R>`
              - 실패했을 때는 첫 번째 타입 인자만 쓰고, 성공 시 두 번째 타입 인자만 쓴다.
              - 즉, 성공 시에는 `Success<Try<E,A>>`(Success 타입 안에 `Try<E, A>`가 존재함) 이다. 
              - 그러므로 인자의 result를 return하면 된다.
              - 실패시 Try의 실패에 해당하는 타입 파라미터만 사용되므로, return type과 동일한 Failed Type이 된다.
              - `Try<E ..`부분이 항상 감음을 주목하자.
              - 이 관찰에서 Try의 타입이 중첩되어 있을 경우에서 성공 했을 때 성공에 대해 `Try<E,A>`를 사용해서 처리하고,
              - 실패시에는 Error만 남기 때문에, 다음 계산의 실행이 중단됨을 알 수 있다. (Error 처리하는 코드 참고!)
 - 예제 2 - 3 / Try의 flatMap 구현 / flatMap
   -  ```
        // map 인터페이스를 flatMap에 복사  
        export const flatMap = <E, A, B>(ta: Try<E, A>, f(a: A) => B): Try<E, B> => {

        } 
      ```
       - flatMap은 map은 한 부분을 제외하고 같다.
       - map 코드를 활용해서 flatMap을 만들 수 있다.
       - flatMap과 map의 다른 점은 f의 리턴 타입에 있다.
- 예제 2 - 4 / Try의 flatMap 구현
    - ```
        export const flatMap = <E, A, B>(ta: Try<E, A>, f: (a: A) => Try<E, B>): Try<E, B> => {

        }
      ```
- 예제 2 - 5 / Try의 flatMap 구현
    - ```
        export const flatMap = <E, A, B>(ta: Try<E, A>, f: (a: A) => Try<E, B>): Try<E, B> => {
            return flat(map(ta, f));
        }
      ```
        - 작은 함수들을 조합해서 복잡한 함수를 만드는 개념을 활용해서 구현 할 수 있다.
        - map 및 flat 함수를 합성해서 flatMap을 구현할 수 있다.
  - 고찰
    - flatMap은 Option에서도 같은 방식으로 구현이 가능하다.
    - 관심이 있다면 직접 구현을 추천한다.
## 참고
 - https://fastcampus.co.kr/courses/207789/clips/
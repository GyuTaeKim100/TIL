# Try-catch
 - 목표
     - Try-catch가 어떻게 참조에 투명하지 않은지 파악
     - throw의 단점

## 예제 / Try-catch 및 throw가 참조에 투명하지 않은 이유
   - 베이스 예제
       - ```
            console.clear();

            const tenDivideBy = (n: number): number => {
                if(n ===0) {
                    throw Error("0으로 나눌 수 없습니다.");
                }
                return 10 / n;
            }

            const test =() => {
                try {
                    return tenDivideBy(0);
                } catch (e){
                    return 1;
                }
            }

            export const main = () => {
                const x = test();
                console.log(x);
                console.log('프로그램이 종료 되었습니다.');
            }
         ```
          - tenDivideBy 함수의 문제점
              - 리턴 타입에 의해서 참조가 투명하지 않음 
                - 리턴 타입이 number 임에 주의
                - 숫자는 0으로 나눌 수 없다.
                    - 이 경우 throw를 통해서 에러 발생시킨다.
                - throw Error가 함수 구현에 추가되었지만, return type이 number이다. 
                - 이를 통해 함수의 return type만으로는 함수가 에러를 발생하는 지를 파악하기 어렵다.
                - 값의 부재 측면에서 return 타입 중 일부를 값의 부재로 표현 또는 undefined로 return 됨을 타입에 명시되었지만, 에러는 리턴 타입 추론이 작동하지 않는다.
                - 결론으로 해당 함수의 리턴값은 참조에 투명하지 않다. 이에 의해 Try-catch 구문이 포함된 test 함수 또한 참조에 투명하지 않게 된다.
                - 이를 해결하기 위해서 에러를 사전에 파악하려면, 별도 에러에 대해서 문서화 또는 주석을 달거나, 해당 함수의 코드를 분석해야만 한다.
                - 이런 문제점을 해결하기 위해 throw로 에러를 해결하는 대신,명시적인 값으로 리턴하는 방법도 존재한다.
  - 예제 1 
       - ```
            console.clear();

            const tenDivideBy = (n: number): number => {
                if(n ===0) {
                    throw Error("0으로 나눌 수 없습니다.");
                }
                return 10 / n;
            }

            // 코드 변경!
            const test =() => {
                try {
                    const y = tenDivideBy(0);
                    return y;
                } catch (e){
                    return 1;
                }
            }

            export const main = () => {
                const x = test();
                console.log(x);
                console.log('프로그램이 종료 되었습니다.');
            }
          ```
           - 의문
             - 프로그램에 변화가 없다. 이는 참조에 투명한 것일까?
- 예제 2 / Throw를 리턴하는 함수를 try 밖으로 빼기 
       - ```
            console.clear();

            const tenDivideBy = (n: number): number => {
                if(n ===0) {
                    throw Error("0으로 나눌 수 없습니다.");
                }
                return 10 / n;
            }

            // 코드 변경!
            const test =() => {
                const y = tenDivideBy(0);
                try {
                    return y;
                } catch (e){
                    return 1;
                }
            }

            export const main = () => {
                const x = test();
                console.log(x);
                console.log('프로그램이 종료 되었습니다.');
            }
         ```
          - 결과로 1을 리턴하는 것이 아닌, console Error를 출력하고 프로그램이 중단된다.
          - Error를 발생하는 즉시 프로그램이 중단되었기 떄문에, '프로그램이 종료 되었습니다'라는 문자열도 출력되지 않았다.
          - 이를 통해 알 수 있는 사실은 예외가 발생하는 표현식은 try-catch 블록의 안과 밖에 존재하는지에 따라 프로그램의 동작이 달라지기 떄문에 참조에 투명하지 않다.
          - 의문으로 이 참조에 투명하지 않은 문제를 해결할 수 있는 방법은 없을까?
          - 에러가 발생했을 때 Throw 대신 에러를 명시적인 값으로 반환하는 방법이 있따.
          - 에러를 명시적으로 값으로 반환하면 try-catch문 대신 에러가 아닐때와 에러일 때 코드를 별도로 작성 할 수 있다.
          - 이는 값의 부재를 다루는 Option 타입을 만든 것과 맥락이 같다.


## 에러를 값으로 다루는 타입
 - 실패하거나 성공했을 때 각각 다른 값을 가지는 자료 구조
 - ADT의 대수 자료형에서, 합 타입에 해당하는 tagged union을 흉내내도록 한다.
 - 예제 1 / Success 타입
    - ```
        type Success<R> = {
            readonly _tag : "success",
            readonly result : R
        };
      ```
 - 예제 2 / Failed 타입
     -  ```
          type Failed<E> = {
              readonly _tag : "failed",
              readonly result : E
          }; 
        ```
 - 예제 3 / Try 타입
     - ```
           type Success<R> = {
              readonly _tag : "success",
              readonly result : R
          }; 

          type Failed<E> = {
              readonly _tag : "failed",
              readonly result : E
          }; 

          // 에러가 발생하고 있다.
          export type Try = Failed | Success
       ```
        - Try 타입에서 에러가 발생하는 이유
          - Faild와 Success는 타입 파라미터가 각각 1개씩 필요하기 때문에 에러가 발생한다.
          - 둘은 서로 다른 타입을 허용해야 하므로, Try는 Failed와 Success에 대해 개별적으로 전달될 타입 파라미터를 각각 하나씩 입력해야 하므로, Try는 2가지 파라미터를 입력 받아야 한다.
 - 예제 4 / Try 타입 개선
     - ```
          type Success<R> = {
              readonly _tag : "success",
              readonly result : R
          }; 

          type Failed<E> = {
              readonly _tag : "failed",
              readonly result : E
          }; 

          export type Try<E, R> = Failed<E> | Success<R>;
       ```
 - 예제 5 / 성공과 실패를 만드는 함수 추가
     - ```
         type Success<R> = {
              readonly _tag : "success",
              readonly result : R
          }; 

          type Failed<E> = {
              readonly _tag : "failed",
              readonly result : E
          }; 

          export type Try<E, R> = Failed<E> | Success<R>; 

          export const success = <R>(result: R): Try<never, R> => ({
              _tag: 'success',
              result
          })
          
          export const failed = <E>(error: E): Try<E, never> => ({
              _tag: 'failed',
              error,
          })
       ``` 
        - success, failed 두 함수에서는 never이 사용되고 있다.
        - 이는 Try의 인터페이스에 의해서 사용하지 않는 타입에 대해서 never를 사용.
        - 리턴 타입에는 success 타입 또는 failed 타입이 아닌 Try 타입을 사용했다.
        - 이유는 값을 만들 때는 success 또는 failee 등 구체적인 타입으로 추론 시키는 것 보다 일반적인 Try로 만들고, 구체적인 타입을 알아야 할 때는 type들을 구분해서 그에 맞는 동작을 하는 것이 더 범용적이기 때문이다.
        - 추가로 never를 사용할 때는 안 쓰는 타입 파라미터가 리턴 타입에서 사용 될 때는 never를 사용해야 한다.
- 예제 6 / 타입 확인 함수 추가
    - ```
          type Success<R> = {
              readonly _tag : "success",
              readonly result : R
          }; 

          type Failed<E> = {
              readonly _tag : "failed",
              readonly result : E
          }; 

          export type Try<E, R> = Failed<E> | Success<R>; 

          export const success = <R>(result: R): Try<never, R> => ({
              _tag: 'success',
              result
          })
          
          export const failed = <E>(error: E): Try<E, never> => ({
              _tag: 'failed',
              error,
          })

          export const isSuccess = <R>(ta: Try<unknown, R>): ta is Success<R> => ta._tag ==="success";
          export const isFailed = <E>(ta: Try<E, unknown>): ta is Failed<E> => ta._tag ==='failed';
      ```
        - isSuccess, isFailed 함수는 안쓰는 함수 인자를  unknown을 사용했는데, unknown은 해당 타입의 함수 인자에서 사용 될 때는 never 보다 unknown이 더 적합하다.
        - unknown, never에 관련해서
           - 타입스크립트의 타입시스템이 subtype을 사용하기 때문인데, 인자 타입과 리턴 타입에 따라 subtype의 동작이 달라지기 떄문이다.
           - 이를 공변성과 반공변성이라고 표현한다. (이는 심화주제이므로 다음에 학습하자)
           - 이전 예제 중 Option을 처리한 getOrElse를 사용햇었는데, 이는 값이 없으면 사용할 기본 값을 설정 후 Option을 제거한 타입으로 만드는 함수였다.
           - Try에서도 이러한 역할을 하는 함수를 만든다면 Option과 비슷한 방식으로 구현 할 수 있을것이다.
 - 예제 7 / Try를 대체 할 getOrElse 함수 제작
     - ```
           type Success<R> = {
                readonly _tag : "success",
                readonly result : R
            }; 

            type Failed<E> = {
                readonly _tag : "failed",
                readonly result : E
            }; 

            export type Try<E, R> = Failed<E> | Success<R>; 

            export const success = <R>(result: R): Try<never, R> => ({
                _tag: 'success',
                result
            })
            
            export const failed = <E>(error: E): Try<E, never> => ({
                _tag: 'failed',
                error,
            })

            export const isSuccess = <R>(ta: Try<unknown, R>): ta is Success<R> => ta._tag ==="success";
            export const isFailed = <E>(ta: Try<E, unknown>): ta is Failed<E> => ta._tag ==='failed'; 

            export const getOrElse = <R>(ta: Try<unknown, R>, defaultValue: R): R => {
              // 에러가 있을 경우 기본 값을 사용한다.
              if(isFailed(ta)) return defaultValue;              

              // 결과가 성공이라면 해당 값을 사용한다.
              return ta.result;
            }
       ```
        - 추가 개선 방향
          - error를 구분할 수 있다면 더 활용도가 높아질 것이다.
            - 이를 위해 getOrElse함수의 에러 처리 절은, default value는 값이 아니라 error type의 값을 입력 받아 성공 타입에 대한 값을 리턴하는 함수가 되어야 한다.
 - 예제 8 / getOrElse 개선
     - ```
           type Success<R> = {
                readonly _tag : "success",
                readonly result : R
            }; 

            type Failed<E> = {
                readonly _tag : "failed",
                readonly result : E
            }; 

            export type Try<E, R> = Failed<E> | Success<R>; 

            export const success = <R>(result: R): Try<never, R> => ({
                _tag: 'success',
                result
            })
            
            export const failed = <E>(error: E): Try<E, never> => ({
                _tag: 'failed',
                error,
            })

            export const isSuccess = <R>(ta: Try<unknown, R>): ta is Success<R> => ta._tag ==="success";
            export const isFailed = <E>(ta: Try<E, unknown>): ta is Failed<E> => ta._tag ==='failed'; 

            export const getOrElse = <R>(ta: Try<unknown, R>, defaultValue: (e: E)=> R): R => {
              // 에러가 있을 경우 에러에 기반하여 기본 값을 결정한다.
              if(isFailed(ta)) return defaultValue(ta.error);              

              // 결과가 성공이라면 해당 값을 사용한다.
              return ta.result;
            }
       ```
        - 알 수 있는 사실
          - 대수 자료형과 패턴 매칭을 제공하는 일부 언어들은, 언어에서 제공하는 Option 또는 Try를 만들 때 필요한 3~4줄 분량의 타입 선언만으로도 우리가 직접 만든 여러 가지 타입들과 타입들과 동일한 기능을 제공하기도 한다.
          - 그러한 언어는 조금 더 구현에 편할 수 있을지 모르나, 이러한 기법을 잘 안다면 타입 스크립트 뿐 아니라 다른 언어들에서도 충분히 직접 만들어서 사용 할 수 있을 것이다.
          - 직접 구현을 통해 Option과 상당히 비슷함을 알 수 있다. 
          - 다음 섹션에서는 Option과 Try의 트레이드 오프를 파악한다.

## 참고
 - https://fastcampus.co.kr/courses/207789/clips/
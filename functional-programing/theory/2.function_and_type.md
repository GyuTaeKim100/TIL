# 함수와 함수 합성

## 명령적 사고에서 선언적 사고로 전환
 - ![6.png](./imgs/6.png) 
 - 전역 변수에 숨겨진 부수효과 찾아내기
 - 절차(Procedure)를 순수함수로 바구기
 - Record Data와 함수 비교하기
 - 함수 합성(composition)
 - 함수와 타입, 집합
 - 타입을 만드는 함수, 제네릭(Generic)

## 계산과 부수효과의 분리 - 전역 변수에 숨겨진 부수효과 찾아내기
 - 예제 1
     - ```
        // 토마토 : 7000원
        // 오렌지 : 15000원
        // 사과 : 10000원

        export let totalPrice = 0;

        totalPrice += 7000;
        totalPrice += 15000;
        totalPrice += 10000;

        totalPrice += 30000; // 문제 발생! - 30000원의 근원이 불분명 (사과 3개 또는 오렌지 2개)
        
        totalPrice += 8000; // 문제 발생 - 토마토를 7000원이 아닌 8000원을 더 하게 됨

        totalPrice +=700; // 문제 발생 - 토마토의 마지막 자릿수 오타

        // 만약 새롭게 계산을 해야 하는 경우, export let 아래의 모든 코드를 다 지우고 다시 totalPrice를 계산해야 한다.
       ```
 - 에제 2 - 명령형 프로그래밍 적용
     - ```
        // 토마토 : 7000원
        // 오렌지 : 15000원
        // 사과 : 10000원

        // 전역상태 - 부수효과
        export let totalPrice = 0; 


        // 프로시저 1
        export function addTomato() {
            totalPrice+= 7000;
        }

        // 프로시저 2
        export function addOrange() {
            totalPrice+= 15000;
        }

        // 프로시저 3
        export function addApple() {
            totalPrice += 10000;
        }

        // 프로시저 4
        export function list1() {
            // 토마토, 오렌지, 사과 한 박스
            addTomato();
            addOrange();
            addApple();
        }

        // 프로시저 5
        export function list2() {
            // 토마토 2상자
            addTomato();
            addTomato();
        }

        // 프로시저 6
        export function list3() {
            // 오렌지 100상자

            // 직접 타이핑
            //  - 문제 발생 - 직접 타이핑 시 100번의 동일한 코드 필요, 실수 발생 가능성이 높고 확인이 쉽지 않다.
            //  - 문제 발생 - 만일 100개 중 30개를 뺀다면? 코드 변경 후 제대로 변경된 여부를 확인이 필요
            addOrange();
            addorange();
            ... // 반복 생략
            addOrange();

            // 반복문 사용
            for(i = 0; i < 100 ; i++) {
                addOrange();
            }
        }

        export function main() {
            list1();
        }
       ```
        - 계산 과정에 초점을 맞춰서 코딩
    - 예제2 - 사이드 이펙트 발생시키기
        - ```
           import * as from './clip3_2";

           C.main()

           const app = document.getElementById("app");
           if(app !== null) {
               app.innerHTML = `
                <h1>Total price:${Math.round(C.totalPrice)}</h1>
               `
           }
          ```
            - 원본 코드 결과는 1500000이고
            - `<h1>total price ... 생략</h1>`으로 T를 t로 변경시 값이 3000000으로 변경됨
                - 왜 문자 하나의 대소문자 변경에 의해 이러한 사이드 이펙트가 발생했을까?
                    - 이유는 코드 샌드 박스에서 구동 시 핫 모듈 리플레이스먼트가 변경된 코드에만 적용되고 다른 코드에 대해서는 적용이 안되서이다. 즉 js 파일에서 main은 실행 되었지만, 전역 변수인 totalPrice 변수가 초기화 될 기회를 얻지 못하고 기존 변수 값에 추가 연산을 해서 발생한다.
                    - 즉 부수효과의 원인을 찾기 어렵고 이해하기 어려운 예시이다.




## 참고
 - https://fastcampus.co.kr/courses/207789/clips/
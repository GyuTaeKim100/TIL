# OnBoarding
 - reactivex.io 공식 도큐먼트 학습

## 메인
### 주요 특징
1. The Observer pattern done right.
  - Observer pattern
  - Iterator pattern
  - functional programming
2. Create
  - Easily create event streams or data streams.
3. Combine
  - Compose and transform streams with query-like operators.
4. Listen
  - Subscribe to any observable stream to perform side effects.
    - 의문
      - 의도적인 Side Effect를 만듬을 목적으로 함?

### Better codebases
1. Functional
  - Avoid intricate stateful programs (복잡한 상태를 가진 프로그래밍을 피하자), using clean input/output functions over observable streams.
2. Less is more (적을수록 낫다)
  - ReactiveX's operators often reduce what was once an elaborate challenge(치밀한 도전) into a few lines of code.
3. Async error handling
  - Traditional try/catch is powerless for errors in asynchronous computations, but ReactiveX is equipped with proper mechanisms for handling errors.
    - 의문
      - 왜 전통적인 try/catch가 async error에 효과적이지 않다고 주장할까?
      - ReactveX는 오류를 처리하는 어떤 적절한 메커니즘을 갖추었는가?
4. Concurrency made easy
  - Observables and Schedulers in Reactive X allow the programmer to abstract away low-level threading, synchronization, and concurrency issues.
    - 의문
      - ReactiveX는 저수준 스레딩, 동기화, 동시성 이슈를 어떻게 추상화 하는가?

## Introduction
### ReactiveX
  - ReactiveX is a library for composing asynchronous and event-based programs by using observable sequences.
      - 의문
        - event-based programs?
        - observable sequences?
  - [!img1](./imgs/1.png)
  - it extends the observer patten to support sequences of data and/or events and adds operators that allow you to compose sequences together declaratively while abstracting away concerns about things like low-level threading, syncronization, thread-safety, concurrent data structures, and non-blocking I/O.
      - 의문
        - 옵저버 패턴에서 어떤 부분이 구체적으로 확장 되었는가?
        - 기존 옵저버 패턴은 data 외 event를 sequence를 지원하지 않았는가?
        - Observable을 통해서 아래 현상이 없어지는가?
          - 로우 레벨 스레딩? (어떠한?)
          - 동기화? (어떠한?)
          - 스레드 안정성? (어떠한?) 
          - non-blocking (어떠한?)
          - concurrent data structures (어떠한?)
 - Observables fill the gap by being the ideals way to access asynchronous sequences of multiple items.
  - synchronous, Iterable로 순차적으로 실행하면 처리
  - asynchronous, Observable을 통해서 구독으로 처리
- It is sometimes called "functional reactive programming" but this is a misnomer(부적절하다). ReactiveX maybe functional, and it maybe reactive, but "functional reactive programming"is a different animal.
  - 왜 maybe functional? 
  - 왜 maybe reactive?
  - functional reactive programming이 잘못된 표현이라고 주장하는 이유는?
    - One main point of difference is that functional reactive programming operates on values that change continuously over time, while ReactiveX operates on discrete values that are emitted over time. (반응형 함수형 프로그래밍은 시간이 지남에 따라 지속적으로 변화하는 값에 대해 작동하지만 <지속적으로 이전과 동일한 값을 의미하는가?>, ReactiveX는 시간이 지남에 따라 방출되는 Discrete values에 대해 작동함)

      - 자세한 내용
        - https://github.com/conal/talk-2015-essence-and-origins-of-frp
  - reactive의 개념이 무엇일까?

### Why Use Observables?
  - The ReactiveX Observable model allows you to treat streams of asynchronous events with the same sort of simple(간단한 종류), composable (조합 가능한 작업) that you use for collections of data items like arrays.
  - It frees you from tangled(복잡한, 뒤엉킨) webs of callbacks, and thereby(그렇게 함으로써, 그것 때문에) makes your code more readable and less prone(덜 경향이 있는) to bugs.

### Observables Are Composable (전반적으로 이해가 안됨. Java Futures 는 순서 교체가 가능한 Iterable 개념으로 짐작함.)
  - Techniques like Java Futures are straightforward(복잡하지 않은) to use for a single level of asynchronous execution but they start to add non-trivial complexity(사소한 복잡성) when they're nested(중첩 될 때 사소한 복잡성이 추가되기 시작한다).
    - 의문
      - Java Futures를 잘 모름. 
        - (문서) https://docs.oracle.com/javase/7/docs/api/java/util/concurrent/Future.html
  - It is difficult to use Futures to optimally compose conditional asynchronous exceution flows -조건부 비동기 실행 흐름을 최적으로 구성하는 것은 어렵다(불가능)- (or impossible, since latencies of each request vary(서로 각각 다르다) at runtime - 불가능한 이유는, 지연 시간은 런타임에 따라 다르기 떄문이다). 
      - 참고
          - https://gist.github.com/benjchristensen/4671081#file-futuresb-java-L163
  - This can be done, of course, but it quickly becomes complicated-복잡한- (and thus error-prone, 오류가 발생하기 쉽다) or it prematurely blocks(조기에 막는다) on Future.get(), which eliminates(없애다. 제거하다) the benefit of asynchronous execution.
      - 전반적으로 이해가 안됨
      - 의문
        - Futures가 비동기의 이점을 막는 요소는 무엇이 있을까? 
  - ReactiveX Observables, on the other hand, are intended for composing flow(합성 흐름) and sequences of asyncronous data.
      - 참고 
          - https://github.com/ReactiveX/RxJava/wiki/#composition

### Observables Are Flexible
  - ReactiveX Observables supports not just the emission(배출) of single scalar values (as Futures to), but also of sequences of values or even infinite streams.
  - Observable is a single abstraction(단일 추상화 객체) that can be used for any of these use cases(사용 사례).
  - An Observable has all of the flexibility(유연함) and elegance(우아함) associated with its mirror-image cousin the Iterable.
  - [!img2](./imgs/2.png)
  
### Observables Are Less Opinionated(독선적인)
  - ReactiveX is not biased(편향된) toward(...쪽으로) some particular source(특정 소스) of concurrency or asynchronicity.
  - Observables can be implemented using(...를 사용하여 구현할 수 있습니다) thread-pools, event loops, non-blocking I/O, actors (such as from Akka), or whatever implementation suits your needs, your style, or your expertise(전문지식). Client code treats all of its interactions with Observables as asynchronous, whether your underlying(근본적인) implementation is blocking or non-blocking and however you choose to implement it.
  - How is this Observable implemented?
    - ```
        public Observable<data> getData();
      ```
        - does it work synchronously on the same thread as the caller?
        - does it work asynchronously on a distinct(뚜렷한) thread?
        - does it divide its work over(한쪽에서 다른 사물이 덮이도록) multiple threads that may return data to the caller in any order(어떤 순서)?
        - does it use an Actor (or multiple Actors) instead of a thread pool?
        - does it use NIO(무슨 약자?) with an event-loop to do asynchronous network access?
        - does it use an event-loop to separate the work thread from the callback thread?
    - From the Observers's point of view, it doesn't matter!
  - And importantly: with ReactiveX you can later change your mind, and radically(본래) change the underlying nature of your Observable implementation, without breaking the consumers of your Observable.

## Callbacks Have Their Own Problems
  - Callbacks solve the problem of premature(정상 또는 예상 보다 이른) blocking (조기 차단 문제?) on `Future.get()` by not allowing anything to block.


## 함수형 프로그래밍
1. 코딩 중 오류의 소지가 될 수 있는 변수 사용 지양
   - 스레드의 동시접근에 의한 오류 또는 교착 문제에서 자유로운(?) 코딩 가능
2. 순수 함수 사용
    - 함수들의 연쇄 작용
3. 선언형 프로그래밍
4. 다양한 함수의 기능과 활용법을 아는 게 좋음
   
## reactive x
1. Observable
   1. 일련의 값들을 발행
   2. 관찰 할 수 있는 대상
2. Operators
   1. 순수함수 목록
   2. Pipe 형식
3. Observer
   1. Pipe를 구독하며, 값이 발행되면 작업을 실행
   2. 발행물을 기다림 (구독하다, 반응하다)

## 로대쉬, 자바스크립트 표준과 다른점?
1. 1차원적인 값 뿐 아닌 연속된 값들의 흐름을 stream으로 관리(파이프라인을 통해)
   1. 시간의 흐름
   2. 사용자의 동작
   3. 네트워크 요청의 결과
2. stream을 통해 요소를 배열처럼 관리함

## ajax 직렬 예
  ```
    const {range} = rxjs
    cosnt {ajax} = rxjs.ajax
    const {mergeMap, toArray, pluck, retry} = rxjs.operator

    range(1,20).pipe(
        mergeMap(index => ajax(
            'https://127.0.0.1:3000/people/quater-error/${index}'
        )).pipe(
            pluck('response', 'first_name'),
            retry(3)
        )
        , 4),
        toArray()
    ).subscribe(console.log)
  ```
  - 설명
    - range
      - 1에서 20까지 숫자를 스트림으로 생성
    - mergeMap 
      - stream에서 나온 각 값마다 이를 사용하는 지정된 또다른 스트림을 만들어낸다
      - 이 스트림들이 동시에 실행되도록 한다
      - 한 번에 실행될 수 있는 갯수를 4개로 제한
    - pluck
      - response 항목의 first_name 항목을 추출
    - retry
      - 최대 3 번 재실행
    - toArray
      - 스트림의 모든 값이 발행 되기를 기다렸다가 그것들을 한 배열에 묶어 내보내게 된다

## 프롬프터 만들기
1. 키보드로부터 스트림을 만든다
  ```
    // 방향키만 1 또는 -1로 치환한 스트림
    const keypress$ = fromEvent(document, 'keydown').pipe(
      pluck('key'),
      filter(k, k.includes('arrow)),
      map(k => {
        return {
          ArrowDown:1,
          ArrowUp:-1,
          ArrowLeft:-1,
          ArrowRight:1
        }[k]
      })

    )
  ```
  - 키보드 이벤트를 생성
  - key 항목 뽑음
  - arrow 만 뽑음
  - 방향키에 따라 -1 또는 1로 치환
2. 스크롤에 의한 스트림
  ```
  // 마우스 스크롤을 1초 간격으로 끊은 뒤
  // 방향에 따라 1 또는 -1로 치환한 스트림
  const scroll$ = merge(
    fromEvent(document, 'mousewheel),
    fromEvent(document, 'wheel)
  ).pipe(
    throttleTime(1000),
    map(s => s.deltaY > 0 ? 1 : -1)
  )
  ```
  - 브라우저 별 mousewheel, wheel로 처리
    - 스트림 두 개 만들고 merge를 통해 병합
  - throttleTime
    - 만일 둘 다 받는 브라우저의 경우 or 트랙패드에 대한 예외처리
    - 주어진 시간에 한 값만 통과하도록 한다
    - 초당 1회만 이벤트에 반응

3. 위 1, 2를 하나의 스트림으로 병합
  ```
    // 위의 키보드 스트림과 마우스 스트림
    // 그리고 최초값 0을 병합한 스트림
    const input$ = merge(
      keypress$, scroll$
    ).pipe(startWith(0))
  ```
  - merge
    - 하나의 스트림으로 병합
  - startWith
    - stream의 시작 부분에 프로그램 실행 시 바로 발행하는 값을 넣을 수 있다
    - 0 이라는 값을 통해 첫 화면을 띄운다

4. lines$
  ```
    const lines =[
      "반응형 프로그래밍 반응형 프로그래밍",
      "꿀잼 꿀잼 꿀잼 꿀잼"
    ]

    const spaces = 10

    // 출력할 첫, 마지막 라인의
    // 각각 앞뒤 공백으로 들어갈 스트림
    const spaces$ = range(0, spaces).pipe(mapTo(''))

    // 프롬프터에 표시할 행들을 앞뒤 공백과 이어붙인 뒤
    // spaces + 1개 라인, 1줄 간격으로 묶어
    // 배열 형태로 반환하는 스트림
    const lines$ = concat(
      spaces$, from(lines), spaces$
    ).pipe(
      bufferCount(spaces * 2 + 1, 1),
      skipLast(spaces * 2),
      toArray()
    )
  ```
  - 프롬프터는 포커스 문장의 위, 아래를 빈 문자열 여러 라인이 붙도록 할 예정
  - concat
    - 스크립트 앞뒤에 이어 붙인다
  - bufferCount
    - 스트림을 앞의 인자만큼 뗴어내고 이를 뒤의 인자만큼 이동하면서 반복 (?)
  - skipLast 
    - 끝에서 N개를 제거해줌
  - toArray
    - 스트림의 모든 발행물들을 하나의 배열에 넣어서 반환

4. 최종
  ```
   // 인풋 스트림의 입력에 따라 라인 스트림의
   // 1줄 간격으로 묶인 배열을 하나씩 발행하는 최종 스트림
  const final$ = inputs$.pipe(
    scan((acc, cur)=> {
      return Math.main(Math.max(acc += cur, 0), lines.length -1)
    }),
    mergeMap(cursor=> {
      return lines$.pipe(
        map(buffereds => buffereds[cursor])
      )
    })
  )
  ```
  - inputs$에서 발행되는 값들을 scan이란 오퍼레이터를 사용해서
    각 값마다 이전에 나온 모든 값들과의 누적값을 발행하도록 한다
  - 최댓갓 최솟 값 제한

## 질문
  - 반응형 프로그래밍?
  - 반응형 프로그래밍과 ReactiveX는 차이가 존재하는가?
  - Observable이 어떻게 구현되어 있을까?
  - actor란?
  - NIO는 무슨 약자임?
  - thread pool과 actor의 차이?
  - Concurrency와 Asynchronicity의 차이?
  - Push와 Pull의 차이점?
  - Work thread와 callback thread의 차이?
  - Scalar value?
    - 하나의 숫자로만 표시되는 양.
    - 즉, 단위 크기만 있는 물리량.
    - 참고
      - https://ko.wikipedia.org/wiki/%EC%8A%A4%EC%B9%BC%EB%9D%BC_(%EB%AC%BC%EB%A6%AC)
  - 멀티 캐스팅? 캐스팅?
    - 멀티 캐스트
      > 한 번의 송신으로 메시지나 정보를 목표한 (불특정 다수가 아닌, 특정 수신 대상)여러 컴퓨터에 동시에 전송하는 것.
      - 참고
        - http://www.terms.co.kr/broadcast.htm
        - https://ko.wikipedia.org/wiki/%EB%A9%80%ED%8B%B0%EC%BA%90%EC%8A%A4%ED%8A%B8
        - https://m.blog.naver.com/PostView.naver?isHttpsRedirect=true&blogId=eqqus&logNo=140188701607
  - 브로드 캐스트
    - 참고
      - http://www.terms.co.kr/broadcast.htm
  - 동기, 비동기와 블로킹, 논블로킹 차이 (추후 별도 문서로 분리)
    - 동기, 비동기는 프로세스의 수행 순서 보장에 대한 매커니즘
    - 블로킹, 논블로킹은 프로세스의 유휴 상태에 대한 개념
    - 두 개념은 직접적인 관련은 거의 없고, 단지 조합하여 사용되는 것 뿐이다.
    - 참고
      - https://evan-moon.github.io/2019/09/19/sync-async-blocking-non-blocking/

## 참고
  - 인프런 얄코-자바스크립트-reactivex 강의
  - (reactiveX 공식 도큐먼트, Resource) https://reactivex.io/tutorials.html

# RxJS 한번 배워보실래요?
- 요약한 아티클
  - <https://yozm.wishket.com/magazine/detail/1753/> (테오님, RxJS 한번 배워보실래요?)

- 자바스크립트
  - 시간, 비동기 다루기 어려움.
  - 객체지향과 함수형 프로그래밍이 적절히 잘 섞을 수 있음.
- RxJS
  - 비동기 다루기에 적합
  - 단순히 특정 기능을 쉽게 사용할 수 있는 유틸성 라이브러리가 아님.
  - 개발과 비동기의 관점의 패러다임이 변경되어야 할 만큼 러닝커브가 굉장히 높음.

## 1. RxJS 맛보기 - 희망편

- 공식홈페이지 소개 요약
  - 관찰 가능한 시퀀스를 사용하여 비동기 및 이벤트 기반 프로그램을 구성하기 위한 라이브러리.
  - 핵심 유형인 Observable(Array) , 위성 유형(Observer, Scheduler, Subjects), 메소드(map, filter, reduce 등)에서 영감을 받은 연산자를 제공하여 비동기 이벤트를 컬렉션으로 처리할 수 있도록 한다.
  - ReactiveX는 Observer 패턴과 Iterator 패턴을 결합 및 함수형 프로그래밍을 컬렉션과 결합을 통해서, 이벤트 시퀀스를 관리하는 이상적인 방법에 대한 요구를 충족한다.
- 핵심 키워드
  - 관찰 가능한 시퀀스, 비동기, 이벤트, Observable, Observer, Subjects, 메소드, 연산자, Observer 패턴, Iterator 패턴, 함수형 프로그래밍, 컬렉션
- 한줄 요약
  - 이벤트, 비동기, 시간을 마치 Array 처럼 다룰 수 있게 만들어주는 라이브러리
- 선언적 프로그래밍 예시 (함수형)

   ```

    const sum = points // 점들 중에서
      .filter(([x,y])=> x> 0 && y > 0) // 이중 1사분면에 있는 값을 추려서
      .slice(0, 5) // 5개만 골라서
      .map(([x,y]=> Math.sqrt(x*x + y*y)) //원점과의 거리들의
      .reduce((a, b)=> a +b) //총합
  ```

- 위 예시를, 배열이 아닌 마우스를 통한 입력으로 받는 경우 (선언형 프로그래밍이 아닌 방식으로)

  ```
    let sum = 0;
    Let count = 0;
    window.onclick = function(event) {
      const [x,y] = [event.pageX - screen.width/2, event.pageY - screen.height/2]

      // 1사분면에 있는 값만
      if (x > 0 && y > 0) {
        // 원점과의 거리의 합을 더해서
        sum += Math.sqrt(x*x + y*y)
        count++ 
      }

      if(count ===5) {
        window.onclick = null // 이벤트를 더 이상 입력받지 않도록 한다.
        console.log(sum)
      }

    }
  ```

  - 해당 코드를 선언형으로 작성할 수 없음. 이유는 자바스크립트에서는 이러한 객체와 메소드는 존재하지 않는다.
  - 일반적인 자바스크립트만을 사용한다면, 이벤트와 시간을 다루기 위해서는 callback, setTimeout 등의 코드들로 작성게 되고, 이는 복잡한 코드(예시, 콜백헬)를 만들게 된다.
- 이벤트를 Array 처럼 다룰 수는 없을까?
  - 자바스크립트 기본 객체에는 이러한 API가 없다.
  - 하지만 선언적으로 작성하지 못할 이유 또한 없다.
    - `Event` 또한 `Array`처럼 동일한 타입의 데이터를 여러 개 가지고 있다.
    - 단 다른 점은, 미리 존재하는 값이 아닌 비동기적으로 아직 존재하지 않는 부분이다.
    - 이러한 부분은 callback으로 해결할 수 있다.
    - 선언적 프로그래밍 또한 callback을 사용하므로, 결국 같은 형식으로 작성할 수 있다.
- 예시, (작동 안되는 코드) callback을 활용하여서, 위 예시를 선언적 프로그래밍으로 리팩토링

  ```
    // points를 clicks에서 추출 함. 
    // 핵심은, 어떻게 비동기적이며 시간 차이가 존재하는 clicks를 map이 가능한 Array로 변경할 수 있는가이다.
    const points = clicks.map(event => [event.pageX - screen.width/2, event.pageY, screen.height/2] )

    // 오 같은 코드다?
    const sum = points // 점들 중에서
      .filter(([x,y] => x > 0 && y > 0) // 이중 1사분면에 있는 값을 추려내
      .slice(0, 5) // 5개만 골라서
      .map(([x,y] => Math.sqrt(x*x + y*y)) // 원점과의 거리들의
      .reduce((a+ b) => a+ b) // 총합
  ```  

  - 코드 상 주석의 핵심 부분을, 이벤트를 다루는 새로운 객체인 Observable을 만들고 Array와 같은 메소드를 추가한다면, 이벤트를 선언적으로 Array를 다루듯이 만들 수 있는 라이브러리인 Rx가 탄생한다.
- 예시, 위 예제를 RxJS를 적용

  ```
    // click을 통해 Observable
    cosnt clicks: Observable<MouseEvent> = fromEvent(window, “click”)

    // (RxJS 스펙에 존재하는) fromEvent 코드는 어떻게 생겼을까?
    const fromEvent = (target, type) => new Observable(observer => {
      target.addEventListener(type, (event) => observer.next(event))
      return ()=> target.removeEventListener(type)
    })
  ```

- Observable은 Array와 Promise의 상위호환이다.

  - Observable을 통해서, 여러 Event를 마치 Array처럼 다룰 수 있는 새로운 객체 타입을 얻을 수 있다.
  - Observable은 Promise의 상위호환이다
    - 의문
      - 어떤 부분에서?
      - 트레이드 오프는?
  - Promise로 만들 수 있는 값은 Observable 방식으로도 만들 수 있다.
    - 예시

      ```
        // Promise는 통신이나 시간과 같은 비동기로직을 다루기 쉽게 만들어줌.
        // Promise는 비동기 로직을 값으로 만들 수 있음.
        const fetchXXX = (props) => new Promise((resolve, reject) => {
          fetch(url, props).then(res => resolve(res), err => reject(err))
        })

        // (성립!) Observable은 Promise를 대신 쓸 수 있다.
        const fetchXXX = (props) => new Observable(observer => {
          fetch(url, props).then(res => observer.next(res), err => observer.error(err))
        })

        // 핵심
        // (성립 안되는 슈도 코드임을 참고) 
        // 반대로 Promise는 Observable이 될 수 없음.
        const fromEvent = (target, type) => new Promise(resolve => {
          // Promise는 여러 개의 값을 받을 수 없다.
          target.addEventListener(type, (event) => resolve(event))

          // Promise는 종료 시 clean up을 할 수 없다.
          return () => target.removeEventListener(type)
        })
      ```

      - 의문
        - 만약 프로미스로 해당 문제를 해결 시 어떻게 clean up을 하는가?
        - Promise로 Observable 같은 스트림을 만들 수 있는가?

- 기본적인 자바스크립트에서는, Array는 비동기를 다룰 수 없지만 여러 개의 값을 다룰 수 있는 반면, Promise는 비동기를 다룰 수 있지만 오직 하나의 값만 다루 수 있다.
- Observable은 (위) 2가지 역할을 동시에 수행할 수 있습니다.
  - 여러 값을 다루면서 비동기를 다룰 수 있음.
  - Array와 Promise와 같이 메소드를 가지고 있음.
  - **이러한 성질을 통해 비동기를 선언적 방식으로 개발할 수 있게 된다.**

- 이전 내용 요약
  - RxJS는 Array와 Promise 성질을 모두 가진 이벤트를 다루는 새로운 객체 타입 Observable을 제공하는 라이브러리이다.
  - 이 객체는 Array의 메소드(map, filter)와 같은 연산자를 제공하며, 이를 통해 비동기 이벤트를 컬렉션 다루듯이 처리할 수 있게 만들어준다.
  - RxJS로 비동기 이벤트와 시간을 Array처럼 다룰 수 있는 경우까지도 선언형 프로그래밍이 가능해진다.
- 질문: RxJS로 뭘 할 수 있는가?
  - 답변: 비동기 이벤트를 컬렉션 다루듯이, 즉 Array를 다루듯이 선언적으로 개발 할 수 있다.
    - 예시, 트리플 클릭 구현
      - 요구사항:  0.25초 이내에 클릭한 개수가 3개라면 트리플 클릭인 코드

        ```
          const tripleClicks$ = fromEvent(window, “click”)
            .bufferTime(250) // 0.25초 간
            .filter(clicks => clicks.length ===3) // 클릭이 3개면
            .subscribe(…)
        ```

      - 만약 해당 코드를 eventListener와 setTimeout 등을 이용해서 작성하려면 매우 막막함.
        - 코드 생산 비용이 높아짐.
        - 파편화, 사이드를 없애기 위한 전략으로 캡슐형을 만족시키는 객체지향을 적용 해야함. 그렇지 않다면 코드 관리 비용이 매우 높아짐.
- 그 외 예시
  - 요구사항
    - 서버에게 API 요청 시 5초 이내에 응답이 없으면 실패로 간주
    - 재시도 시 1초 간격으로 재시도
    - 3번 연속으로 실패 시 별도 처리
  - RxJS로 구현 시

      ```
        request$
          // 아직 진행중이면 skip
          .exghustMap(params => post_some_request(params) // 서버와 통신
          .timeout(5000) // 5초 간 응답이 없으면 에러로 취급
          .retryWhen(error => error.delay(1000).take(3)) // 에러가 발생 시 1초 지연을 최대 3번까지
          . subscribe(…)
      ```

- 알 수 있는 사실
  - 구현 난이도가 비교적 높은, 이벤트와 비동기 그리고 시간을 복잡한 코드가 아닌, 값으로 다루기 되는 시각을 가지게 되면 훨씬 더 프로그램을 단순한 시각에서 개발할 수 있게 해준다.
  - 뿐만 아니라, Value와 Array와 Promise, 그리고 Observable 모두 (비)동기 컬렉션,즉 스트림으로 추상화하여 생각할 수 있다. (Stream으로 일반화)
  - Value는 그냥 값이고, Array는 동기 컬렉션, Promise는 비동기 값, Observable은 비동기 컬렉션으로 모든 것이 스트림으로 일반화 될 수 있다.
  - 프로그램을 결국 스트림으로 다루는 것으로 귀결시키는, 심플한 반응형 프로그래밍 패러다임으로 개발할 수 있게 된다.
- RxJS 활용 예시: 웹에서 화상 회의 서비스를 개발한다고 가정해보자.
  - 사전에 WebRTC, 카메라, 마이크 데이터를 가져오기 위한 로컬 미디어 스트림 API, 미디어 장비의 조회나 권한 API까지 알아야 한다.
    > 실제 개발 시 API를 배우고 학습 시 많은 시간을 소비한다.
  - 그러나, 실제 프로그램을 개발시 복잡해지고 어려워지는 이유는 API가 어려워서가 아니다.
  - 실제로 기획서의 요구사항을 구현하는 동작들이 언제, 어떤 조건으로 발동하는 지 정하는 시나리오 구현의 비중이 훨씬 크다.
  - 이러한 동작은 대부분이 비동기 형태로 발생한다.
  - 즉 개발하는 앱이 복잡해지는 이유는, 비동기의 …하면 …이라는 구현이 많아서 이다.
  - RxJS는 이러한 …하면 …의 구현을 로직 조합이 아니라 값으로 처리할 수 있게 해준다.
  - 뿐만 아니라, 여러 Operator을 제공하면서 적절한 조합을 통해서, 개발자가 원하는 형태의 코드를 직관적이며 단순한 선언적으로 작성할 수 있도록 만든다.
    - 의문
      - rxjs 방식의 선언적 프로그래밍은 상대적으로 직관적이며 단순함을 만족하는가?
        - **Array는 절차형이 아니라 함수형으로 다루면 코드가 간결해지듯이, 비동기 로직도 데이터로 취급해서 함수형으로 다루면 코드가 간결해진다.**
- RxJS는 어떻게 쓰는 걸까?
  - Array를 다루기 위해서는 map, filter, reduce 뿐만 아니라 every, concat, fill, join 등 다양한 Array를 다루는 Method들이 존재한다.
  - 마찬가지 개념으로 Observable은 비동기 Array의 형태이며, 이러한 데이터 형태를 다루는 여러 가지 Operator들이 존재한다.

- 실전 예시
  - 요구사항
    - 참가자 입장 시 ‘OO님이 참여하였습니다.’ 토스트 팝업을 띄워주세요. 
    - 단, 여러 명이 동시에 입장하면 2초 동안 모았다가 ‘OO 외 2명이 참여했습니다.’ 라는 식으로 표기해주세요.

    ```
      const participants$: Observable (Array<Participants) = …

      participants$
        .distintUntilChanged((a, b => a.length === b.length) // 참여자 명수가 변할때만,
        .bufferCount(2,1) // 2개씩 짝지어 전후를 비교하여
        .filter(([prev, curr])=> curr.length > prev.length) // => 새로운 참여자가 입장했는가?

        // 전 후 데이터를 비교하여 새롭게 참가한 사람만 추려내어
        .map(([prev, curr]) => array_diff(prev, curr, p=> p.uid))

        // 2초간 모아보고 새로운 참가자가 있으면
        .bufferTime(2000)
        .filter(x=> x.length)

        // 동시 참가자 수에 따라 토스트 팝업 출력
        .tap(participants => {
          if(participants.length ===1) show_toasts(“OO님이 입장”)
          else show_toast(“OO님 외 N명 입장”)
        })
    ```

- 위 내용 요약
  - 비동기 로직을 Data로 다룰 수 있다.
  - 모든 로직을 스트림과 함수형으로 쉽게 작성할 수 있다.
  - Pull 패러다임에서 Push 패러다임으로 코딩할 수 있게 된다.

## 2부. RxJs를 배우며 어려웠던 것들 - 현실편

- Pipe
  - RxJS 5.5부터 도입됨.
  - RxJS의 초창기는 Event를 Array처럼 다루는 개념으로 시작됨.
    - Array의 Method 문법과 많이 닮음
  - 이후 module과 번들 개념이 도입되고, RxJS의 기본 덩치가 커짐에 따라 Method 방식은 Tree-Shaking에 불리하다는 문제가 있다.
    - 의문
      - 구체적으로 어떤 부분에서 Tree-Shaking 문제가 발생하는가?
        - 답변: 바로 아래 예제 참고
  - 그래서 각 Method를 함수로 만들어서 함수형 프로그래밍의 파이프방식을 차용하여, 다음과 같은 방식으로 코드를 작성할 수 있도록 만들었다.
  - 기존 Method 방식 (dot-chain 방식)

    ```
      // 기존 Method 방식 (dot-chain 방식)
      import {Observable} from ‘rxjs’

      const tripleClick$ = Observable.fromEvent(window, “click”)
        .bufferTime(250)
        .filter(clicks => clicks.length ===3)
        .subscribe(…)
    ```

  - Pipe Method 방식

    ```
      import {fromEvent, bufferTime, filter} from ‘rxjs’

      const tripleClicks$ = fromEvent(window, “click”).pipe(
        bufferTime(250),
        filter(clicks => clicks.length ===3),
      ).subscribe(…)
    ```

- Method가 아닌 Operator 함수로 분리하면 import 한 만큼만 번들에 포함할 수 있다.
  - 장점
    - 조금 번거롭고 코드의 가독성을 희생되어도 사용하지 않는 Operator를 코드에 포함하지 않도록 하여서, 번들 크기를 줄일 수 있게 된다.
    - Custom한 Operator를 Method에 포함하지 않고 얼마든지 만들 수 있다.
  - 단점
    - 조금 번거롭고, 가독성이 희생된다.
    - 타입스크립트와 호환이 좋지 않다.
      - 의문
        - 구체적으로 어떤?
- Pipe 연산자의 대안으로, `Pipeline Operator |>`가 있다.
  - 가독성의 문제는, 결국 문법의 문제이다.
  - JS에 새로운 문법을 도입하여, 더 간결한 형태로 함수형 프로그래밍을 활용할 수 있는 Operator를 제안한다.
  - 예제

    ```
      // Pipe Operator란?
      const lowercase = (str) => str.toLowerCase()
      const capitalise = (str) => str.slice(0, 1).toUppercase() + str.slice(1)
      const wow = (str) => str + “!”

      wow(capitalise(lowercase(“hEllo wORLD”))) // Hello World!
      // => 함수를 연속해서 호출을 하려니 적용되는 순서가 반대가 되어 헷갈린다.

      “hEllo wORLD” |> lowercase |> capitalize |> wow // Hello World!
      // => 값이 함수를 통해 전달되는 코드를 작성할 수 있게 되어 함수 조립을 훨씬 더 직관적인 코드 형태로 작성할 수 있다.
    ```

- 만약 RxJS에서,Pipeline Operator를 쓸 수 있게 된다면, RxJS Method가 아닌 함수로 분리된 장점을 전부 취하면서도 훨씬 더 함수형스러운 방식으로 코딩이 가능해진다.
  - 예제 (문법적으로 지원 안됨)
    ```
      // Pipeline Operator 방식
      import {fromEvent, bufferTime, filter} from ‘rxjs’

      const tripleClick$ = fromEvent(window, “click”)
        |>bufferTime(250)
        |>filter(clicks => clicks.length ===3),
        |>subscribe(…)
    ```

- Observable과 Pipeline은 아직도 논쟁 중이다.
  - 이전에는 Promise가 표준 API가 아니였다. 
  - 그 당시에는 자바스크립트가 싱글 쓰레드의 이벤트 루프 방식을 택하면서 필연적으로 비동기처리를 콜백으로 해야만 했기 때문에, 코드가 Callback 지옥이 되었고, 추가로 예외처리까지 더해지면서 복잡한 코드가 만들어지는 경향이 컸다.
  - Promise 도입 후, 비동기를 다루는 방식이 획기적으로 간단해졌다.
  - 이후 async, await 문법도 생겨났다.

- 사실 Operator가 중요한 게 아니다.
  - Observable이 더 중요하다.
  - 이미 fromEvent, timer, ajax는, 대부분 프레임워크 단에서 이벤트 핸들러등을 통해 처리되고 있고, 사실 시간을 다루는 경우는 많지도 않으며, Ajax의 경우 대체로 데이터를 1번만 전달해서 Promise로도 충분했다.
  - 현실적으로 RxJS를 현재 웹 프레임워크에서 어디서부터 적용해야 할 지 찾는 것이 참 어렵다.
- 일단 Source로 만들 수 있는 것부터 찾자
  - 예제, RxJS를 Realtime database인 Firebase에 연동하기
    - RxJS 연동 전

      ```
        // Firebase는 이런식으로 Callback과 API를 조합해서 데이터를 사용해야해서 복잡한 코드를 만들어야 했다.
        const ref = firebase .database().ref(path)

        ref.on(“value”, snapshot => {
          const value = snapshot.toJSON()
          // doSomething here
        })

        ref.off()```
          -RxJS 연동 후

        const fromFirebase = (path: string) => new Observable(observer => {
          const ref = firebase.database().ref(path)

          ref.on(“value”, snapshot => {
            const value = snapshot.toJSON()
            observer.next(value)
          })

          return () => ref.off()
        })
      ```

        - RxJS로 Firebase API를 캡슐화한 이후로, 더이상 로직이 아니라 값으로 다룰 수 있게 되었다.
- 연관된 computed Value를 만들거나 참가자가 새롭게 들어왔다는 것을 알아내는 이벤트도 데이터를 기준으로 아주 쉽게 작성할 수 있다.
  - 예제

      ```

        const users_in_chat$ = fromFirebase(‘/chat/users’).pipe(
          map(users => Object.values(users))
        )

        const num_users_in_chat$ = users_in_chat$.pipe(
          map(users => users.length),
          distinctUntilChanged() // 같은 값이면 중복 전달 방지
        )

        num_users_in_chat$.pipe(
          bufferCount(2,1), // 예전 값을 가져와서
          filter((prev,curr]) => curr > prev), // 참가자 수가 커진 상황에서
          tap(()=> {  //새로운 참가자가 들어왔다! })
        ).subscribe()

      ```

# Hot? Cold?

- RxJS로 Source를 만들 수 있게 되면, 기존의 복잡한 콜백 로직 등을 모두 Observable의 세계로 전환하여 선언적으로 코드를 다룰 수 있다. (더 고급스러운 코드를 작성할 수 있게 된다)

- Promie의 경우 함수를 사용하는 순간 이미 실행이 되며 데이터가 공유되는 `Hot` 방식이다.
- 예제

    ```

      // 생성 시점에 이미 실행이 되어 1초 뒤 Promise에 값이 보관된다.
      const p = new Promise(resolve => {
        setTimeout(()=> resolve(‘promise!’), 1000)
      })

      // 아직 값이 없으니, 기다렸다가 1초 뒤 값이 출력이 도니다.
      p.then(res => console.log(res))

      // 2초 후에 요청을 한다면
      setTimeout(() => {
        // 1초 대에, 이미 Promise는 보관이 되어 있으므로, 호출 즉시 출력이 된다.
      }, 2000)

    ```

- 하지만 RxJS는 함수형 프로그래밍에 근간을 두고 있기 때문에, 지연평가(Lazy evaluation) 방식을 사용한다.
  - Observable의 세상에서는 생성 시에 선언만 하고, 구독이 요청한 시점에 해당 코드를 실행하는 Cold 방식을 가지고 있다.
  - 예제

      ```

        // 생성을 했지만, 실행은 시키지 않고 선언만 해둔 상태이다.
        const p$ = new Observable(observer => {
          setTimeout(()=> observer.next(“observable!”), 1000)
        })

        // 구독 요청을 헀으니 이 함수가 실행된 시점부터 1초 뒤 값이 출력이 된다.
        p$.subscribe(res => console.log(res))

        // 2초 후에 요청을 한다면
        setTimeout(() => {
          // 2초 뒤 구독되므로, 이 때 별도의 observer가 생성이 되기 때문에, 콘솔 로그는 바로 출력이 되지 않고, 추가로 1초를 더 기다린 후 출력된다..
          p$.subscribe(res => console.log(res))
        }, 2000)

      ```

- 즉, Observable은 데이터를 요청할 때마다 함수가 실행되어 결과를 전달해주는 방식이므로, 여러 군데에서 같은 값을 사용하면 데이터를 공유하지 않고, 그때마다 선언된 함수를 호출하는 방식이 된다.

  - 이 사실을 모르면, API를 Observable로 만들고 난 뒤 여러 군데에서 해당 데이터를 사용했을 때 API 콜을 중복으로 계속 호출되는 문제가 발생한다.
  - Cold는, Animation 등에 적합하다.
  - Hot은, 상태 관리와 같이 API를 다루는 데이터 등에 적합하다.
- RxJS는 `Cold한 Observable을 Hot하게 만들기 위한 과정(Multicasting)`이 상당히 복잡하다.
- 만약 Observable의 기본이 Cold인 상황에서, Multicasting을 사용하지 않고 Hot Observable을 만들려면 어떻게 해야 할까?
  - Subject, behaviorSubject...
  - Hot Observable 전용 객체인, Subject와 BehaviorSubject가 존재한다.
  - Hot이 필요하다면 복잡한 Multicasting보다는, Subject를 보다 추천한다.
  - 프로그램에서 값을 계속 공유해서 사용해야 하는 경우에는,
    - 1) 이벤트나 동작과 같이 시점이 중요한 경우 -> Subject
    - 2) API 등의 동작 결괏값을 계속 공유해야 하는 경우 -> BehaviorSubject
- 예제, Firebase의 API를 BehaviorSubjcct를 적용하기

  ```

    const memo = Object.create(null)

    export const fromFirebase = (path: string, initValue: T) => {
      const r$ =  memo[path] || new BehaviorSubject(initValue)
      const ref = firebase.database().ref(path)

      ref.on(‘value’, snapshot=> {
        const value = snapshot .toJSON()
        r$.next(value)
      })
    }
  ```
    - 특히 Subject와 BehaviorSubject는 프론트엔드 상태관리를 만들기 위해서 정말 중요한 개념이다.

- 마무리
  - 프론트엔드 프로그래밍 시 특정 기능을 구현하는 것보다, 사용자들의 동작과 조건에 맞춰 적절히 연결하는 것이 더 복잡하다.
  - 이러한 연결 과정이 복잡한 이유는 비동기라는 문제가 있기 때문이다.
  - 비동기를 잘 다루는 것이 난이도가 높은, 고급 개발자로 가기 위해서 정복해야 할 분야이다.
  - RxJS는 비동기를 잘 다루기 위한 목적으로 만들어졌고, 특히 함수형 프로그래밍, 반응형 프로그래밍, 선언적 프로그래밍이라는 새로운 패러다임을 기반으로 하는 멋진 라이브러리이다.
  - 자바스크립트 라이브러리에서 웹 표준 API로 등록되기 위해 TC39에 계류되어 있는 라이브러리이다.
  - Everything is Stream.

- 의문
  - 위성 유형?
  - 컬렉션?
  - 지연평가?
- 요약한 아티클
  - <https://yozm.wishket.com/magazine/detail/1753/>

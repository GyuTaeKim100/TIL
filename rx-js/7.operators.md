# operators

## 1. 기본적인 배열 연산자들

- 목록
  - count, max, min, reduce, first, last, elementAt, dictinct, filter, tap

- 표준 JS와 차이점
  - 표준 JS는 Pipe가 아직 반영 안됨(논의 중).
    - RxJS는 Pipe로 여러 Operator를 조합 가능.
  - 표준 JS는 배열 Method가 제한적임.

1. 예제1) 산수관련, count max, min, reduce

    ```
        const {of} = rxjs
        const {count, max, min, reduce} = rxjs.operators

        const obs$ = of(4,2,6,10,8)
        
        // count
        obs$.pipe(count()).subscribe(x => console.log('count'+ x))
        // count 5

        // max
        obs$.pipe(max()).subscribe(x => console.log('max'+ x))
        // max 10

        // min
        obs$.pipe(min()).subscribe( x=> console.log('min' + x))
        // min 2

        // reduce
        obs$.pipe(
            // reduce 함수에 의해서 배열의 Iterable한 연산 결과가 acc에 대입됨.
            // 초기값: 0
            // acc: 누적값
            reduce((acc, x)=> {return acc + x}, 0)
        ).subscribe(x => console.log('reduce' + x))

    ```

2. 예제2) 선택 관련, first, elementAt, distinct

    ```
        const {from} = rxjs
        const {first, last, elementAt, filter, distinct} = rxjs.operators

        const obs$ = from(
            [9,3,10,5,1,10,9,9,1,4,1,8,6,2,7,2,5,5,10,2]
        )

        // first
        obs$.pipe(first()).subscribe(x => console.log('first' + x))
        // first 9

        // last
        obs$.pipe(last()).subscribe(x => console.log('last' + x))
        // last 2

        // elementAt
        obs$.pipe(elementAt(5)).subscribe(x => console.log('elementAt' + x))
        // elementAt 10 
        // 참고로, index는 0 부터 진행됨.

        // distinct
        obs$.pipe(distinct()).subscribe(x=> console.log('distinct'+ x))
        // 중복 값 제거하고, 동일한 값의 요소를 1번씩 만 출력한다. 
        
        // distinct 9
        // distinct 3
        // distinct 10
        // distinct 5
        // distinct 1
        // distinct 4
        // ... 이하 생략

        // distinct + count
        obs$.pipe(distinct(), count()).subscribe(x=> console.log(x))
        // 10 출력

        // 짝수 중에서 가장 큰 값 출력하기
        obs$.pipe(
            filter(x => x % 2 ===0),
            max()
        ).subscribe(x => console.log(x))
        // 10 출력

        // 5보다 큰 3번째 짝수 출력하기
        obs$.pipe(
            filter(x => x > 5),
            filter(x => x % 2 ===0),
            elementAt(2)
        ).subscribe(x => console.log(x))
        // 8 출력

        // distinct된 값들 중, 홀수들의 총 개수를 출력하기
        obs$.pipe(
            distinct(),
            filter(x => x%2 ===1),
            count()
        ).subscribe(x => console.log(x))
        // 5 출력
    ```

## 2. tap Operator

- 통과되는 모든 값마다 개발자가 지정한 특정 작업을 수행한다.
  - Debuging 활용 시, console.log를 출력하는 용도로 사용됨.
  - Side Effect를 유발하는 요소는 지양해야 한다.
- 발행 결과에 대한 Side Effect는 없음.

- 예제)

    ```
        const {from} = rxjs
        const {tap, filter, distinct} = rxjs.operators

        from(
            [9,3,10,5,1,10,9,9,1,4,1,8,6,2,7,2,5,5,10,2]
        ).pipe(
            tab(x => console.log('-------first tab' + x)),
            filter(x=> x%2 ===0),
            tab(x => console.log('----after filter), x),
            distinct(),
            tab(x => console.log('--중복 값 제거', x))
        ).subscribe(x => console.log('발행물'+ x))
    ```

## 3. Transformation oeprators

- Pipeline에 통과되는 값을 원하는 값으로 변경함.

### map

- 예제)

    ```
        const {of} = rxjs
        const {map} = rxjs.operators

        of(1,2,3,4,5)
        .pipe(
            map(x => x * x)
        ).subscribe(console.log)
    ```

- 예제)

    ```
        const {from} = rxjs
        const {map} = rxjs.operators

        from(
            [
                {name:'apple', price: 1200},
                {name: 'carrot', price: 800},
                {name: 'meat', price: 5000},
                {name: 'milk', price: 2400}
            ]
        ).pipe(
            map(item => item.price) // 참고로, 용도상 fluck이 더 적합함.
        ).subscribe(console.log)
        // 1200
        // 800
        // 5000
        // 2400
    ```

### fluck

- 예제)

    ```
        const {from} = rxjs
        const {pluck} = rxjs.operators

        const obs$ = from(
            [
                {name:'apple', price:1200, info: {category: 'fruit'}},
                {name:'carrot', price:800, info: {category: 'vegetable'}},
                {name:'pork', price:5000, info: {category: 'meet'}},
                {name:'milk', price: 2400, info: {category: 'drink'}}
            ]
        )

        obs$.pipe(
            pluck('info').pluck('category') // 또는 pluck('info','category')
        ).subscribe(console.log)
        // fruit
        // vegatable
        // meet
        // drink
    ```

### toArray

- Stream의 모든 발행물을 하나의 배열로 묶어서 출력한다.
- 예제)

    ```
        const {range} = rxjs
        const {toArray, filter} = rxjs.operators

        range(1, 50).pipe(
            filter(x=> x%3 ===0),
            filter(x=> x%2 ===1),
            toArray()
        ).subscribe(console.log)
        // 하나의 배열이 출력됨. 
    ```

### scan

- reduce 와 비교 시
  - reduce : 연산 최종 결과 1개만을 발행한다.
  - scan : 연산 과정과 결과를 모두 순차적으로 발행한다.
- 예제)

    ```
        const {of} =rxjs
        const {reduce, scan} = rxjs.operators

        const obs$ = of(1,2,3,4,5)
        
        obs$.pipe(
            reduce((acc, x) => {return acc + x}, 0)
        ).subscribe(x => console.log('reduce' + x))
        // reduce 15

        obs$.pipe(
            scan((acc, x)=> { return acc + x}, 0)
        ).subscribe(x => console.log('scan'+x))
        // scan 1
        // scan 3
        // scan 6
        // scan 10
        // scan 15
    ```

### zip

- 풀려 있는 zipper를 올릴 때, 분리된 양쪽이 결합됨을 상상한다.
- 2개 이상의 옵저버블 또한 결합이 가능하다.
- 각 배열 별 길이가 다른 경우, 길이가 짧은 배열을 기준으로, 결과물 또한 길이가 짧은 배열의 길이로 생성됨.
- 의문
  - concat과 차이점은?
    - 답: 예제1, 2를 보면 확인이 가능하다.
- 예제 1) Array 결합

    ```
        const {from, interval, fromEvent, zip} = rxjs
        const {pluck} = rxjs.operators

        const obs1$ = from([1,2,3,4,5])
        const obs2$ = from(['a','b','c','d','e'])

        zip(obs1$, obs2$).subscribe(console.log)
        // [1, 'a']
        // [2, 'b']
        // [3, 'c']
        // [4, 'd']
        // [5, 'e']
    ```

- 예제 2) Observable 결합
 - 참고로, Obervable에 pipe가 호출 된 결과물 또한 Observable이다.

   ```
    const {from, interval, fromEvent, zip} = rxjs
    const {pluck} = rxjs.operators

    const obs4$ = interval(1000)
    const obs5$ = fromEvent(document, 'click').pipe(pluck('x'))

    zip(obs4$, obs5$).subscribe(console.log)
    // interval 당 click 1개가 묶인다. (해당 예제는 Event 타이밍 조절을 목표로 함)
    // 주의 할 점은, 10초 간 click 안하면 interval이 10개 쌓이고, 마우스 click을 10연타 시 10개가 바로 출력이 됨.
    // 단 1초 안에 여러 번 click 시, 오직 1개의 click 만 출력됨. 그 후 시간의 흐름에 따라 이전의 click 결과가 순차적으로 출력됨.
    // 결론으로, 두 이벤트의 발행물을 묶어서 하나로 출력함.
   ```

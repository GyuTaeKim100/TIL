
# 비동기를 우아하게 처리하기 위한 Observable

## 1. Promise의 한계

- JS는 싱글 스레드로, 동시성 확보를 위해서 비동기 처리를 함.
  - 예시로, DOM Event, Ajax, Animations, 시간(Throttling/Debounce 등), Websockets, Workers 등이 존재함.
- 주로 비동기 처리 시, Callback을 활용해서 처리함.
  - 문제는 Callback Hell이 발생함.
- Promise
  - 한계
    - (실행 중) 취소 불가능
      - 취소가 왜 필요할까?
        - 예시) Auto-Complete
          - 사용자가 “angular” 입력 시, Ajax 요청함.
          - 사용자가 다음으로 “react” 입력 시, Ajax 요청함.
          - 이전 요청인 “angular”는 취소되어야 함.
          - 취소되지 않으면 Ajax Response 순서가 보장되지 않으면, “angular”의 결과가 출력될 수 있음.
    - 단일값
      - 대부분 비동기는 값이 여러 개이다.
        - callback은 여러 값을 다룰 수 있으나, 코드가 복잡해진다.

## 2. Observable 소개

- 특징
  - 비동기로 발생하는 여러 데이터를 다루는 인터페이스
  - 이벤트 스트림
  - 취소 가능
    - 의문
      - 구체적인 예시?
        - 답변: 예시로, switchMap 오퍼레이터가 존재함.
  - 비동기 흐름을 쉽게 읽을 수 있음

## 3. Rxjs로 비동기 프로그래밍

- 특징
  - Observable 구현체 제공
  - Composition 및 생성 유틸리티 제공 (a.k.a operator)
    - Observable을 재활용하여 성능 향상
    - 비동기 흐름을 선언적으로 작성
  - Scheduling
- Piping
  - 도입 이유
    - Prototype을 확장하면 문제가 많다.
      - Global
      - Tree-shaking이 힘듬.
    - 가독성은 pipe가 떨어지는 부분은 있음.

## 4. Observable 좋은 선택일 수 있는 이유

- Pull
  - 외부에 요청하여, 응답받고 처리
  - 값을 가져오기 위해서 지속적인 호출이 필요함.
  - iteration, function
  - 좋은 예시로, Redux saga.
- Push
  - 외부에 응답이 오면 그 때 반영하여 처리
  - 값을 가져오기 위해서 구독
  - 웹에서 다루는 대부분의 비동기는 Push 모델이 적합 (언제 이벤트가 발생할지, 발생측에서 …)

## 5. 은탄환은 없다

- 러닝커브가 매우 가파르다.
- 디버깅의 어려움
- 표준 스펙으로 채택의 어려움.

## 6. 활용

- RxJS Scheduling and animation
  - RxJS Scheduler
    - 언제 구독이 시작될지 또는 언제 값이 전달될지 타이밍을 계산
    - 기본적으로 Scheulder는 지정되어 있지 않음.
  - animationFrameScheduler
    - 다음 requestAnimationFrame에 값이 전달됨.

## 참고

- (유투브) <https://www.youtube.com/watch?v=oHF8PEkteq0&t=1s>

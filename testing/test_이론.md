## 도메인 범위 : Test / CROWN2.0 - 사용자 설명서

## software testing 종류
- 추가 자료 https://angel927.tistory.com/77?category=222018
1. black box testing(블랙 박스 테스팅)
    - 시스템의 내부 설계를 전혀 고려하지 않은 테스팅
    - 고객의 요구사항 등이 담긴 프로그램 명세서를 기반으로 테스팅
    - 입력과 출력을 확인하므로서 시스템 오류를 발견하는 방식
    - 기능이 오류 없이 작동하고 명세에 맞게 작동하는 지를 시험하는데 많이 사용
    - 기능검사(functional testing) 라고도 함
    - 또는 명세 기반 시험(specification-based testing) , 입출력 시험(input/output testing)
2. white box testing(화이트 박스 테스팅)
    - 유리상자 처럼 내부가 잘 보이는 박스
    - 테스트를 수행 시 소스코드와 내부 구조(알고리즘)을 하나하나 짚어가면서 입력 값에 따른 출력 값이 어떠한 원리로 계산(수행)되는 지 정밀하게 테스트( 프로그램 내부의 소스코드와 구조를 어떻게 분석 )
    - 시스템 내부 설계를 고려한 테스팅
    - 시스템의 코드 내부 로직에 대한 지식을 기반으로 수행
    - 내부적으로 소프트웨어와 코드가 어떻게 동작하는지 알고 있어야 한다
    - 커버리지를 통하여 테스팅
    - 프로그램 내부 구조의 타당성 여부를 시험하는 방식
    - 내부 구조의 해석을 위해 프로그램의 모든 처리 루틴에 대해 시험하는 기본 사항
    - 가끔 발생하는 조건도 고려해서 처리 루틴을 검증하기 위한 시험 데이터를 작성하여 시험을 실시
    - 커버리지 종류
      - Path
      - Statement coverageㅂ
        - 구문 커버리지
        - 소스코드 문장(Line) 수행량
      - Decision or branch coverage
        - 분기 (결정) 커버리지
        - if, for, while 등 수행 결과가 각각 True와 false를 갖는 테스트를 수행
        - 예시)
          - if(x<3)
            - ture를 만족하려면 테스트를 통해 x < 3일 경우(x :=2)를 수행하게 됨
            - false를 만족하려면 x > 3일 경우(x:=3 또는 x:=10)를 수행하게 됨
      - Condition coverage
         - 조건 커버리지
      - DC/CD
      - MC/DC
        - Modified Condition/Decision Coverage
        - 변경 조건/결정 커버리지
        - 보통 조건 커버리지 기법은 사용하지 않음 => MC/DC기법 사용
        - Condition은 개별 조건식
          - 개별 조건식 : 전체 조건식을 가장 작은 단위로 쪼개어 낸 조건식
        - Decision은 전체 조건식
          - 전체 조건식 : 분기 커버리지에서도 사용되는 분기 또는 결정과 같은 의미 
        - 개별 조건식과 전체 조건식 예시)
          - 조건식 if(x <3 && y <10)
            - 전체 조건식은 괄호 안의 모든 내용 => x <3 && y < 10
            - 개별 조건식은 두 개 => x < 3 , y < 10
        - 각 개별 조건식이 서로 독립적으로 전체 조건식에 영향을 미치는 진리표를 만족하는 설계 기법
          - 독립적이다 : 전체 조건식이 True/Fase 값으로 변경 될 때 A가 변하지 않고 B가 변했거나, B가 변하지 않고 A로 변하는 방식으로 서로의 변화가 결과 값에 영향을 끼치지 않는다는 뜻
        - 자세한 정보는 https://m.blog.naver.com/suresofttech/220636029506?referrerCode=1
        - MC/DC는 테스트케이스 조합의 개수를 줄이면서, 개별 조건식까지 테스트를 수행하기 위하여 고안된 기법
      - Multiple Condition Coverage 
  
3. Gray box testing
    - 소프트웨어의 내부 구조의 일부만 알고 수행하는 테스팅
    - 블랙 박스 테스팅과 화이트 박스 테스팅이 혼합된 방식의 테스팅
    - 그레이박스 시험은 내부 구조를 일부만 알고 시험하는데 시험을 위한 테스트 케이스를 만들 때 내부 구조 정보를 활용하며, 시험은 불랙박스 형태로 수행된다. 주로 통합 시험에서 많이 사용된다.

4. Unit testing
   - 각각의 소프트웨어 컴포넌트나 모듈 대상 테스팅
   - 테스터가 아닌 프로그래머에 의해 수행
   - 수행을 위한 프로그램 내부에서 수행되는 코드와 프로그램 설계에 대해 해박한 지식 필요

5. Integration testing (통합 테스팅)
    - 프로그램이 통합된 이후에 결합된 기능들을 검증하기 위한 통합 모듈 테스팅
    - 모듈은 일반적으로 코드 모듈, 개별 어플리케이션, 네트워크 상의 클라이언트와 서버 애플리케이션 등
    - 이 유형의 테스팅은 특히 클라이언트/서버 분산 호나경 시스템에 적절

6. system testing
   - 각각의 요구사항에 대해 전체 시스템이 테스팅 됨
   - 전체 요구사항 명세에 기반한 블랙박스 타입 테스팅으로 모든 조합 가능한 시스템의 부분들을 커버
   
7. alpha testing
   - 개발의 마지막 부분에서 수행하는 테스팅
   - 가상의 유저 환경이 조성될 수 있다
   - 테스팅 결과로 사소한 디자인 변경 등이 이루어질 수 있다

8. beta tseting
   - 엔드 유저에 의해 완료되는 테스팅
   - 프로그램 상용화르 위한 애플리케이션 릴리즈 이전의 최종 테스팅 의미

9.  acceptance testing (인수 테스팅)
   - 일반적으로 개발된 시스템이 고객이 명세한 요구사항을 충족했는지를 검증하기 위해 사용
   - 사용자 혹은 고객이 인수 테스팅을 통한 결과를 보고서 애플리케이션을 인수(Accept) 할 것인지를 결정하기 위해 수행

9.regression testing (리그레션 테스팅)
   - 애플리케이션의 모든 모듈 및 기능에 대한 수정 사항을 테스팅
   - 모든 시스템을 커버하는 것은 무척 어려운 일이므로 일반적으로 자동 테스팅이 사용 된다

## QA와 QC란 무엇인가
  - http://koonhous.blogspot.com/2017/10/difference-between-qa-and-qc.html
  - https://angel927.tistory.com/76
  - QA 품질 보증
    - Quality assurance 품질 보증
    - ```
         기업이 품질 요건 및 충족할 수 있는 신뢰를 제공하기 위해 품질관리 시스템의 요구사항에 따라 구현 가능한 품질관리를 계획하고 체계적인 활동을 수행하는 것으로 정의하고 있습니다. QA는 고객의 요구사항을 충족하기 위한 활동으로 제품의 개발, 주문 및 자재 구매, 고객의 요구사항을 검토하여 이를 충족시키기 위한 검사, 생산공정관리 및 일정, 단계별 공장 활동을 관리하는 것이 포함되어 있습니다.
      ```
    - 주요 업무
      - 공정 상태 모니터
    - 어떤 실체(품목, Entity)가 품질 요구 사항을 충족하는 것에 대한 적절한 신뢰감을 주기 위하여 품질시스템에서 실시되고 필요에 따라 실증되는 모든 계획적이고 체계적인 활동
    - 고객의 관점에 많은 비중을 두는 활동
    - 해당 제품에 대한 좀 더 포괄적인 책임을 지는 역활
    - 고품질 (High-Quality)
    - 대다수 기업은 소프트웨어의 결함을 예방하기 위해 품질 보증 프로세스를 확립하고 지속적으로 관리
    - 소프트웨어 분야
      - 소프트웨어 수명주기에 참여하여 요구사항 검토, 소스코드 분석, 문서화 등 전문적이고 포괄적인 의미로 QA를 씀
      - QC업무를 가능하게 하는 프로세스에 대한 지속적이고 일관된 개선과 유지보수를 제공
    - 제품의 보증 및 사후 서비스
  - QC 품질 관리
    - Quality Control 품질 관리
    - 기업 경영상 제일 유리하다고 생각되는 품질을 보장하고 이것을 가장 경제적 제품으로서 생산하는 방법
    - 품질에 대해 미리 정의된 요구사항을 검증하는 프로세스 
    - 제품에 많은 비중
    - 제품의 목적에 준한 기능을 검증하는 역할
    - 품질 보증 프로세스 내에서 품질 평가 활동을 모니터링하고 요구사항을 충족하는 지 관찰하는 업무를 수행
    - 결함 발견을 위한 활동
      - 소프트웨어 테스팅(Testing), 리뷰(Review), 검사(Inspection)를 수행
    - 소프트웨어 분야
        - QC보다 QA 혹은 SQA(Software Qaulity Assureance - 소프트웨어 품질 보증)
        - 소프트웨어가 일련의 요구사항에 부합하는지를 점검 및 소프트웨어가 미리 정의된 요구사항을 충족하는 지 검증
    - 생상 되는 제품의 품질 관리 
  - 예시)
    - 핸드폰 게임
      - 게임 기능은 게임 속 캐릭터가 잘 움직이는가, 포인트는 잘 합산되는가, 레벨업/다운은 기획과 동일하게 진행되는 가 등
      - 품질관리 (QC)는 이러한 기능들이 잘 구현되었는지 확인
      - 품질 보중 (QA)는 핸드폰에서 구동 시 데이터는 너무 많이 소모하지 않는지, 메모리는 적절히 분배하고 있는지, 동일한 ID로 다른 핸드폰에서 로그인 했을 때 정보가 제대로 이관되는 지 등의 사용자 관점에서 판단할 수 있는 잘 만든 게임을 위한 검증 활동

  - 포함 관계
    - Testing < QC < QA

  - 결론
    - QC 프로세스를 제품이 우리가 의도한 대로 작동하는 지 검증
    - QA 프로세스는 우리에게 그 제품이 우리 고객의 요구를 충족시킬 것이라는 확신
    - QA프로세스를 QC 프로세스의 측면을 포함하는 메타 프로세스로 간주
    - QA는 사용성과 디자인의 영향을 검증하는 것을 넘어서, 기능이 정확하게 구현되었는지 뿐 아니라 그 기능이 유용한 것인지를 검증하는 것
    - 
 

## 부하 테스트와 스트레스 테스트 차이
  -  https://angel927.tistory.com/72?category=222018

## 훌륭한 테스트 팀을 만들고 유지하기
  - https://angel927.tistory.com/75?category=222018

## 테스트 커버리지 100%의 함정
  - https://m.blog.naver.com/suresofttech/221204080414?referrerCode=1

## 구조적 커버리지 종류
  - https://m.blog.naver.com/suresofttech/221833396343?referrerCode=1

## UI Automator를 이용한 UI 테스트 자동화
  - https://m.blog.naver.com/suresofttech/221343561605?referrerCode=1

## GUI 응용 소프트웨어의 자동품질관리 시스템
  - https://m.blog.naver.com/suresofttech/222069487635?referrerCode=1

## 에자일 개발 방법론 - 스크럼
  - https://m.blog.naver.com/suresofttech/222080386117?referrerCode=1

## SW 설계 명세서의 구성 요소와 템플릿 
  - https://m.blog.naver.com/suresofttech/222477570203?referrerCode=1

## 지속적 통합 CTS 적용 사례
  - https://m.blog.naver.com/suresofttech/222576545291?referrerCode=1

# 자동차
## 국제 표준 ISO 26262에 정의된 소프트웨어 검증 방법
  - 자동차에 탑재되는 E/E(Electric & Electronic) 시스템의 오류로 인한 사고를 방지하기 위해 ISo에서 제정한 자동차 기능 안전 국제 규격
  - 총 10개의 part와 43개의 요구사항 및 권고사항으로 구성됨
  - 개발 초기부터 생산, 폐기에 이르는 소프트웨어 전체 생명주기에서의 안전 관련 요구사항을 제시
  - 참고 https://m.blog.naver.com/suresofttech/220694936401?referrerCode=1
  - 이해 잘 안됨
  - 나중에 다시 볼 것
## 자동차 분야에서 모델 기반 개발에 관련된 국제 표준 동향 - ISO 26262, MISRA-AS
  - https://m.blog.naver.com/suresofttech/220806109553?referrerCode=1

# 임베디드
## 임베디드 타깃 테스트의 문제점과 해결 방안
  - https://m.blog.naver.com/suresofttech/220731900177?referrerCode=1


# 국방

## 무기체계 소프트웨어 개발 및 관리 메뉴얼 개정 분석
  - https://m.blog.naver.com/suresofttech/220811945079?referrerCode=1

## 항공 SW 인증 주요 표준 DO-178C
  - https://m.blog.naver.com/suresofttech/220821979276?referrerCode=1

## [국방] 무기체계 소프트웨어 신뢰성 시험 요약
  - https://m.blog.naver.com/suresofttech/220743032566?referrerCode=1

## [국방] 무기체계 SW 신뢰성 시험 - 실행시간 오류 (Run Tiem error) 검출 방안
  - https://m.blog.naver.com/suresofttech/220695842319?referrerCode=1
  - 무기 체계 SW 신뢰성 실험
    - 정적 실험
      - SW를 실행하지 않은 상태에서 소스코드 내 조재하는 결험 검출
      - 시험 항목
        - 코딩 규칙 검증
        - 실행 오류(ETE) 검출
          - 실행 정지, 오작동, 메모리 누수 등을 유발할 가능성이 있는 소프트웨어 소스 코드의 취약점 (언어 의존한)
          - CWE (Common Weakness Enumeration)
        - 소프트웨어 보안 및 품질강화를 위해 개발 시에 참고할 수 있도록 소프트웨어 취약점을 표준화한 목록
    - 동적 실험
      - SW의 구조를 기반으로 SW를 실행하면서 기능의 정상동작 여부를 확인하는 실험
      - 시험 항목
        - SW의 코드 실행률 확인


##  메뉴얼 테스트 vs 테스트 자동화
   - https://blog.powerumc.kr/353
   - 공통
     - 범위 정하기 힘듬
     - 테스트 기본
   - 메뉴얼 테스트
     - 수동 테스트
     - 테스터에 의해 직접 수행하여 테스트 결과를 기록하는 방식

   - 테스트 자동화
     - 자동 테스트
     - 프로그램이나 스크립트에 의해 자동으로 테스트를 수행하여 결과를 기록

   - 자동화 테스트는 신뢰가 그리 높지 않다?
   - 메뉴얼 테스트는 매번 인력이 투입되는 테스트
     - 인력이 매우 비쌈
     - 수행 속도가 느리지만 신뢰도가 매우 높음
   - 

## TDD
  - Test Driven Development
  - 테스트 주도 개발
  - 에자일 방법론 중 하나인 eXtream Programming(XP)의 Test First의 개념에 기반을 둔 단순한 설계에 중점
    - eXtream Programming(XP)
      - 미래에 대한 예측을 최대한 하지 않음
      - 지속적인 프로토타입을 완성하는 애자일 방법론 중 하나
      - 추가 요구사항이 생기더라도 즉각 반영 가능
    - 단위 테스트
      - 한 단위(class, component, module) 만 테스트
  - (기존)설계 이후 코드 개발 및 테스트 케이스를 작성와 다름
  - 테스트 케이스르 작성 한 후 실제 코드를 개발하여 리팩토링하는 절차
  - 순서 case 1
    - 설계 디자인 --> 테스트 코드 작성 --> 코드 개발
               <--설계(디자인) 수정 <--(리팩토링)
  - 순서 case 2
    - Red 단계 (Write Failling Test): 실패하는 테스트 코드를 먼저 작성
    - Green 단계 (Make Test Pass): 테스트 코드를 성공시키기 위한 실제 코드를 작성
    - Yellow 단계 (Refactor): 중복 코드 제거, 일반화 등 리팩토링 수행
    - 중요
      - 실패하는 테스트 코드를 작성할 때 까지 실제 코드를 작성하지 않는다
      - 실패하는 테스트를 통과할 정도의 최소 실제 코드를 작성
      - 실제 코드에 대해 기대되는 바를 보다 명확하게 정의함으로써 불필요한 설계를 피할 수 있고, 정확한 요구사항에 집중 가능
  - 일반 개발 방식
    - 요구사항 분석 -> 설계 -> 개발 -> 테스트 -> 배포의 형태의 개발 주기
      - 단점은 소프트웨어 개발을 느리게 하는 잠재적 위험 존재
        - 잠재적 위험
          - 소비자의 요구사항이 처음부터 명확하지 않을 수 있다
          - 처음부터 완벽한 설계 불가능
          - 자체 버그 검출 능력 저하 또는 소스코드의 품질이 저하될 수 있다
          - 자체 테스트 비용이 증가할 수 있다
        - 결론 
          - 코드들은 재사용이 어렵고 관리가 어렵고 유지보수가 어렵다
          - 작은 기능 수정 시 모든 부분을 테스트해야 하므로 전체적인 버그를 검출하기 어려워진다
            - 자체 버그 검출 능력 저하
            - 코드 안고치려는 현상 => 코드 품질 저하
            - 자체 테스팅 비용 증가
        
  - 책과 비슷
    - 목차 구성 (테스트코드 작성)
    - 목차 별 맞는 내용 구상하여 초안 작성 (코드 개발)
    - 고쳐쓰기 반복 (코드 수정)
  - 고품질 소프트웨어를 만들 수 있다
  - 왜 해야 할까?
    - 피드백
    - 협력
    - 두 요소가 자주 이루어진다면 더 좋은 결과가 나올 수 있다
  - 어떤 상황에서 사용?
    - 처음해보는 프로그램 주제(개발 능력에 대한 불확실성 높은 경우)
    - 고객의 요구조건이 바뀔 수 있는 프로젝트 (외부적인 불확실성이 높은 경우)
    - 개발하는  중에 코드를 많이 바꿔야 된다고 생각하는 경우
    - 내가 개발하고 나서 이 코드를 누가 유지보수 할 지 모르는 경우
  - 효과
    - 피드백과 협력을 동시에 증진
  - 테스트의 명시화
    - 테스트는 보통 동사이다 
      - 테스트한다. 테스트해라.
    - TDD를 하면 test는 명사가 된다.
    - 동사는 그 순간에만 하는 것
    - 명사(대상, 목적어)는 이후에도 소유할 수가 있다. 
      - 이를 통해 남들에게 테스트 코드를 보여줄 수 있고, 남들은 그 코드를 직접 실행해볼 수 있다.
  - 왜 TDD는 협력을 증진시킬까
    - 테스트가 명사가 된다면 공유가 쉬워진다. 다른 사람의 코드를 쉽게 접근 가능하고, 이해가 빨라진다. 다른 사람의 코드의 의도를 확인 할 수 있게 한다
  - 예제)
    - 정수 숫자의 숫자 범위 별 문자(A,B,C,D)로 변환
      - 1. 테스트 코드 작성
      - 2. 테스트 코드에 맞는 실제 코드 작성
      - 3. 테스트 코드에 작성된 클래스 정보를 통과할 정도로 입력을 한 뒤 리팩토링 작업 (예외처리, 중복제거, 추가 기능)을 반복
  - TDD 개발 방식의 장점
    - 보다 튼튼한 객체 지향적인 코드 생산
      - TDD 코드는 재사용 보장을 명시하므로 TDD를 통한 소프트웨어 개발 시 기능 별 철저한 모듈화 진행됨
      - 종속성과 의존성 낮은 모듈로 조합된 소프트웨어 개발을 가능
      - 필요에 따라 모듈을 추가하거나 제거해도 소프트웨어 전체 구조에 영향을 미치지 않게 된다
    - 재설계 시간의 단축
      - 테스트 코드를 먼저 작성하기 때문에 개발자가 지금 무엇을 해야하는지 분명히 정의하고 개발을 시작
      - 테스트 시나리오를 작성하면서 다양한 예외사항에 대해 생각
      - 개발 중 소프트웨어의 전반적인 설계가 변경되는 일을 방지
    - 디버깅 시간 단축
      - 유닛 테스팅을 하는 이점
      - 예) 사용자의 데이터가 잘못 나온다면 DB의 문제인지, 비즈니스 레이어의 문제인지, UI의 문제인지 실제 모든 레이어들을 전부 디버깅해야 함
        - TDD는 자동화된 유닛테스팅을 전제하므로 특정 버그를 손 쉽게 찾아낼 수 있다
    - 테스트 문서의 대체 가능
      - 프로젝트 진행 중 어떤 요소들이 테스트 되었는지 테스트 정의서를 만든다
        - 단순 통합 테스트 문서일 뿐
      - TDD는 테스팅을 자동화 시킴과 동시에 정확한 테스트 근거를 산출
    - 추가 구현의 용이함
      - 기능 추가 시 새 기능이 기존 코드에 어떤 영향을 미칠지 알지 못한다
        - TDD의 경우 자동화된 유닛 테스팅을 전제하므로 테스트 기간을 획기적으로 단축
  - TDD 개발 방식의 단점
      - 생산성 저하
        - 처음부터 2개의 코드를 짜고 중간 중간 테스트를 하면서 고쳐나가야 하기 때문
        - TDD 시 일반적인 개발 방식에 비해 10~30% 정도 시간 증가
      - 이제까지 자신이 개발하던 방식을 많이 바꿔야 함
      - TDD는 이렇게 해야한다는 이미지/틀이 있다
        - 반드시 툴(단위 테스트 프레임 워크)를 써야 한다
          - 이러한 규칙에 얽매이는 것은 애자일 방식이 아님
          - 결국엔 규칙에 얽매여 똑같은 테스트를 copy & paste 한다
          - 도구/규칙에 집착하다 보면 TDD가 어려워지는 것
    - TDD를 잘하는 방법
      - 계속해서 본인이 일하는 방식을 업그레이드

              
## BDD 
  - 행위 주도 개발
  - 인터페이스와 구현을 분리하고 인터페이스에 집중 가능
  - 구현 코드 없이도 BDD를 통해 인터페이스만으로 테스트나 코드를 통해 설계 작업을 진행할 수 있게 됨
  - 테스트 시나리오를 알고 있는 것만으로 테스트를 진행하므로 인터페이스의 디자인이나 설계에 집중

## 요구사항 기반 단위 검증
  - https://m.blog.naver.com/suresofttech/221601016337
  - 자동차 업계
    - ISO 26262 
  - 단위 검증
    - 검증 대상 단위(함수 또는 기능)가 설계된 의도대로 동작하는지 검증하는 절차
  - 추후 자세히 볼 것

## Testing 용어

0. coverage
    - 소스코드 중 어느 정도를 '커버' 했는가
    - 테스트 수행 된 정도
1. Drive 

2. Stub

3. Tcs

4. MC/DC

5. Compile DB

6. Bear

7. JSON compliation database

8. 심볼릭 자료 구조

9.  LINES

10. FUNCTIONS

11. Branches

12. assert

13. GDB

14. GNU
15. GDB

16. libc

17. FOPEN

18. filter
    - status?
    - array size?
    - #Unique TC
    - #All TC
    - #crash?
    - Function timeout?
19. strategy 
    - dfs?
    - rev-dfg?
    - cfg?
    - rendome
    - combined SS?
    - strategy는 어떤 케이스에 어떤 옵션 값을 선택지에 대한 메뉴얼이 존재?

20. pre-processing error 

21. 예약어
    - 식별자로 사용할 수 없는 단어
    - 이미 문법적인 용도로 사용되고 있음
    - 혹은 아직 구현되지 않은 명령어들을 위하여 예약어 지정된 경우
    - 예) return 
22. 식별자
    - 일반 
      - 대상을 유일하게 식별 및 구별할 수 있는 이름
      - 약어는 ID는 식별(identity), 식별 과정(identification),식별자
      - 예) URL, IP 주소, 데이터베이스 키
    - 컴퓨터 공학
      - 코드에 존재하는 변수, 자료형, 서브루틴 등을 가리키는 토큰
      - 식별자의 프로그램 내의 스코프나 액세서빌리티는 지역 또는 전역 일 수 있다.
23. 토큰
    - 어휘 분석(lexical analysis)의 단위를 가리키는 컴퓨터 용어
    - 예시
      - 어휘소 sum / 토큰 분류 identifier
      - 어휘소 = / 토큰 분류 assignment operator
      - 어휘소 3 / 토큰 분류 integer literal
      - 어휘소 + / 토큰 분류 addition operator
      - 어휘소 2 / 토큰 분류 interger literal
      - 어휘소 ; / end of statement
24. 어휘소
    - 어휘를 이루는 하나 하나의 요소
    - 단어의 개념과 비슷하나 그 구체적인 내용은 학자에 따라 다르다
25. 어휘 분석(lexical analysis)
    - 또는 낱말 분석
    - 프로그래밍 언어를 처리하는 최초의 단계 (어떤 최초?)
26. 파싱
    - 문자열을 의미 있는 토큰으로 분해하고 이들로 이루어진 파스 트리를 만드는 과정
      - 종류
        - 하향식 구문 분석
        - 상향식 구문 분석
    - 참고 : https://ko.wikipedia.org/wiki/%ED%8C%8C%EC%8A%A4_%ED%8A%B8%EB%A6%AC
27. 파서
    - 인터프리터나 컴파일러의 구성 요소 가운데 하나
    - 입력 토큰에 내재된 자료 구조를 빌드하고 문법을 검사
    - 일련의 입력 문자로부터 토큰을 만들기 위해 별도의 낱말 분석기 이용
28. 파스 트리
    - 올바른 문장에 대해 트리 구조로 나타낸 것
    - 입력 언어 문법을 구체적으로 반영
29. 구분자, 분리자
    - 영어로 Delimiter
    - 일반 텍스트 또는 데이터 스트림에서 별도의 독립적인 영역 사이의 경계를 지정하는 데 사용하는 하나의 문장 혹은 문자들의 배열
    - 예시 CSV(comma-separted values) 파일의 필드 구분자의 역할

## 국어?
29. 어휘
    - 일상 어휘
      -  일상에서 쓰는 말
      -  전문어는 학술이나 특정한 분야에서 특별한 의미로 쓰는 말
      -  전문어를 통해 그 분야에서 효과적인 업무 수행을 할 수 있다
30. 낱말
    - 의미를 담고 있는 자립성 있는 최소 단위
    - 자립성이 있으므로 앞뒤로 띄어쓰기 가능
31. 형태소
    - 의미를 가지는 요소로서 더 이상 분석할 수 없는 가장 작은 말의 단위(더 이상 분석 시 자음과 모음으로만 나뉘어 알아볼 수 없게 된다)
    - 최소 유의미 단위
    - 문법적/관계적인 뜻만을 나타내는 단어 또는 단어의 부분
    - 단어와 다름
      - 어느 부분이 다른가? 아래 서술
    - 예)
      - 사랑
        - 사, 랑 을 나누면 의미 잃음
      - 첫사랑, 짝사랑
        - 첫, 사랑 과 짝, 사랑은 나누어도 본 뜻이 존재 (각 2개의 형태소)
32. 단어
    - 또는 낱말

33. 낱말과 어휘의 차이점
    - 단어: 최소의 자립 형식
    - 형태소: 의미를 지닌 최소의 단위
    - 단어는 자립적으로 쓰일 수 있지만 형태소는 반드시 자립적으로 쓰이는 것은 아니다
    - 예) 맨손
      -  맨, 손  은 2개의 형태소로 이루어진 하나의 단어
       - 손은 자립적으로 쓰일 수 있는 형태소이지만 맨은 자립성이 없어 홀로 나타나지 못한다
34. 구
    - 둘 또는 그 이상의 낱말이 묶여 하나의 문장을 이루는 성분(명사, 동사, 부사, 형용사 등)으로 쓰이는 말 덩이
    - 문법 체계에서 절보다 낮은 곳
      - 예시) 따듯한 봄에 소풍을 간다
        - 따듯한 봄 = 구
      - 예시) 철수는 깊은 생각에 잠겼다
        - 깊은 생각
35. 문장
    - 문장이란 문법상의 용어
    - 문장에는 단어, 구, 절이 포함
    - 문장의 끝에는 마침표, 쉼표, 물음표, 느낌표를 찍는다.
    - 종류
      -   평서문(~이다)
      -   의문문(~인가)
      -   감탄문(~이구나)
      -   명령문(~하라)   
36. 절
    - 주어(subject)와 서술어(predicate)로 이루어진 통사적인 단위의 하나로 더 큰 문장의 성분이 되는 것
    - 주어가 명시적으로 드러나지 않는 경우도 있다.
    - 완전한 문장이 될 수도 있다
    - 여러 절이 모여 하나의 문장 즉 복문을 이룰 수 있다.
    - 예시)
      - 지현이는 착하다고 한다
        - 지현이는 착하다 = 절
          - 지현이(주어), 착하다(술어)
      - 지현이는 착하다고 한다에 '지현이는 착하다'는 문장 안에 들어가 있는 말덩이
37. 문단
    - 하나의 글에서 내용이나 형식을 기준으로 하여 크게 나누어 끊은 단위
    - 한 편의 글에는 여러 개의 문단이 들어 있다
    - 한편의 글에서 내용을 기준으로 나눈 것
    - 문단은 하나의 주제만을 표현하는 문장들을 묶은 것
    - 하나의 주제를 이끌어 내는 중심 문장과 그 중심 문장을 설명하거나 보충하거나 하는 문장들이 있다 = 묶음을 문단
    - 줄을 바꾸고 들여쓰기를 하는 단위
38. 단락
    - 한편의 글 속에서 하나의 작은 주제를 표현하는 작은 글
    - 문단과 단락은 그 개념이 명확하지 않고, 설명하는 사람에 따라 다른 경우가 있다.
39. 복문
    - ?
40. 문
41. 언어 구성자
42. 구문(syntex)
    - 프로그래밍 언어에서 프로그램의 모습, 형태, 구조가 어떻게 보이는지에 대해 정의
    - 구문은 정해진 문법을 이용
    - 종류
      - 단어(word): 문자가 어떻게 토큰을 형성하는지 결정하는 어휘적 수준
      - 구(phrase) : 어떻게 토큰이 구를 형성하는지를 결정하는 문법 수준
        - 예시) ?
      - 컨텍스트(context): 어느 객체나 변수 이름이 참조하는지를 결정 (형이유효한지 등)
        - 문맥, 맥락
        - OS에서는 프로세스의 상태(문맥), 한 프로세스의 문맥은 그 프로세스의 프로세스 제어 블록에 기록됨, 컨텍스트 스위치(문맥 교환)
43. 조건식
    - ?
44. 통사적 단위
    - 문장
    - 절
    - 단어

45. 구/절/문 의 구분

## 참고 사이트
  - https://m.blog.naver.com/suresofttech/221601016337
# Mockists vs. Classicis
- 테스트 대역은 매력적인 도구이다. 
- 특히 단위 테스팅이나 테스트 주도 개발을 처음 배우는 프로그래머에게 더욱 그렇다.
- 하지만 모든 도구는 장점과 단점이 있고 유용한 환경이 있다.
- 테스트 대역을 보다 조심스럽고 효과적으로 다루는 방법을 고민하자.

### 비교
 - sociable 테스트와 solitary 테스트
 - sociable 테스트
     - 단위 테스트 -(의존)-> 시스템 -(의존)-> 의존 대상
 - solitary 테스트
     - 단위 테스트 -(의존)-> 시스템 -(의존)-> 테스트 대역
     - 단위 테스트가 테스트하고자 하는 코드 외 코드를 대체(?)하여 SUT를 독립시킴
     - 확실한 안정적인 단위 테스트를 하는 걸까?
       - 아니다.
       - 가정의 안정도 참고 
 - sociable 테스트와 solitary 비교
 

 ### 가정의 안정도
  - 테스트 대역 사용으로 인해 생기는 가정의 얼마나 믿을 수 있을까?
  - 테스트 대역이 구현하는 인터페이스가 단순할 수록 1에 가까워 짐(안정)
  - 테스트 대역이 구현하는 인터페이스가 복잡할 수록 0에 가까워 짐(불안정)

### Mock
  - sut 내부의 동작을 검증

### Mock의 위험
 - 상태 검증 vs 행위 검증
   - Mock은 행위 검증에 가깝다
 - 정보 숨김 위배
   - Mock은 SUT 내부의 동작 검증에 책임이 있으므로 내부 구현에 대한 정보를 갖게 되고 이 부분이 테스트 코드로 유출 된다
 - 테스트가 SUT 구현에 의존
 - 고통스럽고 불안한 리팩터링
   - 구현을 바꿀 때 요구사항을 만족해야 하지만 Mock은 모듈이 노출하고 있는 인터페이스만 사용해서 테스트하는 것이 아닌 내부 구현까지 참고하므로 테스트 코드가 깨질 가능성이 매우 높다
   - 개발자의 리팩토링을 주저하게 만든다

### 상태 검증
 - 입력에 대한 출력 검증

### 행위 검증
 - 어떻게 출력을 만드는지 검증

### Mockists 
 - Mock을 적극적 사용
 
### Classicists
 - 직접 구현


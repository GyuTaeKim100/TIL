# CS terms

## blob

### 참고

1. (mdn, blob) <https://developer.mozilla.org/en-US/docs/Web/API/Blob>

## 프록시

### 설명

- 서버와 클라이언트 사이의 중계기
- 중계 기능을 하는 것을 프록시 서버라고 한다.
- 일부 프록시 서버는, 요청을 캐시 처리한다.
  - 캐시를 통해 네트워크 병목 현상을 방지하는 데 효과적이다.
    - 전송 시간 절약
    - 외부 트래픽 감소
    - 불필요한 요청 감소

### 목적

- 익명으로 컴퓨터를 유지(보안)
- (과거의 주요 목적) 캐시를 통해, 효과적인 리소스 접근을 한다.
  - 흔히 웹 프록시는 서버로부터 웹 페이지를 캐시하는 용도로 사용된다.
  - 현재는 CDN이 역할을 대신한다.
- 네트워크 서비스나 콘텐츠로의 접근 정책을 적용하기 위해.
  - 예시, 원치 않는 사이트를 차단
- 사용률을 기록하고 검사하기 위해서
  - 예시, 회사에서 인터넷 이용을 파악
- 보안 및 통제를 뚫고 나가기 위해서
  - 예시, 내부 정보 보안이 필요한 가수의 기업에서 프록시 서버를 통해서 외부망에 접속한다.
- 바이러스 전파, 악성 루머 전파, 다른 정보를 탈취
  - 추가적인 예시 필요
- IP 추적 피하기
  - 추가적인 예시 필요
- 전달에 앞서 악성 코드를 목적으로 전달된 콘텐츠를 검사
  - 추가적인 예시 필요
- 밖으로 나가는 콘텐츠르 검사
  - 예시, 데이터 유출 보호
- 지역 제한을 우회
  - VPN

### 과정

1. 누군가 웹 브라우저에 나무위키의 도메인을 입력.
2. 요청은 내부에서 캐시 역할을 하는 프록시 서버로 전달.
3. 프록시 서버는 우선 자신이 나무위키 홈페이지의 대문 페이지를 가지고 있는지 체크.
4. 가지고 있지 않다면 외부회선을 통해 나무위키 홈페이지가 있는 서버와 연결하여 대문 페이지를 가져온다.
5. 만약 가지고 있다면 나무위키 홈페이지가 있는 서버에게 자신이 가진 페이지가 최신 버전인지 체크.
6. 최신이 아닌 경우 새로 갱신된 가져옴.

### 보충

- 캐시처리는 네트워크 대역폭이 좁은 경우 효과가 특히 좋다.
  - 만약 좁은 대역폭을 많은 Client가 공유한다고 생각하면 특히 더 큰 효과를 상상할 수 있다. 이 경우 고속 데이터 통신이 가능하도록 내부 캐시를 배치해서 해결한다.
  - 외부 회선은 프록시 서버가 독점한다.
- 효과가 없는 경우
  - 페이지를 반복 열람하는가? 즉 많은 사람들이 동시에 웹 서핑을 요청하면서 동시에 같은 웹 서핑 사이트에 접속하는가?
    - 이 경우 불필요한 캐시 처리이다.
    - 인터넷 대역폭이 높은 망은 굳이 성능 향상을 위해서 프록시를 사용할 필요가 없다.

### 참고

- (위키백과, 프록시 서버) <https://ko.wikipedia.org/wiki/%ED%94%84%EB%A1%9D%EC%8B%9C_%EC%84%9C%EB%B2%84>
- (나무위키, 프록시 서버) <https://namu.wiki/w/%ED%94%84%EB%A1%9D%EC%8B%9C%20%EC%84%9C%EB%B2%84>

## rpc (remote procedure call)

### 참고

- https://ko.wikipedia.org/wiki/%EC%9B%90%EA%B2%A9_%ED%94%84%EB%A1%9C%EC%8B%9C%EC%A0%80_%ED%98%B8%EC%B6%9C
- (RPC란) https://velog.io/@jakeseo_me/RPC%EB%9E%80

## 핸들

### 정의

- 자원(resource)에 대한 추상적인 참조이다.
- 핸들은 응용 소프트웨어가 DB, OS같은 다른 시스템에서 관리되는 메모리 블록 또는 객체들을 참조하는데 사용.
- 일반적인 리소스 핸들로는 파일 서술자, 네트워크 소켓, 프로세스 식별자 등이 있다.

### 포인터와 비교

- 포인터는 참조하는 대상의 주소를 갖는 반면, 핸들은 외부적으로 관리되는 참조를 추상화한 것.
- 참조의 불투명함은 핸들을 무효화시키지 않고도 참조 대상이 시스템에 의해서 메모리에서 재배치 될 수 있게 해준다. (포인터처럼 직접 할당된 주소를 가리키는 것이 아닌(직접 참조), 참조는 핸들을 가리키고, 핸들 내에서 메모리 배치가 이루어짐. 이를 간접 참조라 표현함.)
- 간접 참조의 여분의 층 또한 관리하는 시스템의 동작(참조 대상에 대해 수행하는)이 할 수 있는 제어를 증가시킨다.  (‘일반적으로 핸들은 전역 배열에 대한 인덱스이거나 포인터이다.’ 란 언급을 통해서 포인터처럼 메모리에 파편화된 할당이 되는 게 아닌것으로 보임.)
- 핸들 누수는 컴퓨터 프로그램이 자원에 대한 핸들을 요구하고 다 사용한 후 놓지 않을 때 발생하는 소프트웨어 버그이다. 이는 자원 누수의 형태로서 메모리를 가리키는 포인터에 대한 메모리 누수와 비슷하다.

### 참고

- <https://ko.wikipedia.org/wiki/%ED%95%B8%EB%93%A4_(%EC%BB%B4%ED%93%A8%ED%8C%85)>

## 서브루틴

### 정의

- 함수, 서브루틴, 루틴, 메서드, 프로시저는 소프트웨어에서 특정 동작을 수행하는 일정 코드 부분을 의미한다.
- 하나의 큰 프로그램을 여러 부분을 나누어주기 때문에 같은 함수를 여러 상황에서 여러 차례 호출할 수 있으며 일부분을 수정하기 쉽다는 장점을 가진다.

### 참고

- <https://ko.wikipedia.org/wiki/%ED%95%A8%EC%88%98_(%EC%BB%B4%ED%93%A8%ED%84%B0_%EA%B3%BC%ED%95%99)>

## 람다 대수

### 설명

- 람다 계산 또는 람다 계산법이라 부름.
- 추상화와 함수 적용 등의 논리 연산을 다루는 형식 체계이다.
- 람다 대수의 항은 변수와 추상화 및 적용 연산을 통해 구성된다 (비순수 람다 대수에서는 상수 역시 구성에 참여한다)
- 람다 대수의 (이해 안되는 부분) 알파 동치와 베타 축약 등의 연산을 수행할 수 있다.
- 알파 동치는 제한 변수를 변경하는 변환으로 이름 충돌을 방지하기 위해 사용됨. 단 드 브루인 첨수를 사용할 경우 이는 필요 없다.
- 베타 축약은 함수 적용을 적절한 치환 연산 결과로 대신하는 변환이며,베타 축약에 대한 주어진 항의 표준형이 (존재할 경우) 알파 동치 아래 유일하다는 사실은 처치-로서 정리의 따름정리이다.
- 람다 대수는 튜링 완전성을 만족시키며, 보편 튜링 기계와 동치이다.

### 도입

- 람다 대수는 함수를 단순하게 표현할 수 있음.
- 함수의 계산이라는 개념을 더 깊이 이해할 수 있게 도움.
- 내용이 어려워서 자세히는 안봄. 추후 자세히 볼 것

### 의문

- 적용 연산?
- 알파 동치?
- 베타 축약?
- 드 브루인 첨수?
- 처치-로서 정리의 따름정리?
- 튜링 완전성?
- 동치?
- 항등 함수?
  - identity function
  - 항등 함수 또는 항등 사상 또는 항등 변환은 정의역과 공역이 같고, 모든 원소를 자기 자신으로 대응 시키는 함수이다. (모든 원소를 자기 자신으로 대응한다?)
  - 자세히 안 봄
  - 참고
    - <https://ko.wikipedia.org/wiki/%ED%95%AD%EB%93%B1_%ED%95%A8%EC%88%98>

### 참고

- <https://ko.wikipedia.org/wiki/%EB%9E%8C%EB%8B%A4_%EB%8C%80%EC%88%98>

## 분산 시스템

### 참고

- (쿠버네티스 공식 도큐먼트) <https://kubernetes.io/ko/docs/concepts/overview/what-is-kubernetes/>
- (쿠버네티스, 도커 기본 개념) <https://www.samsungsds.com/kr/insights/220222_kubernetes1.html>
- (분산 시스템이란) <https://www.atlassian.com/ko/microservices/microservices-architecture/distributed-architecture>
- (분산 처리 시스템의 개념 이해) <https://losskatsu.github.io/os-kernel/dist-sys-concept01/#>

## 콜백(callback) 또는 콜백 함수(callback function)

### 설명

- 다른 코드의 인수로서 넘겨주는 실행 가능한 코드
- 콜백 수신 코드로 콜백 코드(함수)를 전달할 때 콜백 함수의 포인터(또는 핸들), 서브 루틴 또는 람다 함수의 형태로 넘겨준다.
- (동기 콜백) 콜백수신 코드는 콜백 코드를 필요한 경우 실행시킨다.
- (비동기 콜백은) 콜백수신 코드는 넘겨 받은 콜백함수를 ‘핸들러’로 등록하고, 콜백 수신 함수의 동작 중 어떠한 반응의 일부로서 나중에 호출할 때 사용할 수도 있다
- 콜백은 폴리모피즘과 제네릭 프로그래밍의 단순화된 대체 수법이다.
- 콜백 수신 함수의 정확한 동작은 콜백 함수에 의해서 바뀐다.
- 콜백은 코드 재사용을 할 때 유용하다.

### 배경

- 연결 리스트 상의 각 요소에 대해서 여러 가지 처리를 수행하는 문제 시, 한 방법으로 리스트 상의 반복자(iterator)로 각 객체를 처리할 수 있다.
  - 가장 일반적인 방법이지만, 이상적인 방법은 아니다.
  - 이유는 반복자를 제어하는 코드(for 문)는 리스트의 노드를 방문할 때마다 노드를 복제해야 한다. (복제의 의미는, 반복자가 원본을 참조하는 값을 주는 것이 아닌 deep copy를 한다고 보임.)
  - 리스트의 갱신이 비동기 프로세스로 처리되는 경우, 반복자로 리스트를 탐색하는 동안에 요소를 잃어버리거나 다음 노드를 탐색할 수 없게 될 가능성이 있다. (뮤텍스 등 쓰면 안됨? 그러면 관리가 복잡해지려나…)
  - 대체 방법으로 새롭게 라이브러리 함수를 만들어, 적당한 동기 신호(어떤 신호??)를 통해 필요한 처리를 하도록 한다. 이 경우에도 리스트를 탐색할 때마다 동일한 함수를 호출해야 한다.(많은 비용을 필요로 함) 이 방식은 여러 응용 프로그램에 쓰이는 범용 라이브러리에 적합하지 않다. 라이브러리를 개발할 때에는 모든 응용 프로그램의 요구를 예측할 필요가 없게 하며(범용성), 응용 프로그램 개발에서는 라이브러리에 추가된 기능에 대한 자세한 정보를 알 필요가 없도록 하는 것이 바람직하다. (*글이 전반적으로 잘 이해가 안됨* -> 코드 예시보고 이해됨.)
  - *결론으로 콜백은 이러한 문제를 해결 할 수 있음.* 프로그래머는 응용 프로그램이 각 요소를 처리하는 방법을 콜백 코드로 제공한다. 이런 식으로 유연성을 해치지 않고 명확하게 라이브러리와 응용 프로그램을 구별할 수 있다.
  - (정적 영역 방식의 언어인 c, c++) 콜백의 경우 이러한 인수를 변수 영역 외의 응용 프로그램 데이터 포인터에 이용한다.  (코드 예시 같이 볼 것!)
  - (동적 영역 방식의 언어,) 클로저를 이용하면 자동으로 응용 프로그램 데이터로 접근할 수 있다.
    - js 기준으로 environment variable 때문에?

### 의문

- 제네릭 프로그래밍?

- 폴리모피즘?

- 참고
  - <https://ko.wikipedia.org/wiki/%EC%BD%9C%EB%B0%B1>
  - <https://stackoverflow.com/questions/824234/what-is-a-callback-function/7549753#7549753>
    - callback을 call after로 보는 관점

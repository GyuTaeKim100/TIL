## 정의
 - 마이크로 서비스
   - 소프트웨어를 구축하기 위한 아키텍처이자 하나의 접근 방식
   - 애플리케이션을 상호 독립적인 최소 구성 요소로 분할
   - 모든 요소를 하나의 애플리케이션에 구축하는 전통적인 모놀리식 접근 방식 대신 마이크로 서비스에서 모든 요소가 독립적으로 연동되어 동일한 태스크를 완수
   - 다수의 애플리케이션 간에 유사한 프로세스를 공유하는 기능을 중시
   - 클라우드 네이티브 모델 구현을 위해 애플리케이션 개발을 최적화 하는 데 필요한 중 주요 구성 요소
   - 마이크로 서비스 기반 인프라
     -  개발자 : 고품질 소프트웨어를 보다 신속하게 제공
     -  고려 사항
        - 마이크로 서비스로 분할하는 것으로는 충분하지 않음
        - 애플리케이션을 관리하고 오케스트레이션하며 여기서 생성되고 수정되는 데이터를 처리해야 한다

 - 마이크로 서비스 자세히
   - 애플리케이션의 핵심 기능을 세분화하는 방식
   - 각 기능을 서비스
   - 기능 별 독립적으로 구축하고 배포 가능
   - 개별 서비스가 다른 서비스에 부정적 영향을 주지 않으면서 작동(또는 장애가 발생)할 수 있음을 의미합니다
   - 예시)
     - 온라인 구매 사이트
       -  제품 검색을 위해 사이트 검색창 사용 => 하나의 서비스
       -  구매자 선호도 데이터베이스에서 추출한 관련 상품에 대한 추천 내역 => 하나의 서비스
       -  온라인 장바구니에 항목을 추가하기 => 하나의 서비스
    - 애플리케이션의 핵심 기능이며 다른 서비스들과 독립적으로 작동
    - 마이크로서비스 아키텍처는 애플리케이션의 핵심 기능을 유연하게 결합할 뿐 아니라, 불가피한 장애, 향후 확장 여부 및 새로운 기능 통합에 대비할 수 있도록 서비스 간 커뮤니케이션 및 개발팀의 구조를 조정
    - 서비스 지향 아키텍처(SOA)
    - 애플리케이션 개발 초기
      -  최소한의 변경 사항이 있어도 자체적인 QA 주기에 따라 대규모 업데이트를 해야 함
      -  전체 애플리케이션의 소스 코드는 하나의 배포 유닛 등으로 내장 => 모놀리식
      - 애플리케이션에 오류 발생 시 전체를 오프라인으로 전환하고 운영 규모를 축소시킨 다음 문제 해결
      - 이 방식은 소규모 애플리케이션에서 여전히 실행 가능
      - 성장하는 기업들은 다운타임을 감당 할 수 없다
    - 서비스 지향 아키텍처는 애플리케이션을 별개의 재사용 가능한 서비스 단위로 분할
      - 엔터프라이즈 서비스 버스(ESB)를 통해 통신 (ESB는 무엇인가?)
      - 아키텍처에서는 특정 비즈니스 프로세스를 기반으로 구성된 개별 서비스가 통신 프로토콜(SOAP, ActiveMQ, Apache Thrift 등)을 준수하며 ESB를 통해 공유
      - 서비스 요소가 ESB를 통해 통합되어 하나의 애플리케이션을 구성
    - 장점
      -  서비스의 구축, 테스트, 수정을 동시에 수행 가능 => 더이상 모놀리식 개발 주기는 필요가 없다
      - ESB는 전체 시스템의 단일 장애점(single point of failure)을 나타내기 때문에 이러한 방식에서 모놀리식 제거는 새로운 모놀리식을 만들어낼 뿐이며, 잠재적으로 ESB가 전체 조직의 자체적인 장애 요소로 작용할 수 있는 것
  - SOA에서 마이크로서비스로~
    - 차이점
      -  마이크로서비스는 스테이트리스(stateless) 방식으로 서로 통신 가능
         - 내결함성이 더 높고 ESB에 대한 의존성은 더 낮다
           -  내결함성?
    - 마이크로서비스가 프로그래밍 언어에 구속 받지 않는 API(애플리케이션 프로그래밍 인터페이스)이기 떄문에 개발팀이 자체 툴을 선택할 수 있다
    - Linux 컨테이너를 활용해 애플리케이션의 여러 조각들을 독립적으로 작동시킬 수 있다
    - 각 개별 요소 및 라이프사이클에 대한 통제력은 훨씬 강화된다
    - 컨테이너화된 마이크로서비스는 API 및 DevOps팀과 함꼐 클라우드 네이티브 애플리케이션의 기반
  - 마이크로 서비스 장점
    - 출시 기간 단축
      -  개발 주기가 단축되기 때문에 마이크로 서비스 아키텍처는 보다 민첩한 배포 및 업데이트를 지원
    - 높은 확장성
      - 특정 서비스에 대한 수요가 증가함에 따라 필요에 따라 여러 서비스 및 인프라에 배포할 수 있다
    - 뛰어난 복구 능력
      - 독립적인 서비스들은 제대로 구축되기만 한다면 서로에게 영향을 주지 않는다
      - 부분 장애 발생 시 전체 어플리케이션이 다운되지 않는다
    - 손쉬운 배포
      - 마이크로서비스 기반 애플리케이션은 전통적인 모놀리식 애플리케이션에 비해 더욱 모듈화되고 규모가 작아졌기 때문에 배포에 따르는 우려 사항들이 사라졌다
    - 편리한 액세스
      -  하나의 큰 어플리케이션을 더 작은 조각으로 분할
      -  개발자들이 각 조각을 파악하고 업데이트하며 개선하기가 용이
      - 애자일 방식과 결합할 경우 개발 주기가 더욱 가속화 가능
    - 향상된 개방성
      -  다중 언어 지원(Polyglot) API를 사용하기 때문에 개발자들은 필요한 기능에 맞는 최적의 언어와 기술을 자유롭게 선택 가능
   - 당면 과제
     - 마이크로 아키텍처로의 전환을 고려 시
       - 직원들의 업무 방식의 변화도 고려 
         - 조직적, 문화적 변화를 과제의 일부분으로 인식 => 각 팀마다 자체적인 배포 주기가 있으며 고유한 고객군에 대한 고유한 서비스를 제공하기 떄문 (필수 사항)
     - 복잡성과 효율성
       1. 구축 
         - 서비스 간 종속성을 파악하는 시간 필요
         - 종속성 때문에 하나의 빌드를 완료 시 여러 다른 빌드가 트리거 될 수 있음을 인지
         - 마이크로서비스가 귀사의 데이터(왜 ?)에 미치는 영향을 고려
       2. 테스트
        - 통합 테스트 뿐 아니라 E2E 테스트를 수행하기가 어렵고 중요
        - 서비스가 서로 지원하도록 하기 위해 아키텍처를 어떻게 구성했는지에 따라 아키텍처의 한 부분에 장애가 발생하면 떨어져 있는 다른 부분에 장애를 일으킬 수 있다는 점을 유의
       3. 버전 관리
        - 새로운 버전 업데이트 시 이전 버전과 호환성에 문제가 발생 가능
        - 대안
            - 서로 다른 클라이언트용으로 여러 라이브 버전을 사용할 수 있다 (유지관리가 더 복잡해짐)
       4. 배포
        - 초기 구축 단계에서는 이 부분도 과제 범주
        - 배포를 쉽게 하려면 우선 상당한 정도의 자동화에 투자
        - 마이크로서비스의 복잡성 때문에 사람이 수동으로 배포하는 것이 버거워지기 때문
        - 서비스 룰 아웃을 어떻게 어떤 순서로 할 지 고민
       5. 로그 관리
        - 분산 시스템에서는 모든 내용을 한 곳에 모을 수 있는 중앙 집중식 로그가 필요
       6. 모니터링 
        - 문제의 근원을 정확히 집어내려면 시스템을 중앙에서 파악할 수 있는 능력 필요
       7. 디버그 
        - 원격 디버그는 선택 사항이 아니다
          - 해당 방식은 수십 수백개의 서비스를 관리 할 수 없다
       8. 연결성
          - 중앙집중식 또는 통합형 여부에 관계 없이 서비스 검색을 고려해야 한다

## 참고
- https://www.redhat.com/ko/topics/microservices
- https://developers.redhat.com/blog/2017/05/04/the-truth-about-microservices?extIdCarryOver=true&sc_cid=701f2000001OH7EAAW
    


### 2회 차 발제문
### 1. 방어적 복사와 카피-온-라이트의 차이점
- 복사 깊이적 차이점
	- 카피-온-라이트
		- 얕은 복사
	- 방어적 복사
		- 깊은 복사
- 복사 깊이적 차이점에 의해서 사용 시점의 차이가 발생한다.
	- 카피-온-라이트
		- 통제할 수 있는 데이터를 바꿀 때
			- 즉 단순 읽기 또는 참조를 통해서 값을 변경되지 않을 때			
	- 방어적 복사
		- 안전지대 경계의 진입로에서, 신뢰할 수 없는 코드와 상호 작용 시
			- 상호 작용은 안전지대의 경계 교차점에서 이루어지는 데이터의 입력, 출력을 의미한다.
			- 신뢰할 수 없는 코드가 공유되는 데이터를 참조를 통해서 값 변경을 할 수 있는 가능성을 배재할 수 없음.
- 비용 차이
	- 카피-온-라이트
		- 데이터 구조의 1 depth에 대해서만 복사가 진행 됨.
	- 방어적 복사
		- 데이터 구조의 전 계층에 대해서 복사가 진행됨.
		- 상대적으로 메모리 용량, 속도 측면에서 카피-온-라이트에 비해서 무거운 편이다.
		- 단 자주 사용되지 않고, 안전지대의 경계 교차점에서만 사용되므로, 빈도 또한 상대적으로 낮다.
- 의문
	- 만약 안전지대 내에서도, 참조를 통해 데이터가 변경되는 코드가 있다면, 이 경우는 카피-온-라이트가 아닌 방어적 복사를 해야 한다?
		- 구체적인 예시로, 데이터 계층 구조가 깊고, 데이터 계층 구조의 얕은 복사(참조가 복사됨)가 일어난 곳의 값을 변경하는 코드인 경우를 의미함.
		- 이 경우가 안전지대가 훼손되는 경우이고, 신뢰할 수 없는 코드에 의한 방어적 복사를 할 시점이다.
		- 즉 이 경우 또한, 신뢰할 수 없는 코드가 데이터에 접근이므로, 방어적 복사를 해야만 한다.
		- 앗싸리, 비용 고려 안하고 방어적 복사로 다 떼우면 가장 안전한게 아닐까 싶다. 코드의 복잡성이 높아질 수록, 카피-온-라이트에서도 참조에 의한 변경이 일어날 가능성을 배제할 수 없기 때문이다. (기획에 대한 의존도가 높지만) 

###  2. 채팅 서비스 라이브러리를 만들고 있다고 가정하여서, 이 라이브러리의 계층형 설계를 해보고, 그 설계도에서 추상화 벽에는 어떤 함수들이 필요한가?
- 가정
	- 채팅 서비스의 *Front-end*만 다룬다.
	- 채팅 서비스의 *비즈니스 로직에 대한 라이브러리*이다. UI 로직은 제외한다.
	- 채팅 서비스의 프로덕트의 기획마다 추상화 벽이 다를 수 있으므로 *간단히 요구사항을 정리*하자면
		1. 실시간성 X
			1. 백단에서는 특정 간격(예시로 1초 간격)으로 간격 내 발생한 모든 누적된 이벤트를 단번에 클라이언트에게 전달함.
		2. 동시성 (?)
			1. 사용자가 채팅창에 문자열을 입력 시 백단에서 먼저 비즈니스 로직에 대한 처리가 완료된 후, 백단에서 처리 된 결과만 채팅창에 출력된다. 
		3. 채팅방 내에서, 단체 채팅과 귓속말 채팅이 존재한다.
		4. 동기화
			1. 접속 시, 전체 채팅 히스토리(채팅방 시작 시점부터) 를 불러온다.
			2. 채팅 중 접속이 끊긴 경우, 끊긴 시점부터 재접속 성공 이전까지의 채팅 히스토리를 불러온다.
		5. 현재 정상적인 접속 여부를 실시간으로 확인한다.
		6. 타인이 접속, 접속 종료 시 안내 문구가 출력된다.
 
### 계층 구조
 - TODO
	- 데이터 타입을 정의 해본다.
	- 계층 간 데이터를 어떻게 주고 받을 지를 정의해본다.
	- Push 기반으로 계층간 데이터를 주고 받을 때와, Pull 기반으로 계층간 데이터를 주고 받을 때 차이점이 존재하는 지 확인해본다.

***

- ***채팅 UI 로직***
	- *역할*
		- 채팅 비즈니스 규칙 계층과 데이터를 기반으로 상호 작용한다.
			- 수신한 데이터를 기반으로 랜더링을 진행함.
			- 사용자에게 입력받은 데이터를 아래 계층에 전달함.
	***
	-  **채팅 비즈니스 규칙 계층**
		- *요구사항 3*
			- 메시지를 개인에게 송신한다.
			- 메시지를 개인에게 수신한다.
			- 메시지를 단체에게 전송한다.
			- 메시지를 단체에게 수신한다.
		- *요구사항 4*
			- 접속 시, 전체 채팅 히스토리 메시지 내역을 수신한다.
			- 특정 간격의 채팅 히스토리를 불러온다.
		- *요구사항 5*
			- 현재 정상적인 접속 여부를 실시간으로 확인한다.
		- *요구사항 6*
			- 타인이 접속한 정보를 수신한다.
			- 타인이 접속 종료한 정보를 수신한다.
***	
 - **제품에 대한 일반 동작 계층**
	 - 메시지 단위로 송신한다.
	 - 메시지 단위로 수신한다.
 - **제품에 관한 상세 동작 계층**
	-  패킷의 헤더를 추출한다.
		- *추가 설명*
			- 패킷은 서버와 클라이언트 간 프로토콜이다.
			- 패킷의 구성은 헤더와 페이로드로 이루어진다. 
			- 헤더는 메시지의 종류이고, 페이로드는 메시지의 내용이다.
	- 패킷의 페이로드를 추출한다.
	- 패킷의 헤더 별 페이로드를 헤더에 따라 분할한다.
		- 예시
			- 패킷의 헤더가 만약 *메시지를 단체에게 수신한다 (요구사항5)*인 경우, 페이로드는 리스트 타입으로 각각의 요소는 메시지에 대한 정보를 담고 있다.
			- 메시지에 대한 정보 구조 예시
				- 시각
				- 사용자
				- 내용
- 패킷 송수신 계층
	- 송신 버퍼
		- 역할
			- 위 계층은 송신 버퍼에게 메시지를 Push한다.
			- 아래 계층에게 버퍼 내 모든 패킷을 Push한다.
	- 수신 버퍼
		- 역할
			- 아래 계층에서 수신 버퍼에게 메시지를 Pull한다.
			- 위 계층에게 버퍼 내 모든 패킷을 Push한다.
- **버퍼 계층**
	- 버퍼 할당하기
	- 버퍼 해제하기
	- 버퍼 시작하기
	- 버퍼 정지하기
	- 버퍼 사이즈 재조정하기
	- 버퍼에 담긴 모든 역직렬화된 데이터를 Push한다.
	- 버퍼에 담긴 모든 직렬화된 데이터를 Pull 한다.
- **시스템 라이브러리**
	- 웹 소켓
	- 불변성 라이브러리
- **카피-온-라이트**
	- **자바스크립트 언어 기능**
        

### 3. 방금 여러분이 설계한 채팅 서비스 라이브러리에서 직접 구현을 통해, 설계를 개선할 곳이 있는가?
- 있다면 이유는 무엇인가?
	- 메모
		- 액션, 계산 ,데이터 고려...
- 없다면 이유는 무엇인가?
### 4. 콜백으로 분리하는 함수는 전역적, 함수 내부의 지역적,  또는 inline 방식으로 사용할 수 있다. 어떤 방식으로 사용할지에 대한 개인적인 의견을 말해보자.
- 어차피 모듈 시스템이므로, 모든 모듈 사이의 전역따윈 존재하기 어려움.




## 7장 신뢰할 수 없는 코드를 쓰면서 불변성 지키기
### 살펴볼 내용
- 레거시 코드 또는 신뢰할 수 없는 코드로부터, 내 코드를 보호하기 위한 **방어적 복사**를 만든다.
	- 카피-온-라이트를 적용할 수 없는 코드를 함께 사용해야 할 때
		- 바꿀 수 없는 라이브러리
		- 레거시 코드가 데이터를 변경시
- 얕은 복사와 깊은 복사를 비교한다.
- 카피-온-라이트와 방어적 복사를 언제 사용하면 좋은지 알 수 있다.

### 방어적 복사 (defensive copy)
- 특징
	- 불변성 원칙을 지키면서, 신뢰할 수 없는 코드와 상호작용할 때 사용한다
- 예시
	- 웹 API 
		- 암묵적인 방어적 복사
		- 요청 및 응답 시, JSON 데이터에 대해서 깊은 복사본(deep copy)
	- 시스템이 상호 간 통신 시
		- 직렬화와 역직렬화 시, 깊은 복사가 이루어진다.
	- 얼랭과 엘릭서
		- 두 프로세스가 서로 메시지를 송수신 시
			- 메일박스에 메시지 수신 시 복사된다.
			- 메일 박에가 메시지 송신 시 또한 복사된다.
		- 방어적 복사를 통해서, 얼랭 시스템의 핵심인 고가용성을 보장이 됨.

### 깊은 복사
- 특징
	- 원본과 어떤 데이터 구조도 공유하지 않는 것이 얕은 복사와 차이점이다.
		- 즉, 중첩된 모든 객체나 배열을 복사한다. (참조를 통한 공유 제거)
	- 만약 바뀌지 않는 값이라면, 얕은 복사를 통해서 원본과 복사본 간 참조를 통한 데이터를 공유하는 게 더 효율적이다.
	- 자바스크립트에서는 깊은 복사를 구현하는 것이 어렵다.
		- 최근 자바스크립트 스펙에 깊은복사 기능이 추가되었다. (…이름이 기억이 안남)

### 방어적 복사 규칙
- 규칙 1 : 데이터가 안전한 코드에서 나갈 때 복사하기
	1. 불변성 데이터를 위한 깊은 복사본을 만든다.
	2. 신뢰할 수 없는 코드로 복사본을 전달한다.
- 규칙 2 : 안전한 코드로 데이터가 들어올 때 복사하기
	 1. 변경될 수도 있는 데이터가 들어오면, 바로 깊은 복사본을 만들어 안전한 코드로 전달한다.
	 2. 복사본을 안전한 코드에서 사용한다.

### 기타
- 동시에 사용자 데이터 복사본 두 개(사용자를 객체로 표현)가 있는 경우, 어떤 것이 진짜 사용자인가?
		- 함수형 프로그래밍에서는 유일한 객체로 사용자를 표현하지 않는다.
		- 단지 사용자에 대한 데이터를 처리하고 기록한다.
		- 데이터는 이벤트에 대한 사실이다.
		- 사실은 필요할 때마다 여러 번 복사할 수 있다.
- 커피-온-라이트와 방어적 복사는 비슷한것 같다. 다른 점은? 둘다 필요한가?
		- 둘 모두 불변성을 유지하기 위해 사용된다.
		- 반드시 안전지대 내에서 카피-온-라이트만 옳은 것은 아니다.
			- 안전 지대 내에서도 방어적 복사로도 불변성을 유지할 수 있다.
			- 단지 방어적 복사는 깊은 복사를 한다. 이는 많은 비용을 필요로 한다.
			- 즉, 많은 복사본 때문에 연산과 메모리를 낭비하는 것을 막으려면, 안전지대 내에서는 카피-온-라이트를 사용하는 것이 좋다.
- 카피-온-라이트와 비교 (@TODO: 표)
		- 카피-온-라이트
			- 사용 시점
				- 통제할 수 있는 데이터를 바꿀 때
			- 사용처
				- 안전지대 내
					- 카피-온-라이트를 만들어서, 안전지대를 넓혀나간다.
			- 복사 방식
				- 얕은 복사
					- 필요한 부분만 최소한으로 복사한다.
			- 규칙
				- 바꿀 데이터의 얕은 복사를 만든다.
				- 복사본을 변경한다.
				- 복사본을 리턴한다.
			- 기타
				- 사용 빈도가 방어적 복사보다 높다.
- 방어적 복사
		- 사용 시점
			- 신뢰할 수 없는 코드와 데이터를 주고 받을 때
		- 사용처
			- 안전지대 경계에서, 데이터를 통한 상호작용 시
		- 복사 방식
			- 깊은 복사
				- 위에서 아래로 중첩된 데이터 전체를 복사한다.
				-  카피-온-라이트보다 비용이 더 크다.
				- 불변성 원칙을 구현하지 않은 코드로부터 데이터를 보호해준다.
					- 신뢰 할 수 없는 코드와 함께 사용할 때만 사용
			- 규칙
				- 안전지대로 들어오는 데이터에 깊은 복사를 만든다.
				- 안전지대에서 나가는 데이터에 깊은 복사를 만든다.

### 예제, 신뢰할 수 없는 코드 감싸기
- 개선 전
```
{
	// … 생략
	var cart_copy = deepCopy(shoping_cart);
	black_friday_promotion(cart_copy); // 함수 리턴값 외, 함수 인자로 값이 반환될 수 있음.
	Shopping_cart = deepCopy(cart_copy);
}
```
- 개선 후
```
{
	… 생략
	shopping_cart = black_friday_promotion_safe(shopping_cart)
}

function black_friday_promotion_safe(cart) {
	var cart_copy = deepCopy(cart);
	black_friday_promotion(cart_copy);
	return deepCopy(cart_copy); 

}
```


### 예제, 구독
```
	userChange.subscribe(function(user){
		var userCopy = deepCopy(user);
		// 바뀔 수도 있는 사용자 데이터만 들어온다.
		ProcessUser(userCopy);
		// 안전하지 않은 곳으로 나가는 데이터가 없다.
	});
```


### 카피-온-라이트의 한계
- 카피-온-라이트를 통해 형성된 안전지대(safe-zone)는 불변성이 유지되지만, 안전지대 밖의 신뢰할 수 없는 코드와 데이터를 주고 받아야 하는 경우에는 불변성이 유지되지 않는다.
	- 안전지대 밖으로 나가거나 들어오는 데이터는, 신뢰할 수 없는 코드로부터 잠재적으로 바뀔 가능성이 높다.
	- 이유는 신뢰할 수 없는 코드가 계속 데이터 참조를 가지고 있기 때문이다.
	- 이를 해결하기 위해서 방어적 복사가 필요하다.

### 결론
- 방어적 복사(depensive copy)
	- 불변성 유지시, 카피-온-라이트보다 강력하고 일반적인 원칙이다.
	- 장점
		- 불변성을 스스로 구현할 수 있다.
	- 단점
		- 더 많은 데이터를 복사하므로, 더 많은 비용을 소비함.
	- 활용
		- 카피-온-라이트와 함께 사용하면서, 필요시에만 적용한다. 
			- 얕은 복사와 깊은 복사를 때에 따라 잘 적용한다.

## 8장 계층형 설계 1
### 살펴볼 내용
- 소프트웨어 설계에 대한 실용적인 정의를 소개한다.
- 계층형 설계를 이해하고 어떤 도움이 되는지 알아본다.
- 꺠긋한 코드를 만들기 위해 함수를 추출하는 방법을 배운다.
- 계층을 나눠서 소프트웨어를 설계하면 왜 더 나은 생각을 할 수 있는지 알아본다.

### 소프트웨어 설계란
- 코드를 만들고, 테스트하고, 유지보수 하기 쉬운 프로그래밍 방법을 선택하기 위해 미적 감각을 사용하는 것
- 계층형 설계(stratified design)를 사용해 소프트웨어 설계를 위한 미적 감각을 키워본다.

### 계층형 설계란
- 소프트웨어를 계층으로 구성하는 기술
- 각 계층에 있는 함수는 바로 아래 계층에 있는 함수를 이용해 정의한다.
- 설계 감각을 키운다면, 소프트웨어를 고치고, 읽고, 테스트하고 재사용하기 쉬운 코드를 만들기 위한 계층 구조가 무엇인지 알 수 있다.
- 계층 별 목적이 있다.
- 각 계층을 정확히 구분하기가 어렵다.
	- 잘 구분하려면 구분하기 위한 다양한 변수(?)를 찾고 찾은 것을 가지고 어떻게 해야 하는지 알아야 한다.
- **가장 좋은 설계**를 위한 절대 공식과 그 공식을 만드는 변수는 많으나, 복잡하게 섞여 있어 찾기 어렵다.
- 좋은 설계를 위한 감각을 개발하고 그 감각을 따라가면 찾을 수 있다.
- 코드를 읽을 때 더 좋은 설계를 알려주는 신호를 찾는 방법을 배워야 한다.

### 설계 감각 키우기
- 전문가(지식)의 저주
	- 잘하지만 어떻게 하는지 설명하지 못함.
	- 설명하는 것이 블랙박스와 같기 때문이다.
	- 블랙박스를 설명하지 못하는 이유는 복잡하기 떄문이다.
	- 블랙박스는 복잡하고 다양한 입력을 받아 복잡하고 다양한 결과물을 낸다.
- 계층형 설계를 키우기 위한 입력
	- 함수 본문
		- 길이
		- 복잡성
		- 구체화 단계
		- 함수 호출
		- 프로그래밍 언어의 기능 사용
	- 계층 구조
		- 화살표 길이
		- 응집도
		- 구체화 단계
	- 함수 시그니처
		- 함수명
		- 인자 이름
		- 인잣값
		- 리턴값
- 계층형 설계 감각을 키우기 위한 출력
	- (전문가도 어떻게 조합하는지 설명하지 못한다는 것을 기억하면서)
	- 조직화
		- 새로운 함수를 어디에 놓을지 결정
		- 함수를 다른 곳으로 이동
	- 구현
		- 구현 바꾸기
		- 함수 호출하기
		- 데이터 구조 바꾸기
	- 변경
		- 새 코드를 작성할 곳 선택하기
		- 적절한 수준의 구체화 단계 결정하기

### 계층형 설계 패턴
- 패턴 1: 직접 구현
	- 직접 구현된 함수를 읽을 때, 함수 시그니처가 나타내고 이쓴ㄴ 문제를 함수 본문에서 적절한 구체화 수준에서 해결해야 한다.
	- 만약 너무 구체적이라면 코드에서 나는 냄새이다.
- 패턴 2: 추상화 벽
	- 호출 그래프에 어떤 계층은 중요한 세부 구현을 감추고 인터페이스를 제공한다.
	- 인터페이스를 사용하여 코드를 만들면 높은 차원으로 생각할 수 있다.
	- 고수준의 추상화 단계만 생각하면 되기 때문에 두뇌 용량의 한계를 극복할 수 있다.
- 패턴 3: 작은 인터페이스
	- 시스템의 크기가 커질수록, 비즈니스 개념을 나타내는 중요한 인터페이스는 작고 강력한 동작으로 구성해야 한다.
	- 다른 동작도 직간접적으로 최소한의 인터페이스를 유지하면서 정의해야 한다.
- 패턴 4: 편리한 계층
	- 계층형 설계 패턴과 실천 방법은 개발자의 요구를 만족시키면서 비즈니스 문제를 잘 풀 수 있어야 한다.
	- 소프트웨어를 더 빠르고 고품질로 제공하는 데 도움이 되는 계층에 시간을 투자 해야한다.
	- 코드와 그 코드가 속한 추상화 계층은 작업할 때 편리해야 한다.

### 용어
- 오프-바이-원 (off-by-one)
	- 주로 배열을 반복해서 처리할 때 ’크다‘ 또는 ’크거나 같다‘와 같은 비교문을 잘못 선택해 의도하지 않게 마지막 항목을 처리하지 못하거나 처리하는 오류를 말한다.

### 패턴1: 직접 구현
- 어떻게 구현된 코드를 잘 읽을 지 알아본다.
- 강력한 기능의 함수 일지라도, 복잡하지 않게 함수를 표현해야 한다.
- 코드 예시
	- 개선 전
		```
		functionfreeTieClip (cart){
			var hasTie = false;
			var hasTieClip = false;

			for (var i = 0; i < Cart.length; i++ )
			{
				var item = cart[i];
				if(item.name === ‘tie’) {
					hasTie = true;
				}
				if(item.name === ‘tie clip’) {
					hasTieClip = true;
				}
			}
			
			if (hasTie && !hasTieClip) {
				var tieClip = make_item(“tie clip”, 0);
				return add_item(cart, tieClip); // 참조로 값 변경
			}
			return cart;
		}
	   ```
		- 단점
			- 설계 원칙을 가지지 않음.
				- 직접 구현을 따르고 있지 않음.
				- freeTieClip() 함수가알아야 할 필요가 없는 구체적인 내용을 담고 있다.
					- 기획적인 코드가 장바구니가 배열임이 관심사인가?
					- 배열에서 오프-바이-원(off-by-one) 에러가 생긴다면?
	- 베이스 코드
		```
		// 베이스 코드


		// 제품 추가하기
		function add_item (cart, item) {
			return add_element_last(cart, item);
		}

		// 제품 삭제하기
		function remove_item_by_name (cart, name) {
			var idx = null;
			for (var i = 0; i < cart.length ; i++) {
				if(cart[i].name === name)
				{
					idx = i;
				}
			}
			if (idx !== null){
				return removeItems(cart, idx, 1);
			}
			return cart
		}

		// 합계 계산하기
		function calc_total(cart) {
			var total = 0;
			for(var i = 0; i < cart.length; i++) {
				var item = cart[i];
				total += item.price;
			}
			
			return total;
		}

		// 제품이름으로 가격 설정하기
		function setPricebyName (cart, name, price) {
			var cartCopy = cart.slice();
			for (var i =0; i < cartCopy.length ; i++) {
				if(cartCopy[i].name === name) {
					cartCopy[i] = setPrice(cartCopy[i], price);
				}
			}
			return cartCopy;
		}

		// 세금 계산하기
		function cartTax (cart) {
			return calc_tax(calc_total(cart)); 
		}

		// 무료배송이 되는지 확인하기
		functiongets_free_shipping(cart) {
			return calc_total(cart) >= 20; 
		}``

	   ```
	- 개선 1
		
	```
		function freeTieClip (cart) {
			var hasTie = isInCart(cart, “tie”);
			var hasClip = isInCart(cart, “tie clip”);

			if (hasTie && !hasTieClip) {
				var tieClip = make_item(“tie clip”, 0);
				return add_item(cart, tieClip);
			}
			
			return cart 
		}	


		// 반복문을 추출해서 새로운 함수를 만든다.
		function isInCart (cart, name) {
			for (var i =0; i < cart.length ; i++) {
				if(cart[i].name === name) {
					return
				}
				
			}
		}

	```

### 위 예제를, 호출 그래프를 시각화하기
	- freeTieClip()
		- 개선 전
			- (1단계 아래) array index, for loop, make item(), add_item
			- 모두 같은 추상화 수준인가?
				- 배열과 배열 인덱스를 참조하는 기능은 더 낮은 추상화 단계이다.
				- 한 함수가 서로 다른 추상화 단계를 사용하면 코드가 명확하지 않아 읽기 어렵다.
		- 개선 후
			- (1단계 아래) isInCart(), make_item(), add_item()
			- 대략적으로 비슷한 추상화 단계를 사용하고 있다.
			- 장바구니가 배열인지 몰라도 된다.
				- for문을 순회하지 않고, cart는인자로만 전달됨을 의미함.
	- 직접 구현 패턴을 사용하면 비슷한 추상화 계층에 있는 함수를 호출한다.

### 쉬는 시간
- 호출 그래프가 정말 필요한가? 코드를 봐도 문제를 알 수 있을 것 같다.
	- 답
		- 호출 그래프는 단지 알고 있는 내용을 확인시켜 줄 뿐이다.
		- 만약 함수를 더 추가한다면, 더 많은 계층이 생길 수 있다.
		- 계층이 많으면 호출 그래프를 통해 시스템 계층이 어떻게 구성되어 있는지 전체적으로 보는 데 도움이 될 것이다. (시각화)
		- 복잡한 계층을 단순화는 작은 코드로는 얻을 수 없다.
- 모든 다이어그램을 다 그려야 하는가?
	- 답
		- 대부분은 다이어그램을 그리지 않아도 된다.
		- 협업시 커뮤니케이션 측면에서, 다이어그램을 화이트보드에 공유한다면, 좋은 커뮤니케이션 도구가 된다.
		- 설계에 대한 논의는 추상적인 이야기가 될수 있다. 다이어그램이 있다면 추상적인 대화가 아닌 구체적인 것을 보면서 논의할 수 있다.
- 앞에서 그린 계층이 정답인가? 모두가 동의할 수 있는 객관적인 것인가?
	- 답
		- 철학적인 질문이다.
		- 계층형 설계는 각자의 관점으로 사람들이 사용하면서 습득한 것
		- 계층형 설계는 코드 구조를 자세히 볼 수 있는 고글이다.
		- 고글을 통해, 재사용, 테스트, 유지보수 쉬운 코드를 만들 수 있는 방법을 찾을 수 있다.

- 앞의 예제에서 제가 그린 다이어그램에는 더 많은 계층이 있다. 잘못한 것일까?
		- 답
			- 자유이다.
	- 여러 고글을 써서 마음껏 확대 및 축소하여 봐도 된다.


- remove_item_by_name () 함수 그래프 그려보기
	- 예제 코드
		```
			function remove_item_by_name(cart, name) {
				var idx = null;
				for (var i = 0; i < cart.length ; i++) {
					if (cart[i].name === name) {
						idx = i;
					}
				}
				if (idx != null) {
					return removeItems(cart, idx, 1); 
				}
				return cart;
			}
	   ```
	- 다이어긂
		- 1계층
		- 2계층
			- freeTieClip()
		- 3계층
		- 4계층
			- isInCart(), make_item(), add_item(),  remove_item_by_name()
			   - remove_item_by_name()
				   - 같은 박스를 가리킨다는 것은 같은 계층에 있어도 좋다는 정보이다.
		- 5계층

  ### 같은계층에 있는 함수는 같은 목적을 가져야 한다.
  - 계층이 서로 구분되는 목적이 있다면, ㅎ마수가 위치할 계층을 선택하는 데 좋은 정보로 사용할 수. 있따.
  - 계층의 목적은 각 계층에 있는 함수의 목적과 같다.
  - 계층 별 목적
	  - 장바구니 비즈니스 규칙
	  - 일반적인 비즈니스 규칙
	  - 장바구니 기본 동작
	  - 제품에 대한 기본 동작
	  - 카피-온-라이트 동작
	  - 자바스크립트 언어 기능
  - 각 계층은 추상화 수준이 다르다.
  - 어떤 계층에 있는 함수를 읽거나 고칠 때 낮은 수준의 구체적인 내용은 신경 쓰지 않아도 된다.
	  - 예시
		  - ’장바구니 비즈니스 규칙‘ 계층에 있는 함수를 쓸 때, 장바구니가 배열로 구현되어 있다는 것과 같은 구체적인 내용은 신경쓰지 않아도 된다.
  - 다이어그램은 함수가 호출하는 것을 있는 그대로 표현하는 것이기 때문에 함수를 어떤 계층에 놓을지 바로 알 수 있다.
	  - 다이어그램은 코드를 높은 차원에서 볼 수 있는 좋은 도구이다.

### 3단계 줌 레벨
- 전역 줌 레벨
	- 계층 사이에 상호 관계를 포함해서 모든 문제 영역을 살펴볼 수 있다.
- 계층 줌 레벨
	- 한 계층과 연결된 바로 아래 계층을 볼 수 있는 줌 레벨이다.
- 함수 줌 레벨
	- 함수 하나와 바로 아래 연결된 함수들을 볼 수 있다.
- 다양한 줌 레벨로 설계 문제를 찾거나 고칠 수 있다. 

### 화살표
- 화살표가 복잡해 보이는 것을 숨길 수 없다.
- 다이어그램이 복잡하다면 코드가 정돈되어 있지 않기 때문이다.
- 이러한 복잡함을 정리하기 위한 방법을 찾아야 한다.
- 화살표 간 길이가 다른 경우, 특히 다양한 계층을 넘나드는 것은 같은 구체화 수준이 아니라는 증거이다.

### 함수 줌 레벨을 사용하면 함수 하나가 화살표를 비교할 수 있다.
- 만약 다른 두 계층에 있는 동작을 사용하고 있는 경우
	- 직접 구현 패턴에는 맞지 않다.
	- 모두 같은 길이의 화살표를 가져야 한다.
	- 가장 일반적인 방법은 중간에 함수를 두는 것이다 (…사진 생략)
	- 언어 기능을 사용하는 긴 화살표를 줄여야 한다.
- 코드 예시
	- 개선 전
```
	function remove_item_by_name (cart, name) {
		vart idx = null;
		for (var idx= 0; i < cart.length; i++) {
			idx = i;
		}
		if(idx !== null) {
			return removeItems(cart, idx, 1);
		}
		return cart
	}
```
	- 개선 후
```
	function remove_item_by_name(cart, name) {
		var idx = indexOfItem(cart, name);

		// 의문으로,이런 조건문 조차 선언적으로 처리할 수 있을까?
		if(idx !== null) {
			return removeItems(cart, idx, 1);
		}
		return cart;
	}

	function indexOfItem (cart, name) {
		for (var i = 0; i < cart.length ; i++) {
			if (cart[i].name === name) {
				return i;
			}
		}
		return null;
	}
```

	- 가독성이 향상되었다.
	- indexOfItem() 함수는 removeItems 함수보다 계층상 조금 위에 있다.
		- 이유는 배열에 있는 항목이 name속성을 가지고 있음을 알아야 한다.
		- 즉 removeItems() 함수는indexOfItems() 함수보다더 일반적이고, 조금 더 낮은 계층에 있다.
	- 재사용을 통해 코드가 더 짧아졌고, 계층도 명확해지는 장점이 있다.
		- 재사용을 헀을 때 이런 장점이 항상 명확해 보이는 것은 아니다.

### 쉬는 ;시간
- setPriceByName() 함수가 설계가 좋아진 것이 맞나요? 그래프가 직접 구현인 것 같지 않고 더 복잡해진 것 같다.
	- 이런 질문이설계가 가장 어려운 점이기도 하다.
	 - 최선의 설계를 결정하는 공식은 없다.
	 - 코드를 만드는 방법 뿐 아니라 개발자의 기술 수준 등 많은 요소가 복잡하게 연결되어 최선의 설계를 결정한다.
	 - 코드나 호출 그래프를 개선할 수 있는 것을 찾을 수 있따.
	 - 지속적인 참구와 직관이 필요로 하다.
	 - 설계는 어렵고, 개발자들도 서로 동의하지 않을 수도 있고, 상황에 따라 좋은 설계의 기준이 달라지기도 한다.
	 - 그래서 설계에 대해 이야기할 떄는 같은 용어를 사용하는 것이 중요하고 상황을 고려해서 평가해야 한다.

### 직접 구현패턴 리뷰
- 직접 구현한 코드는 한 단계의 구체화 수준에 관한 문제만 해결한다.
	- 좋은 설계를 고민하지 않고만든 코드는 읽거나 고치기 어렵다.
	- 왜 어려울까?
		- 코드가 서로 다른 구체화 단계에 있으면 읽기 어렵다.
		- 코드를 읽을 때 이해해야 할 것이 많이 있는데, 구체화 단게가 다르면 이해하기가 더 어렵다.
		- 직접 구현하면 코드를 읽기 위해 알아야 하는 구체화 단계의 범위를 줄일 수 있다.
- 계층형 설계는 특정 구체화 단계에 집중할 수 있게 도와준다.
	- 코드에 있는 다양한 단서를 통해 구체화 수준에 집중하다 보면 설계 감각을 키울 수 있고 코드를 필요에 알맞게 바꿀 수 있다.
- 호출 그래프는 구체화 단계에 대한 풍부한 단서를 보여준다.
	- 큰 그림으로 한 번에 보기에는 너무 많은 정보가 있다. 
	- 호출 그래프는 함수가 서로 어떻게 연결되어 있는지 보여준다.
	- 함수 시그니처와 본문, 호출 그래프와 같은 다양한 단서를 가지고 직접 코드 패턴을 적용할 수 ㅣㅆ다.
- 함수를 호출하면 더 일반적인 함수로 만들 수 있다.
	- 직접 구현 패턴을 적용하는 방법의 하나이다.
	- 함수가 더 구체적인내용을 다루지 않도록 함수를 일반적인 함수로 뺴내는 것이다.
	- 일반적인 함수는 보통 구체적인 내용을 하나만 다루기 때문에 테스트하기 쉽다.
	- 명확한 코드와 알맞는 이름을 가진 함수는 더 읽기 쉽다.
- 일반적인 함수가 많을수록 재사용하기 좋다.
	- 함수로 빼내면 재사용할 수 있는 곳이 보인다. 중복코드를 찾기 위해 함수를 빼내는 것과 다르다.
	- 구현을 명확하게 하기 위해 일반적인 함수를 빼내는 것이다.
	- 일반적인 함수는 구체적인 함수보다 더 많은 곳에서 쓸 수 있다.
	- 그리고 사용할 곳을 따로 찾지 않아도 재사용할 수 있는 곳을 발견할 수 있을 것이다.
- 복잡성을 감추지 않는다.
	- 직접 구현 패턴을 적용한 코드처럼 보이게 만드는 것은 쉽다.
	- 명확하지 않은 코드를 감추기 위해 ’도우미 함수(helper function)‘을 만들면 된다.
	- 하지만 이렇게 하는 것은 계층형 설계가 아니다.
	- 계층형 설계에서 모든 계층은 바로 아래 계층에 의존해야 한다.
	- 복잡한 코드를 같은 계층으로 옮기면 안된다.
	- 더 낮은 구체화 수준을 가진 일반적인 함수를 만들어 소프트웨어에 직접 구현 패턴을 적용해야 한다.

### 요점 정리
- 계층형 설계는 코드를 추상화 계층으로 구성한다. 각 계층을 볼 때 다른 계층에 구체적인 내용은 몰라도 된다.
- 문제 해결을 위한 함수를 구현할 때 어떤 구체화 단계로 쓸지 결정하는 것이 중요하다. 그래야 함수가 어떤 계층에 속할지 알 수 있다.
- 함수가 어떤 계층에 속할지 알려주는 요소는 많다. 함수 이름과 본문, 호출 그래프 등이 그런 요소이다.
- 함수 이름은 의도를 알려준다. 비슷한 목적의 이름을 가진 함수를 함께 묶을 수 있다.
- 함수 본문의 중요한 세부 사항을 알려준다. 함수 본문은 함수가 어떤 계층 구조에 있어야 하는지 알려준다.
- 호출 그래프로 구현이 직접적이지 않다는 것을 알 수 있다. 함수를 호출하는 화살표가 다양한 길이를 가지고 있다면 직접 구현되어 있지 않다는 신호이다.
- 직접 구현 패턴은 함수를 명확하고 아름답게 구현해 계층을 구성할 수 있도록 알려준다.

## 9장 
- 살펴볼 내용
	- 코드를 모듈화하기 위해 추상화 벽을 만드는 법을 배운다.
	- 좋은 인터페이스가 어떤 것이고, 어떻게 찾는지 알아본다.
	- 설계가 이만하면 되었다고 할 수 있는 시점을 안다.
	- 왜 계층형 설계가 유지보수와 테스트, 재사용에 도움이 되는지 이해한다.

### 패턴 2 리뷰 : 추상화 벽
- 추상화 벽 위에 있는 코드는 데이터 구조와 같은 구체적인 내용을 신경쓰지 않아도 된다.
	- 인터페이스 측면
		- 소비자의 주 관심사만 생산자가 노출시킨다.
	- 소비자의 인터페이스 사용에 대한 러닝 커브를 줄인다.
		- 인터페이스의 세부사항을 모르더라도, 또는 인터페이스 내 본문이 선언적으로 일반화되어서 자연어적으로 이해가 가능함.
- 추상화 단계의 모든 함수는 비슷한 세부 사항을 무시할 수 있도록 정의한다. (블랙박스화)
	- 때로는 구체적인 것이 버그를 만든다.
	- 세부적인 것을 신경쓰지 않고, 쉽게 코드를 만들거나 수정할 수 있다.
	- 예시
		- 반복문
			- 초기값을 정확히 입력했는가?
			- 반복문 종료 조건에 오프-바이-원(off-by-one) 에러가 있는가?
- 추상화 벽으로 추상화를 강력하고 명시적으로 만든다. 
- 바뀌지 않을지도 모르는 코드를 언젠가 쉽게 바꿀 수 있게 만들려면 함정(어떤 함정?)에 빠지지 않아야 한다. 추상화 벽을 사용하면 코드를 쉽게 고칠 수 있다.
	- 코드를 쉽게 고치는 것이 주목적으로 추상화 벽을 사용하는 것이 아니다.
	- 추상화 벽은 팀 간 커뮤니케이션 비용을 줄이고, 복잡한 코드를 명확하게 하기 위해 전략적으로 사용해야 한다.
		- 팀 간에 조율할 것을 줄인다.
		- 각 팀에 관한 구체적인 내용을 서로 신경쓰지 않아도 일 할 수 있다. 
			- 즉 생산자 관점에서 인터페이스 사용을 위해서, 소비자와 의존성 제거
			- 생산자 또한 인터페이스 생성 시, ... 생략
- 핵심으로, 소비자의 주 관심사만 다루는 것이 추상화 벽의 핵심이다.
	- 블랙박스화.
	- 인터페이스 측면에서 사용과 생산 및 유지보수의 분리? (추후 구체적)


### 패턴3 리뷰: 작은 인터페이스
- 추상화 벽에 만든 함수는 인터페이스이다.
- 추상화 벽에 있는 인터페이스로 어떤 값의 집합에 접근하거나 조작할 수 있다.
- 계층형 설계에서 완전한 추상화 벽과 최소한의 인터페이스 사이에 유연하고 조율해야 하는 점이 있다.
	- 의문
		- 예시는?
- 추상화 벽을 작게 만들어야 하는 이유
	1. 추상화 벽에 코드가 많을수록 구현이 변경되었을 때 고쳐야 할 것이 많다.
	2. 추상화 벽에 있는 코드는 낮은 수준의 코드이기 때문에 더 많은 버그가 있을 수 있다.
		1. 의문
			1. ?
	3. 낮은 수준의 코드는 이해하기 더 어렵다.
	4. 추상화 벽에 코드가 많을수록 팀 간 조율해야 할 것도 많아진다.
	5. 추상화 벽에 인터페이스가 많으면 알아야 할 것이 많아 사용하기 어렵다.
- 실천법
	- 상위 계층에 어떤 함수를 만들 때, 가능한 현재 계층에 있는 함수로 구현하는 것이 작은(최소 갯수의) 인터페이스를 실천하는 방법이다.
	- 함수의 목적과 의도를 잘 파악하고, 어떤 계층에 구현하는 것이 적합할 지 고려하자.
	- 일반적으로 그래프에서 상위 계층에 구현하는 것이 좋다.
	- 추상화 벽을 개선 시, 작은 인터페이스를 사용했지만 사실 모든 계층에서 쓸 수 있다.
		- 단 필요한 최소한의 함수만 가지고 있어야만 한다.
		- 함수가 공개 된 이후, 바뀌어도 안되고 나중에 더 늘어서도 안된다.
	- 결론적으로 함수는 바뀌어도 안되고(인터페이스 소비자에게 혼란 초래, 기존 설계 계층화에 ....) 나중에 더 늘어서도 안된다. 계층이 가진 함수는 완전하고, 적고, 시간이 지나도 바뀌지 않아야 한다. 이것이 작은 인터페이스가 전체 계층에 사용되는 이상적인 모습이다.
	- 호출 그래프 하위 계층에 작고 강력한 동작을 만들었을 때 이런 모습을 볼 수 있다. 
		- 하지만 이상적인 모습을 목표로 하는 것보다 현실적으로 이 목표에 가려고 하는 노력이 더 중요하다.
	- 함수의 목적에 맞는 계층이 어디인지 찾는 감각을 기르는 것이 가장 중요하다.
	- 하려는 일이 적은 함수로 잘할 수 있는가? 목적에 맞게 바꾸려고 하고 있는가?

### 패턴 4: 편리한 계층 
- 이전 3가지 계층에 비해서, 조금 더 현실적이고 실용적인 측면을 다룬다.
- 규모적으로 커다란 계층을 만들면 뿌듯하다?
	- 강력해 보이고 고민해야 할 것이 별로 없다?
	- 강력한 추상화 계층은 만들기 어렵다.
	- 시간이 지나면 열심히 만든 추상화 벽이 크게 도움이 되지 않는다고 느낄 것이다.
	- 완벽하지 않고, 없는 것이 더 좋을 것이라고 느낄 지도 모른다.
	- 이렇게 추상화 벽을 높게 쌓은 경험이 있을 것이다. 
	- 이런 실험과 실패도 과정의 일부이다.
	- 추상화 계층을 높게 만드는 것은 어렵다.
- 추상화는 가능한 일과 불가능한 일의 차이를 나타내기도 한다.
- 자바스크립트 언어는 기계어에 대한 추상화 벽을 제공한다.
	- 이런 추상 계층은 어떻게 생각하고 만들었을까?
	- 수십 년에 걸쳐 수천 명의 사람들이 강력한 파서와 컴파일러 그리고 가상 머신을 만들었다.
	- 비즈니스 문제를 해결하기 위해 일하고 있는 개발자로서, 이처럼 거대한 추상화 계층을 만들 시간적 여유는 없다. 너무 오래 걸리고 비즈니스는 기다려주지 않는다.
- 편리한 계층 패턴은 언제 패턴을 적용하고, 또 언제 멈춰야 하는지 실용적인 방법으로 알려준다.
	- 자문해보자. "지금 편리한가?"
	- 만약 작업하는 코드가 편리하다고 느낀다면 설계는 조금 멈춰도 된다.
		- 반복문은 감싸지 않고 그대로 두고 호출 화살표가 조금 길어지거나 계층이 다른 계층과 섞여도 그대로 두자.
	- 반대로, 코드가 지저분하다고 느낀다면 다시 패턴을 적용하자.
	- 어떤 코드도 이상적인 모습에 도달할 수 없다.
	- 언제 설계와 새로운 기능의 필요성 사이 어느 지점에 머물게 된다.
	- 개발자로서의 필요성과 비즈니스 요구사항 모두를 만족시켜야 한다.
		- 즉 소프트웨러르 더 빠르고 고품질로 제공하는 데 도움이 되는 계층에 시간을 투자해야 한다.
		- 코드와 그 코드가 속한 추상화 계층은 작업할 때 편리해야 한다.
			- 즉 어떤 계층에 코드를 추가하더라도, 재사용하기 쉽고, 테스트하기 쉬우며, 고치기 쉬운 코드를 유지할 수 있어야 한다.


### 10장: 일급 함수 1
### 살펴보기
- 왜 일급 값이 좋은지 알아보자.
- 문법을 일급 함수로 만드는 방법에 대해 알아보자.
- 고차 함수로 문법을 감싸는 방법을 알아보자.
- 일급 함수와 고차 함수를 사용한 리팩토링 두 개를 살펴보자.

### 요약
- 일급 값은 변수에 저장할 수 있고 인자로 전달하거나 함수의 리턴값으로 사용할 수 있다. 일급 값은 코드로 다룰 수 있는 값이다.
- 언어에는 일급이 아닌 기능이 많이 있다. 일급이 아닌 기능은 함수로 감싸 일급으로 만들 수 있다.
- 어떤 언어는 함수를 일급 값처럼 쓸 수 있는 일급 함수가 있다. 일급 함수는 어떤 단계 이상의 함수형 프로그래밍을 하는 데 필요로 하다.
- 고차 함수는 다른 함수에 인자를 넘기거나 리턴값으로 받을 수 있는 함수이다. 고차 함수로 다양한 동작을 추상화할 수 있다.
- 함수 이름에 암묵적 인자는 함수의 이름으로 구분하는 코드의 냄새이다.
	- 이 냄새는 코드로 다룰 수 없는 함수 이름 대신 일급 값인 인자로 바꾸는 암묵적 인자를 드러내기 리팩토링을 적용해서 없앨 수 있다.
- 동작을 추상화하기 위해 본문을 콜백으로 바꾸기 릭팩토링을 사용할 수 있다. 서로 다른 함수의 동작 차이를 일급 함수 인자로 만든다.


## 11장: 일급 함수 2
### 1. 코드의 냄새: 함수 이름에 있는 암묵적 인자
- 냄새를 일급 값으로 바꾸면 표현력이 더 좋아진다.
- 함수 이름에 있는 암묵적 인자는 코드의 냄새이다.
- 특징
	- 본문을 포함해서, 거의 똑같이 구현된 함수가 있다.
	- 함수 이름이 구현에 있는 다른 부분을 가리킨다.

### 2. 리팩터링: 암묵적 인자를 드러내기
- 함수 이름에 있는 암묵적 인자를 어떻게 명시적인 함수 인자로 바꿀 수 있을까?
- 암묵적 인자가 일급 값이 되도록 함수에 인자를 추가한다.
- 잠재적 중복을 없애고 코드의 목적을 더 잘 표현할 수 있다.
- 단계
	1. 함수 이름에 있는 암묵적 인자를 확인한다.
	2. 명시적인 인자를 추가한다.
	3. 함수 본문에 하드 코딩된 값을 새로운 인자로 바꾼다.
	4. 함수를 호출하는 곳을 고친다.

### 3. 리팩터링: 함수 본문을 콜백으로 바꾸기
- 어떤 부분(비슷한 함수에 있는 서로 다른 부분)을 콜백으로 바꾼다.
- 일급 함수로 어떤 함수에 동작을 전달할 수 있다.
- 코드를 고차함수로 만드는 강력한 방법이다.

- 단계
	- 본문에서 바꿀 부분의 앞부분과 뒷부분을 확인한다.
	- 리팩토링 할 코드를 함수로 빼낸다.
	- 빼낸 함수의 인자로 넘길 부분을 또 다른 함수로 빼낸다.


### 12장 : 함수형 반복
- 생략

#